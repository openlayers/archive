{"version":3,"sources":["webpack:///./raster.js"],"names":["vgi","pixel","const","r","g","b","summarize","value","counts","min","max","num","values","length","index","Math","floor","delta","bing","_src_ol_source_BingMaps_js__WEBPACK_IMPORTED_MODULE_4__","key","imagerySet","raster","_src_ol_source_Raster_js__WEBPACK_IMPORTED_MODULE_5__","sources","operation","pixels","data","threshold","lib","set","on","event","Array","i","createCounts","get","resolution","timer","clearTimeout","setTimeout","yScale","d3","scaleLinear","domain","range","plotHeight","bar","chart","selectAll","enter","append","attr","count","barWidth","transition","changed","let","area","tip","html","toFixed","replace","message","style","left","chartRect","top","y","opacity","each","bind","schedulePlot","_src_ol_Map_js__WEBPACK_IMPORTED_MODULE_0__","layers","_src_ol_layer_js__WEBPACK_IMPORTED_MODULE_2__","source","_src_ol_layer_js__WEBPACK_IMPORTED_MODULE_3__","target","view","_src_ol_View_js__WEBPACK_IMPORTED_MODULE_1__","center","zoom","minZoom","maxZoom","select","node","getBoundingClientRect","document","body"],"mappings":"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","file":"raster.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from '../src/ol/layer.js';\nimport BingMaps from '../src/ol/source/BingMaps.js';\nimport RasterSource from '../src/ol/source/Raster.js';\n\nconst minVgi = 0;\nconst maxVgi = 0.25;\nconst bins = 10;\n\n\n/**\n * Calculate the Vegetation Greenness Index (VGI) from an input pixel.  This\n * is a rough estimate assuming that pixel values correspond to reflectance.\n * @param {Array.<number>} pixel An array of [R, G, B, A] values.\n * @return {number} The VGI value for the given pixel.\n */\nfunction vgi(pixel) {\n  const r = pixel[0] / 255;\n  const g = pixel[1] / 255;\n  const b = pixel[2] / 255;\n  return (2 * g - r - b) / (2 * g + r + b);\n}\n\n\n/**\n * Summarize values for a histogram.\n * @param {numver} value A VGI value.\n * @param {Object} counts An object for keeping track of VGI counts.\n */\nfunction summarize(value, counts) {\n  const min = counts.min;\n  const max = counts.max;\n  const num = counts.values.length;\n  if (value < min) {\n    // do nothing\n  } else if (value >= max) {\n    counts.values[num - 1] += 1;\n  } else {\n    const index = Math.floor((value - min) / counts.delta);\n    counts.values[index] += 1;\n  }\n}\n\n\n/**\n * Use aerial imagery as the input data for the raster source.\n */\nconst bing = new BingMaps({\n  key: 'As1HiMj1PvLPlqc_gtM7AqZfBL8ZL3VrjaS3zIb22Uvb9WKhuJObROC-qUpa81U5',\n  imagerySet: 'Aerial'\n});\n\n\n/**\n * Create a raster source where pixels with VGI values above a threshold will\n * be colored green.\n */\nconst raster = new RasterSource({\n  sources: [bing],\n  /**\n   * Run calculations on pixel data.\n   * @param {Array} pixels List of pixels (one per source).\n   * @param {Object} data User data object.\n   * @return {Array} The output pixel.\n   */\n  operation: function(pixels, data) {\n    const pixel = pixels[0];\n    const value = vgi(pixel);\n    summarize(value, data.counts);\n    if (value >= data.threshold) {\n      pixel[0] = 0;\n      pixel[1] = 255;\n      pixel[2] = 0;\n      pixel[3] = 128;\n    } else {\n      pixel[3] = 0;\n    }\n    return pixel;\n  },\n  lib: {\n    vgi: vgi,\n    summarize: summarize\n  }\n});\nraster.set('threshold', 0.1);\n\nfunction createCounts(min, max, num) {\n  const values = new Array(num);\n  for (let i = 0; i < num; ++i) {\n    values[i] = 0;\n  }\n  return {\n    min: min,\n    max: max,\n    values: values,\n    delta: (max - min) / num\n  };\n}\n\nraster.on('beforeoperations', function(event) {\n  event.data.counts = createCounts(minVgi, maxVgi, bins);\n  event.data.threshold = raster.get('threshold');\n});\n\nraster.on('afteroperations', function(event) {\n  schedulePlot(event.resolution, event.data.counts, event.data.threshold);\n});\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: bing\n    }),\n    new ImageLayer({\n      source: raster\n    })\n  ],\n  target: 'map',\n  view: new View({\n    center: [-9651695, 4937351],\n    zoom: 13,\n    minZoom: 12,\n    maxZoom: 19\n  })\n});\n\n\nlet timer = null;\nfunction schedulePlot(resolution, counts, threshold) {\n  if (timer) {\n    clearTimeout(timer);\n    timer = null;\n  }\n  timer = setTimeout(plot.bind(null, resolution, counts, threshold), 1000 / 60);\n}\n\nconst barWidth = 15;\nconst plotHeight = 150;\nconst chart = d3.select('#plot').append('svg')\n  .attr('width', barWidth * bins)\n  .attr('height', plotHeight);\n\nconst chartRect = chart.node().getBoundingClientRect();\n\nconst tip = d3.select(document.body).append('div')\n  .attr('class', 'tip');\n\nfunction plot(resolution, counts, threshold) {\n  const yScale = d3.scaleLinear()\n    .domain([0, d3.max(counts.values)])\n    .range([0, plotHeight]);\n\n  const bar = chart.selectAll('rect').data(counts.values);\n\n  bar.enter().append('rect');\n\n  bar.attr('class', function(count, index) {\n    const value = counts.min + (index * counts.delta);\n    return 'bar' + (value >= threshold ? ' selected' : '');\n  })\n    .attr('width', barWidth - 2);\n\n  bar.transition().attr('transform', function(value, index) {\n    return 'translate(' + (index * barWidth) + ', ' +\n        (plotHeight - yScale(value)) + ')';\n  })\n    .attr('height', yScale);\n\n  bar.on('mousemove', function(count, index) {\n    const threshold = counts.min + (index * counts.delta);\n    if (raster.get('threshold') !== threshold) {\n      raster.set('threshold', threshold);\n      raster.changed();\n    }\n  });\n\n  bar.on('mouseover', function(count, index) {\n    let area = 0;\n    for (let i = counts.values.length - 1; i >= index; --i) {\n      area += resolution * resolution * counts.values[i];\n    }\n    tip.html(message(counts.min + (index * counts.delta), area));\n    tip.style('display', 'block');\n    tip.transition().style({\n      left: (chartRect.left + (index * barWidth) + (barWidth / 2)) + 'px',\n      top: (d3.event.y - 60) + 'px',\n      opacity: 1\n    });\n  });\n\n  bar.on('mouseout', function() {\n    tip.transition().style('opacity', 0).each('end', function() {\n      tip.style('display', 'none');\n    });\n  });\n\n}\n\nfunction message(value, area) {\n  const acres = (area / 4046.86).toFixed(0).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  return acres + ' acres at<br>' + value.toFixed(2) + ' VGI or above';\n}\n"],"sourceRoot":""}