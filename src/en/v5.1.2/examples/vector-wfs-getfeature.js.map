{"version":3,"sources":["webpack:///../src/ol/format/filter/Filter.js","webpack:///../src/ol/format/filter/LogicalNary.js","webpack:///../src/ol/format/filter/And.js","webpack:///../src/ol/format/filter/Bbox.js","webpack:///../src/ol/format/filter/Spatial.js","webpack:///../src/ol/format/filter/Comparison.js","webpack:///../src/ol/format/filter/Contains.js","webpack:///../src/ol/format/filter/ComparisonBinary.js","webpack:///../src/ol/format/filter/During.js","webpack:///../src/ol/format/filter/EqualTo.js","webpack:///../src/ol/format/filter/IsLike.js","webpack:///../src/ol/format/filter/GreaterThan.js","webpack:///../src/ol/format/filter/GreaterThanOrEqualTo.js","webpack:///../src/ol/format/filter/Intersects.js","webpack:///../src/ol/format/filter/IsBetween.js","webpack:///../src/ol/format/filter/IsNull.js","webpack:///../src/ol/format/filter/LessThan.js","webpack:///../src/ol/format/filter/LessThanOrEqualTo.js","webpack:///../src/ol/format/filter/Not.js","webpack:///../src/ol/format/filter/NotEqualTo.js","webpack:///../src/ol/format/filter/Or.js","webpack:///../src/ol/format/filter/Within.js","webpack:///../src/ol/format/filter.js","webpack:///../src/ol/format/GML3.js","webpack:///../src/ol/format/WFS.js","webpack:///./vector-wfs-getfeature.js"],"names":["Filter_Filter","tagName","this","tagName_","prototype","getTagName","filter_Filter","filter_LogicalNary","Filter","LogicalNary","conditions","super","Array","slice","call","arguments","Object","asserts","length","constructor","filter_And","And","const","params","concat","filter_Bbox","Bbox","geometryName","extent","opt_srsName","srsName","filter_Spatial","Spatial","geometry","filter_Comparison","Contains","Comparison","propertyName","filter_ComparisonBinary","During","begin","end","ComparisonBinary","expression","opt_matchCase","matchCase","filter_EqualTo","EqualTo","filter_IsLike","GreaterThan","GreaterThanOrEqualTo","Intersects","IsBetween","lowerBoundary","upperBoundary","IsLike","pattern","opt_wildCard","opt_singleChar","opt_escapeChar","wildCard","undefined","singleChar","escapeChar","IsNull","LessThan","LessThanOrEqualTo","Not","condition","NotEqualTo","Or","Within","and","Function","bind","apply","GML3_schemaLocation","format_GMLBase","MULTIGEOMETRY_TO_MEMBER_NODENAME","MultiLineString","MultiCurve","MultiPolygon","MultiSurface","GML3_GML3","GMLBase","GML3","opt_options","options","surface_","surface","curve_","curve","multiCurve_","multiCurve","multiSurface_","multiSurface","schemaLocation","hasZ","readMultiCurve_","node","objectStack","lineStrings","xml","MULTICURVE_PARSERS_","readMultiSurface_","polygons","MULTISURFACE_PARSERS_","curveMemberParser_","CURVEMEMBER_PARSERS_","surfaceMemberParser_","SURFACEMEMBER_PARSERS_","readPatch_","PATCHES_PARSERS_","readSegment_","SEGMENTS_PARSERS_","readPolygonPatch_","FLAT_LINEAR_RINGS_PARSERS_","readLineStringSegment_","GEOMETRY_FLAT_COORDINATES_PARSERS_","interiorParser_","flatLinearRing","RING_PARSERS","push","exteriorParser_","readSurface_","flatLinearRings","SURFACE_PARSERS_","i","ii","flatCoordinates","ends","array","Polygon","GeometryLayout","XYZ","readCurve_","CURVE_PARSERS_","LineString","readEnvelope_","ENVELOPE_PARSERS_","ol_extent","readFlatPos_","let","m","s","re","exec","parseFloat","substr","containerSrs","axisOrientation","ol_proj","getAxisOrientation","y","x","len","readFlatPosList_","replace","context","contextDimension","z","coords","split","dim","getAttribute","xsd","parentNode","writePos_","value","srsDimension","setAttribute","point","getCoordinates","getCoords_","opt_hasZ","writePosList_","points","parts","join","writePoint_","pos","namespaceURI","appendChild","writeEnvelope","values","ENVELOPE_SERIALIZERS_","writeLinearRing_","posList","RING_NODE_FACTORY_","opt_nodeName","exteriorWritten","writeSurfaceOrPolygon_","nodeName","rings","getLinearRings","RING_SERIALIZERS_","patches","writeSurfacePatches_","writeCurveOrLineString_","segments","writeCurveSegments_","writeMultiSurfaceOrPolygon_","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS_","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","writeMultiPoint_","getPoints","POINTMEMBER_SERIALIZERS_","writeMultiCurveOrLineString_","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS_","writeRing_","ring","linearRing","writeSurfaceOrPolygonMember_","polygon","child","GEOMETRY_NODE_FACTORY_","writePointMember_","writeLineStringOrCurveMember_","line","writeGeometryElement","item","ol_obj","isArray","dataProjection","featureProjection","Feature","GEOMETRY_SERIALIZERS_","writeFeatureElement","feature","fid","getId","featureNS","getGeometryName","serializers","properties","getProperties","keys","key","Geometry","writeFeatureMembers_","features","featureType","getType","writeGeometryNode","adaptOptions","geom","writeFeaturesNode","setAttributeNS","http://www.opengis.net/gml","interior","exterior","GEOMETRY_PARSERS_","Point","readPoint","MultiPoint","readMultiPoint","readLineString","readMultiLineString","LinearRing","readLinearRing","readPolygon","readMultiPolygon","Surface","Curve","Envelope","curveMember","curveMembers","surfaceMember","surfaceMembers","lowerCorner","upperCorner","PolygonPatch","LineStringSegment","writeFeatures","polygonMember","pointMember","lineStringMember","format_GML3","FEATURE_COLLECTION_PARSERS","boundedBy","readGeometryElement","TRANSACTION_SUMMARY_PARSERS","http://www.opengis.net/wfs","totalInserted","totalUpdated","totalDeleted","TRANSACTION_RESPONSE_PARSERS","TransactionSummary","InsertResults","INSERT_RESULTS_PARSERS","QUERY_SERIALIZERS","PropertyName","TRANSACTION_SERIALIZERS","Insert","gmlVersion","GML2","Update","featurePrefix","typeName","getTypeName","XMLNS","getKeys","get","name","writeOgcFidFilter","Delete","Property","pair","WFSNS","Native","nativeElement","vendorId","safeToIgnore","FEATURE_PREFIX","OGCNS","FESNS","SCHEMA_LOCATIONS","1.1.0","1.0.0","DEFAULT_VERSION","WFS_WFS","XMLFeature","WFS","featureType_","featureNS_","gmlFormat_","gmlFormat","schemaLocation_","getFeatureType","setFeatureType","readFeaturesFromNode","getReadOptions","readFeaturesInternal","readTransactionResponse","source","readTransactionResponseFromDocument","readTransactionResponseFromNode","doc","readFeatureCollectionMetadata","readFeatureCollectionMetadataFromDocument","readFeatureCollectionMetadataFromNode","n","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","result","writeGetFeature","filter","handle","outputFormat","maxFeatures","resultType","startIndex","count","bbox","filter_bbox","propertyNames","featureTypes","GETFEATURE_SERIALIZERS","writeTransaction","inserts","updates","deletes","baseObj","obj","version","gmlOptions","nativeElements","readProjectionFromDocument","readProjectionFromNode","firstElementChild","nextElementSibling","childNodes","pop","format_XMLFeature","OGC_FID_PARSERS","http://www.opengis.net/ogc","FeatureId","prefix","indexOf","Query","writeFilterCondition","valueReference","timePeriod","writeTimeInstant","writeLogicalFilter","BBOX","writeOgcPropertyName","PropertyIsEqualTo","writeComparisonFilter","PropertyIsNotEqualTo","PropertyIsLessThan","PropertyIsLessThanOrEqualTo","PropertyIsGreaterThan","PropertyIsGreaterThanOrEqualTo","PropertyIsNull","PropertyIsBetween","writeOgcLiteral","PropertyIsLike","toString","writeOgcExpression","property","time","timeInstant","timePosition","format_WFS","vectorSource","source_Vector","vector","Vector","style","Style","stroke","Stroke","color","width","raster","Tile","BingMaps","imagerySet","map","Map","layers","target","document","getElementById","view","View","center","maxZoom","zoom","featureRequest","like","equalTo","fetch","method","body","XMLSerializer","serializeToString","then","response","json","GeoJSON","readFeatures","addFeatures","getView","fit","getExtent"],"mappings":"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","file":"vector-wfs-getfeature.js","sourcesContent":["/**\n * @module ol/format/filter/Filter\n */\n\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature filters.\n *\n * @abstract\n */\nclass Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   */\n  constructor(tagName) {\n\n    /**\n     * @private\n     * @type {!string}\n     */\n    this.tagName_ = tagName;\n  }\n\n  /**\n   * The XML tag name for a filter.\n   * @returns {!string} Name.\n   */\n  getTagName() {\n    return this.tagName_;\n  }\n}\n\nexport default Filter;\n","/**\n * @module ol/format/filter/LogicalNary\n */\nimport {assert} from '../../asserts.js';\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature n-ary logical filters.\n *\n * @abstract\n */\nclass LogicalNary extends Filter {\n\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {...module:ol/format/filter/Filter} conditions Conditions.\n   */\n  constructor(tagName, conditions) {\n\n    super(tagName);\n\n    /**\n     * @type {Array.<module:ol/format/filter/Filter>}\n     */\n    this.conditions = Array.prototype.slice.call(arguments, 1);\n    assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\n  }\n\n}\n\nexport default LogicalNary;\n","/**\n * @module ol/format/filter/And\n */\nimport LogicalNary from '../filter/LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<And>` operator between two or more filter conditions.\n *\n * @abstract\n */\nclass And extends LogicalNary {\n\n  /**\n   * @param {...module:ol/format/filter/Filter} conditions Conditions.\n   */\n  constructor(conditions) {\n    const params = ['And'].concat(Array.prototype.slice.call(arguments));\n    super(...params);\n  }\n\n}\n\nexport default And;\n","/**\n * @module ol/format/filter/Bbox\n */\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Represents a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @api\n */\nclass Bbox extends Filter {\n\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!module:ol/extent~Extent} extent Extent.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be set\n   * on geometries when this is not provided.\n   */\n  constructor(geometryName, extent, opt_srsName) {\n\n    super('BBOX');\n\n    /**\n     * @type {!string}\n     */\n    this.geometryName = geometryName;\n\n    /**\n     * @type {module:ol/extent~Extent}\n     */\n    this.extent = extent;\n\n    /**\n     * @type {string|undefined}\n     */\n    this.srsName = opt_srsName;\n  }\n\n}\n\nexport default Bbox;\n","/**\n * @module ol/format/filter/Spatial\n */\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Represents a spatial operator to test whether a geometry-valued property\n * relates to a given geometry.\n *\n * @abstract\n */\nclass Spatial extends Filter {\n\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!module:ol/geom/Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   */\n  constructor(tagName, geometryName, geometry, opt_srsName) {\n\n    super(tagName);\n\n    /**\n     * @type {!string}\n     */\n    this.geometryName = geometryName || 'the_geom';\n\n    /**\n     * @type {module:ol/geom/Geometry}\n     */\n    this.geometry = geometry;\n\n    /**\n     * @type {string|undefined}\n     */\n    this.srsName = opt_srsName;\n  }\n\n}\n\nexport default Spatial;\n","/**\n * @module ol/format/filter/Comparison\n */\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property comparison filters.\n *\n * @abstract\n */\nclass Comparison extends Filter {\n\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   */\n  constructor(tagName, propertyName) {\n\n    super(tagName);\n\n    /**\n     * @type {!string}\n     */\n    this.propertyName = propertyName;\n  }\n\n}\n\nexport default Comparison;\n","/**\n * @module ol/format/filter/Contains\n */\nimport Spatial from '../filter/Spatial.js';\n\n/**\n * @classdesc\n * Represents a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n */\nclass Contains extends Spatial {\n\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!module:ol/geom/Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @api\n   */\n  constructor(geometryName, geometry, opt_srsName) {\n\n    super('Contains', geometryName, geometry, opt_srsName);\n\n  }\n\n}\n\nexport default Contains;\n","/**\n * @module ol/format/filter/ComparisonBinary\n */\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property binary comparison filters.\n *\n * @abstract\n */\nclass ComparisonBinary extends Comparison {\n\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   */\n  constructor(tagName, propertyName, expression, opt_matchCase) {\n\n    super(tagName, propertyName);\n\n    /**\n     * @type {!(string|number)}\n     */\n    this.expression = expression;\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n  }\n\n}\n\nexport default ComparisonBinary;\n","/**\n * @module ol/format/filter/During\n */\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<During>` comparison operator.\n */\nclass During extends Comparison {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} begin The begin date in ISO-8601 format.\n   * @param {!string} end The end date in ISO-8601 format.\n   * @api\n   */\n  constructor(propertyName, begin, end) {\n    super('During', propertyName);\n\n    /**\n     * @type {!string}\n     */\n    this.begin = begin;\n\n    /**\n     * @type {!string}\n     */\n    this.end = end;\n  }\n\n}\n\nexport default During;\n","/**\n * @module ol/format/filter/EqualTo\n */\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsEqualTo>` comparison operator.\n */\nclass EqualTo extends ComparisonBinary {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @api\n   */\n  constructor(propertyName, expression, opt_matchCase) {\n    super('PropertyIsEqualTo', propertyName, expression, opt_matchCase);\n  }\n\n}\n\nexport default EqualTo;\n","/**\n * @module ol/format/filter/IsLike\n */\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLike>` comparison operator.\n */\nclass IsLike extends Comparison {\n\n  /**\n   * [constructor description]\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} pattern Text pattern.\n   * @param {string=} opt_wildCard Pattern character which matches any sequence of\n   *    zero or more string characters. Default is '*'.\n   * @param {string=} opt_singleChar pattern character which matches any single\n   *    string character. Default is '.'.\n   * @param {string=} opt_escapeChar Escape character which can be used to escape\n   *    the pattern characters. Default is '!'.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @api\n   */\n  constructor(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n    super('PropertyIsLike', propertyName);\n\n    /**\n     * @type {!string}\n     */\n    this.pattern = pattern;\n\n    /**\n     * @type {!string}\n     */\n    this.wildCard = (opt_wildCard !== undefined) ? opt_wildCard : '*';\n\n    /**\n     * @type {!string}\n     */\n    this.singleChar = (opt_singleChar !== undefined) ? opt_singleChar : '.';\n\n    /**\n     * @type {!string}\n     */\n    this.escapeChar = (opt_escapeChar !== undefined) ? opt_escapeChar : '!';\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n\n  }\n}\n\nexport default IsLike;\n","/**\n * @module ol/format/filter/GreaterThan\n */\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsGreaterThan>` comparison operator.\n */\nclass GreaterThan extends ComparisonBinary {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @api\n   */\n  constructor(propertyName, expression) {\n    super('PropertyIsGreaterThan', propertyName, expression);\n  }\n\n}\n\nexport default GreaterThan;\n","/**\n * @module ol/format/filter/GreaterThanOrEqualTo\n */\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n */\nclass GreaterThanOrEqualTo extends ComparisonBinary {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @api\n   */\n  constructor(propertyName, expression) {\n    super('PropertyIsGreaterThanOrEqualTo', propertyName, expression);\n  }\n\n}\n\nexport default GreaterThanOrEqualTo;\n","/**\n * @module ol/format/filter/Intersects\n */\nimport Spatial from '../filter/Spatial.js';\n\n/**\n * @classdesc\n * Represents a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n */\nclass Intersects extends Spatial {\n\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!module:ol/geom/Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   */\n  constructor(geometryName, geometry, opt_srsName) {\n    super('Intersects', geometryName, geometry, opt_srsName);\n  }\n\n}\n\nexport default Intersects;\n","/**\n * @module ol/format/filter/IsBetween\n */\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsBetween>` comparison operator.\n */\nclass IsBetween extends Comparison {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} lowerBoundary The lower bound of the range.\n   * @param {!number} upperBoundary The upper bound of the range.\n   * @api\n   */\n  constructor(propertyName, lowerBoundary, upperBoundary) {\n    super('PropertyIsBetween', propertyName);\n\n    /**\n     * @type {!number}\n     */\n    this.lowerBoundary = lowerBoundary;\n\n    /**\n     * @type {!number}\n     */\n    this.upperBoundary = upperBoundary;\n\n  }\n}\n\nexport default IsBetween;\n","/**\n * @module ol/format/filter/IsNull\n */\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsNull>` comparison operator.\n */\nclass IsNull extends Comparison {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @api\n   */\n  constructor(propertyName) {\n    super('PropertyIsNull', propertyName);\n  }\n\n}\n\nexport default IsNull;\n","/**\n * @module ol/format/filter/LessThan\n */\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLessThan>` comparison operator.\n */\nclass LessThan extends ComparisonBinary {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @api\n   */\n  constructor(propertyName, expression) {\n    super('PropertyIsLessThan', propertyName, expression);\n  }\n\n}\n\nexport default LessThan;\n","/**\n * @module ol/format/filter/LessThanOrEqualTo\n */\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n */\nclass LessThanOrEqualTo extends ComparisonBinary {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!number} expression The value to compare.\n   * @api\n   */\n  constructor(propertyName, expression) {\n    super('PropertyIsLessThanOrEqualTo', propertyName, expression);\n  }\n\n}\n\nexport default LessThanOrEqualTo;\n","/**\n * @module ol/format/filter/Not\n */\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Represents a logical `<Not>` operator for a filter condition.\n */\nclass Not extends Filter {\n\n  /**\n   * @param {!module:ol/format/filter/Filter} condition Filter condition.\n   * @api\n   */\n  constructor(condition) {\n\n    super('Not');\n\n    /**\n     * @type {!module:ol/format/filter/Filter}\n     */\n    this.condition = condition;\n\n  }\n\n}\n\nexport default Not;\n","/**\n * @module ol/format/filter/NotEqualTo\n */\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsNotEqualTo>` comparison operator.\n */\nclass NotEqualTo extends ComparisonBinary {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   * @api\n   */\n  constructor(propertyName, expression, opt_matchCase) {\n    super('PropertyIsNotEqualTo', propertyName, expression, opt_matchCase);\n  }\n\n}\n\nexport default NotEqualTo;\n","/**\n * @module ol/format/filter/Or\n */\nimport LogicalNary from '../filter/LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<Or>` operator between two ore more filter conditions.\n */\nclass Or extends LogicalNary {\n\n  /**\n   * @param {...module:ol/format/filter/Filter} conditions Conditions.\n   * @api\n   */\n  constructor(conditions) {\n    const params = ['Or'].concat(Array.prototype.slice.call(arguments));\n    super(...params);\n  }\n\n}\n\nexport default Or;\n","/**\n * @module ol/format/filter/Within\n */\nimport Spatial from '../filter/Spatial.js';\n\n/**\n * @classdesc\n * Represents a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n */\nclass Within extends Spatial {\n\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!module:ol/geom/Geometry} geometry Geometry.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @api\n   */\n  constructor(geometryName, geometry, opt_srsName) {\n    super('Within', geometryName, geometry, opt_srsName);\n  }\n\n}\n\nexport default Within;\n","/**\n * @module ol/format/filter\n */\nimport And from '../format/filter/And.js';\nimport Bbox from '../format/filter/Bbox.js';\nimport Contains from '../format/filter/Contains.js';\nimport During from '../format/filter/During.js';\nimport EqualTo from '../format/filter/EqualTo.js';\nimport GreaterThan from '../format/filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from '../format/filter/GreaterThanOrEqualTo.js';\nimport Intersects from '../format/filter/Intersects.js';\nimport IsBetween from '../format/filter/IsBetween.js';\nimport IsLike from '../format/filter/IsLike.js';\nimport IsNull from '../format/filter/IsNull.js';\nimport LessThan from '../format/filter/LessThan.js';\nimport LessThanOrEqualTo from '../format/filter/LessThanOrEqualTo.js';\nimport Not from '../format/filter/Not.js';\nimport NotEqualTo from '../format/filter/NotEqualTo.js';\nimport Or from '../format/filter/Or.js';\nimport Within from '../format/filter/Within.js';\n\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...module:ol/format/filter/Filter} conditions Filter conditions.\n * @returns {!module:ol/format/filter/And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params));\n}\n\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...module:ol/format/filter/Filter} conditions Filter conditions.\n * @returns {!module:ol/format/filter/Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params));\n}\n\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!module:ol/format/filter/Filter} condition Filter condition.\n * @returns {!module:ol/format/filter/Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/extent~Extent} extent Extent.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!module:ol/format/filter/Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, opt_srsName) {\n  return new Bbox(geometryName, extent, opt_srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!module:ol/format/filter/Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, opt_srsName) {\n  return new Contains(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!module:ol/format/filter/Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, opt_srsName) {\n  return new Intersects(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!module:ol/format/filter/Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, opt_srsName) {\n  return new Within(geometryName, geometry, opt_srsName);\n}\n\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!module:ol/format/filter/EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, opt_matchCase) {\n  return new EqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!module:ol/format/filter/NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!module:ol/format/filter/LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!module:ol/format/filter/LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!module:ol/format/filter/GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!module:ol/format/filter/GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @returns {!module:ol/format/filter/IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @returns {!module:ol/format/filter/IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string=} opt_singleChar pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string=} opt_escapeChar Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!module:ol/format/filter/IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(propertyName, pattern,\n  opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n  return new IsLike(propertyName, pattern,\n    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);\n}\n\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @returns {!module:ol/format/filter/During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n","/**\n * @module ol/format/GML3\n */\nimport {extend} from '../array.js';\nimport {createOrUpdate} from '../extent.js';\nimport {transformWithOptions} from '../format/Feature.js';\nimport GMLBase, {GMLNS} from '../format/GMLBase.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from '../format/xsd.js';\nimport Geometry from '../geom/Geometry.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection, transformExtent} from '../proj.js';\nimport {createElementNS, getAllTextContent, makeArrayPusher, makeChildAppender,\n  makeReplacer, makeSimpleNodeFactory, OBJECT_PROPERTY_NODE_FACTORY, parseNode,\n  pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI} from '../xml.js';\n\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation = GMLNS +\n    ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n    '1.0.0/gmlsf.xsd';\n\n\n/**\n * @const\n * @type {Object.<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember'\n};\n\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n\n  /**\n   * @param {module:ol/format/GMLBase~Options=} opt_options Optional configuration object.\n   */\n  constructor(opt_options) {\n    const options = /** @type {module:ol/format/GMLBase~Options} */\n        (opt_options ? opt_options : {});\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ = options.multiCurve !== undefined ?\n      options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ = options.multiSurface !== undefined ?\n      options.multiSurface : true;\n\n    /**\n     * @inheritDoc\n     */\n    this.schemaLocation = options.schemaLocation ?\n      options.schemaLocation : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ?\n      options.hasZ : false;\n\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {module:ol/geom/MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve_(node, objectStack) {\n    /** @type {Array.<module:ol/geom/LineString>} */\n    const lineStrings = pushParseAndPop([],\n      this.MULTICURVE_PARSERS_, node, objectStack, this);\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {module:ol/geom/MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface_(node, objectStack) {\n    /** @type {Array.<module:ol/geom/Polygon>} */\n    const polygons = pushParseAndPop([],\n      this.MULTISURFACE_PARSERS_, node, objectStack, this);\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  curveMemberParser_(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS_, node, objectStack, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  surfaceMemberParser_(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS_,\n      node, objectStack, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<(Array.<number>)>|undefined} flat coordinates.\n   */\n  readPatch_(node, objectStack) {\n    return pushParseAndPop([null],\n      this.PATCHES_PARSERS_, node, objectStack, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} flat coordinates.\n   */\n  readSegment_(node, objectStack) {\n    return pushParseAndPop([null],\n      this.SEGMENTS_PARSERS_, node, objectStack, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<(Array.<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch_(node, objectStack) {\n    return pushParseAndPop([null],\n      this.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment_(node, objectStack) {\n    return pushParseAndPop([null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS_,\n      node, objectStack, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  interiorParser_(node, objectStack) {\n    /** @type {Array.<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(undefined,\n      this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      const flatLinearRings = /** @type {Array.<Array.<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   */\n  exteriorParser_(node, objectStack) {\n    /** @type {Array.<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(undefined,\n      this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      const flatLinearRings = /** @type {Array.<Array.<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {module:ol/geom/Polygon|undefined} Polygon.\n   */\n  readSurface_(node, objectStack) {\n    /** @type {Array.<Array.<number>>} */\n    const flatLinearRings = pushParseAndPop([null],\n      this.SURFACE_PARSERS_, node, objectStack, this);\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {module:ol/geom/LineString|undefined} LineString.\n   */\n  readCurve_(node, objectStack) {\n    /** @type {Array.<number>} */\n    const flatCoordinates = pushParseAndPop([null],\n      this.CURVE_PARSERS_, node, objectStack, this);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {module:ol/extent~Extent|undefined} Envelope.\n   */\n  readEnvelope_(node, objectStack) {\n    /** @type {Array.<number>} */\n    const flatCoordinates = pushParseAndPop([null],\n      this.ENVELOPE_PARSERS_, node, objectStack, this);\n    return createOrUpdate(flatCoordinates[1][0],\n      flatCoordinates[1][1], flatCoordinates[2][0],\n      flatCoordinates[2][1]);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} Flat coordinates.\n   */\n  readFlatPos_(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array.<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<*>} objectStack Object stack.\n   * @private\n   * @return {Array.<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList_(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(\n        node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(\n        node.getAttribute('dimension'));\n    } else if (node.parentNode.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(\n        node.parentNode.getAttribute('srsDimension'));\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = (dim === 3) ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/Point} value Point geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? 3 : 2;\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = (point[0] + ' ' + point[1]);\n    } else {\n      coords = (point[1] + ' ' + point[0]);\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array.<number>} point Point geometry.\n   * @param {string=} opt_srsName Optional srsName\n   * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, opt_srsName, opt_hasZ) {\n    let axisOrientation = 'enu';\n    if (opt_srsName) {\n      axisOrientation = getProjection(opt_srsName).getAxisOrientation();\n    }\n    let coords = ((axisOrientation.substr(0, 2) === 'en') ?\n      point[0] + ' ' + point[1] :\n      point[1] + ' ' + point[0]);\n    if (opt_hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/LineString|module:ol/geom/LinearRing} value Geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? 3 : 2;\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/Point} geometry Point geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writePoint_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @param {Array.<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */\n      ({node: node}), this.ENVELOPE_SERIALIZERS_,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack, keys, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/LinearRing} geometry LinearRing geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeLinearRing_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior');\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/Polygon} geometry Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfaceOrPolygon_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS_,\n        this.RING_NODE_FACTORY_,\n        rings, objectStack, undefined, this);\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(\n        patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/LineString} geometry LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveOrLineString_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'LineString' ||\n        node.nodeName === 'LineStringSegment') {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments,\n        geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeMultiSurfaceOrPolygon_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS_,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons,\n      objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/MultiPoint} geometry MultiPoint geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeMultiPoint_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS_,\n      makeSimpleNodeFactory('pointMember'), points,\n      objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/MultiLineString} geometry MultiLineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeMultiCurveOrLineString_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS_,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines,\n      objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/LinearRing} ring LinearRing geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeRing_(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing_(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/Polygon} polygon Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfaceOrPolygonMember_(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(\n      polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/Point} point Point geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writePointMember_(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint_(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/LineString} line LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeLineStringOrCurveMember_(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString_(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/Polygon} polygon Polygon geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/LineString} line LineString geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI,\n      'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString_(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/geom/Geometry|module:ol/extent~Extent} geometry Geometry.\n   * @param {Array.<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {module:ol/format/Feature~WriteOptions} */ (objectStack[objectStack.length - 1]);\n    const item = assign({}, context);\n    item.node = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      if (context.dataProjection) {\n        value = transformExtent(\n          geometry, context.featureProjection, context.dataProjection);\n      } else {\n        value = geometry;\n      }\n    } else {\n      value = transformWithOptions(/** @type {module:ol/geom/Geometry} */ (geometry), true, context);\n    }\n    pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */\n      (item), this.GEOMETRY_SERIALIZERS_,\n      this.GEOMETRY_NODE_FACTORY_, [value],\n      objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {module:ol/Feature} feature Feature.\n   * @param {Array.<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', fid);\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const properties = feature.getProperties();\n    const keys = [];\n    const values = [];\n    for (const key in properties) {\n      const value = properties[key];\n      if (value !== null) {\n        keys.push(key);\n        values.push(value);\n        if (key == geometryName || value instanceof Geometry) {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = makeChildAppender(\n              this.writeGeometryElement, this);\n          }\n        } else {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n          }\n        }\n      }\n    }\n    const item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */\n      (item), context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack, keys);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array.<module:ol/Feature>} features Features.\n   * @param {Array.<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement, this);\n    const item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS), features,\n      objectStack);\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS('http://www.opengis.net/gml',\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array.<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    let nodeName;\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {module:ol/geom/Geometry} */ (value).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS('http://www.opengis.net/gml',\n      nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {module:ol/geom/Geometry} geometry Geometry.\n   * @param {module:ol/format/Feature~WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n  writeGeometryNode(geometry, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    const geom = createElementNS('http://www.opengis.net/gml', 'geom');\n    const context = {node: geom, hasZ: this.hasZ, srsName: this.srsName,\n      curve: this.curve_, surface: this.surface_,\n      multiSurface: this.multiSurface_, multiCurve: this.multiCurve_};\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array.<module:ol/Feature>} features Features.\n   * @param {module:ol/format/Feature~WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n  writeFeaturesNode(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    const node = createElementNS('http://www.opengis.net/gml', 'featureMembers');\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation);\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType\n    };\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos_),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser_,\n    'exterior': GML3.prototype.exteriorParser_\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.GEOMETRY_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(\n      GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(\n      GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(\n      GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(\n      GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(\n      GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface_),\n    'MultiSurface': makeReplacer(\n      GML3.prototype.readMultiSurface_),\n    'Curve': makeReplacer(GML3.prototype.readCurve_),\n    'MultiCurve': makeReplacer(\n      GML3.prototype.readMultiCurve_),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.MULTICURVE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(\n      GML3.prototype.curveMemberParser_),\n    'curveMembers': makeArrayPusher(\n      GML3.prototype.curveMemberParser_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.MULTISURFACE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(\n      GML3.prototype.surfaceMemberParser_),\n    'surfaceMembers': makeArrayPusher(\n      GML3.prototype.surfaceMemberParser_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.CURVEMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(\n      GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.SURFACEMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.SURFACE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.CURVE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.ENVELOPE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(\n      GML3.prototype.readFlatPosList_),\n    'upperCorner': makeArrayPusher(\n      GML3.prototype.readFlatPosList_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.PATCHES_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(\n      GML3.prototype.readPolygonPatch_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.SEGMENTS_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeReplacer(\n      GML3.prototype.readLineStringSegment_)\n  }\n};\n\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array.<module:ol/Feature>} features Features.\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.RING_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing_),\n    'interior': makeChildAppender(GML3.prototype.writeRing_)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.ENVELOPE_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember_),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember_)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(\n      GML3.prototype.writePointMember_)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember_),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember_)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.GEOMETRY_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(\n      GML3.prototype.writeCurveOrLineString_),\n    'MultiCurve': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString_),\n    'Point': makeChildAppender(GML3.prototype.writePoint_),\n    'MultiPoint': makeChildAppender(\n      GML3.prototype.writeMultiPoint_),\n    'LineString': makeChildAppender(\n      GML3.prototype.writeCurveOrLineString_),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString_),\n    'LinearRing': makeChildAppender(\n      GML3.prototype.writeLinearRing_),\n    'Polygon': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygon_),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon_),\n    'Surface': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygon_),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon_),\n    'Envelope': makeChildAppender(\n      GML3.prototype.writeEnvelope)\n  }\n};\n\nexport default GML3;\n","/**\n * @module ol/format/WFS\n */\nimport {assert} from '../asserts.js';\nimport GML2 from '../format/GML2.js';\nimport GML3 from '../format/GML3.js';\nimport GMLBase, {GMLNS} from '../format/GMLBase.js';\nimport {and as andFilter, bbox as bboxFilter} from '../format/filter.js';\nimport XMLFeature from '../format/XMLFeature.js';\nimport {readNonNegativeIntegerString, readNonNegativeInteger, writeStringTextNode} from '../format/xsd.js';\nimport Geometry from '../geom/Geometry.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport {createElementNS, isDocument, isNode, makeArrayPusher, makeChildAppender,\n  makeObjectPropertySetter, makeSimpleNodeFactory, parse, parseNode,\n  pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI} from '../xml.js';\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readGeometryElement, 'bounds')\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(\n      readInsertResults, 'insertIds')\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  }\n};\n\n\n/**\n * @typedef {Object} Options\n * @property {Object.<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array.<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {module:ol/format/GMLBase} [gmlFormat] The GML format to use to parse the response. Default is `ol/format/GML3`.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n */\n\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array.<string>} featureTypes The feature type names.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array.<string>} [propertyNames] Optional list of property names to serialize.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {module:ol/extent~Extent} [bbox] Extent to use for the BBOX filter.\n * @property {module:ol/format/filter/Filter} [filter] Filter condition. See\n * {@link module:ol/format/Filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array.<Object>} nativeElements Native elements. Currently not supported.\n * @property {module:ol/format/GMLBase~Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0` or `1.1.0`.\n */\n\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures\n * @property {module:ol/extent~Extent} bounds\n */\n\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted\n * @property {number} totalInserted\n * @property {number} totalUpdated\n * @property {Array.<string>} insertIds\n */\n\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n\n/**\n * @type {string}\n */\nconst OGCNS = 'http://www.opengis.net/ogc';\n\n\n/**\n * @type {string}\n */\nconst WFSNS = 'http://www.opengis.net/wfs';\n\n\n/**\n * @type {string}\n */\nconst FESNS = 'http://www.opengis.net/fes';\n\n\n/**\n * @type {Object.<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n};\n\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n\n  /**\n   * @param {module:ol/format/WFS~Options=} opt_options Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @private\n     * @type {Array.<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object.<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {module:ol/format/GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat ?\n      options.gmlFormat : new GML3();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation ?\n      options.schemaLocation : SCHEMA_LOCATIONS[DEFAULT_VERSION];\n  }\n\n  /**\n   * @return {Array.<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array.<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readFeaturesFromNode(node, opt_options) {\n    const context = /** @type {module:ol/xml~NodeStackItem} */ ({\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_\n    });\n    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n    const objectStack = [context];\n    this.gmlFormat_.FEATURE_COLLECTION_PARSERS[GMLNS][\n      'featureMember'] =\n        makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n    let features = pushParseAndPop([],\n      this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node,\n      objectStack, this.gmlFormat_);\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Node|Object|string} source Source.\n   * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n        /** @type {Document} */ (source));\n    } else if (isNode(source)) {\n      return this.readTransactionResponseFromNode(/** @type {Node} */ (source));\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Node|Object|string} source Source.\n   * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n        /** @type {Document} */ (source));\n    } else if (isNode(source)) {\n      return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Node} */ (source));\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(n);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(\n      node.getAttribute('numberOfFeatures'));\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n      /** @type {module:ol/format/WFS~FeatureCollectionMetadata} */ (result),\n      FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(n);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n      /** @type {module:ol/format/WFS~TransactionResponse} */({}),\n      TRANSACTION_RESPONSE_PARSERS, node, []);\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {module:ol/format/WFS~WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS, 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', '1.1.0');\n    let filter;\n    if (options) {\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n      if (options.outputFormat) {\n        node.setAttribute('outputFormat', options.outputFormat);\n      }\n      if (options.maxFeatures !== undefined) {\n        node.setAttribute('maxFeatures', options.maxFeatures);\n      }\n      if (options.resultType) {\n        node.setAttribute('resultType', options.resultType);\n      }\n      if (options.startIndex !== undefined) {\n        node.setAttribute('startIndex', options.startIndex);\n      }\n      if (options.count !== undefined) {\n        node.setAttribute('count', options.count);\n      }\n      filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName,\n          12); // `options.geometryName` must also be provided when `options.bbox` is set\n        const bbox = bboxFilter(\n          /** @type {string} */ (options.geometryName), options.bbox, options.srsName);\n        if (filter) {\n          // if bbox and filter are both set, combine the two into a single filter\n          filter = andFilter(filter, bbox);\n        } else {\n          filter = bbox;\n        }\n      }\n    }\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);\n    /** @type {module:ol/xml~NodeStackItem} */\n    const context = {\n      node: node,\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'geometryName': options.geometryName,\n      'filter': filter,\n      'propertyNames': options.propertyNames ? options.propertyNames : []\n    };\n    assert(Array.isArray(options.featureTypes),\n      11); // `options.featureTypes` should be an Array\n    writeGetFeature(node, /** @type {!Array.<string>} */ (options.featureTypes), [context]);\n    return node;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array.<module:ol/Feature>} inserts The features to insert.\n   * @param {Array.<module:ol/Feature>} updates The features to update.\n   * @param {Array.<module:ol/Feature>} deletes The features to delete.\n   * @param {module:ol/format/WFS~WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const node = createElementNS(WFSNS, 'Transaction');\n    const version = options.version ? options.version : DEFAULT_VERSION;\n    const gmlVersion = version === '1.0.0' ? 2 : 3;\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {module:ol/xml~NodeStackItem} */\n    let obj;\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    const schemaLocation = SCHEMA_LOCATIONS[version];\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', schemaLocation);\n    const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n    if (inserts) {\n      obj = {node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName};\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj,\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Insert'), inserts,\n        objectStack);\n    }\n    if (updates) {\n      obj = {node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName};\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj,\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Update'), updates,\n        objectStack);\n    }\n    if (deletes) {\n      pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'srsName': options.srsName},\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Delete'), deletes,\n      objectStack);\n    }\n    if (options.nativeElements) {\n      pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'srsName': options.srsName},\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Native'), options.nativeElements,\n      objectStack);\n    }\n    return node;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(n);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild &&\n        node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (!(n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 &&\n            n.firstChild.nodeType === 3))) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop(\n    {}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function(node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {Array.<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop(\n    [], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const filter = createElementNS(OGCNS, 'Filter');\n  const child = createElementNS(OGCNS, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', fid);\n  node.appendChild(filter);\n}\n\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @returns {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (value instanceof Geometry) {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */ (\n      {'gmlVersion': context['gmlVersion'], node: node,\n        'hasZ': context['hasZ'], 'srsName': context['srsName']}),\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory('Property'), values,\n    objectStack);\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const name = createElementNS(WFSNS, 'Name');\n  const context = objectStack[objectStack.length - 1];\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(WFSNS, 'Value');\n    node.appendChild(value);\n    if (pair.value instanceof Geometry) {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value,\n          pair.value, objectStack);\n      } else {\n        GML3.prototype.writeGeometryElement(value,\n          pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}}\n *     nativeElement The native element.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', nativeElement.safeToIgnore);\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeContainsFilter),\n    'Intersects': makeChildAppender(writeIntersectsFilter),\n    'Within': makeChildAppender(writeWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {string} featureType Feature type.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  node.setAttribute('typeName', typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {module:ol/xml~NodeStackItem} */ (assign({}, context));\n  item.node = node;\n  pushSerializeAndPop(item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'), propertyNames,\n    objectStack);\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(OGCNS, 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Filter} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {node: node};\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter], objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Bbox} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Contains} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeContainsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Intersects} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeIntersectsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Within} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeWithinFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/During} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n\n  const valueReference = createElementNS(FESNS, 'ValueReference');\n  writeStringTextNode(valueReference, filter.propertyName);\n  node.appendChild(valueReference);\n\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/LogicalNary} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {node: node};\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition], objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Not} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {node: node};\n  const condition = filter.condition;\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition], objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/ComparisonBinary} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.expression);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsNull} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsBetween} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(OGCNS, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeOgcLiteral(lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(OGCNS, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeOgcLiteral(upperBoundary, '' + filter.upperBoundary);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsLike} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.pattern);\n}\n\n\n/**\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeOgcExpression(tagName, node, value) {\n  const property = createElementNS(OGCNS, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcPropertyName(node, value) {\n  writeOgcExpression('PropertyName', node, value);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcLiteral(node, value) {\n  writeOgcExpression('Literal', node, value);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {module:ol/format/filter/Filter} filter Filter.\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter) {\n  const child = createElementNS(OGCNS, 'Filter');\n  writeFilterCondition(child, filter, []);\n  return child;\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<string>} featureTypes Feature types.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {module:ol/xml~NodeStackItem} */ (assign({}, context));\n  item.node = node;\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'), featureTypes,\n    objectStack);\n}\n\n\nexport default WFS;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {\n  equalTo as equalToFilter,\n  like as likeFilter,\n  and as andFilter\n} from '../src/ol/format/filter.js';\nimport {WFS, GeoJSON} from '../src/ol/format.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\nimport BingMaps from '../src/ol/source/BingMaps.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport {Stroke, Style} from '../src/ol/style.js';\n\n\nconst vectorSource = new VectorSource();\nconst vector = new VectorLayer({\n  source: vectorSource,\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(0, 0, 255, 1.0)',\n      width: 2\n    })\n  })\n});\n\nconst raster = new TileLayer({\n  source: new BingMaps({\n    imagerySet: 'Aerial',\n    key: 'As1HiMj1PvLPlqc_gtM7AqZfBL8ZL3VrjaS3zIb22Uvb9WKhuJObROC-qUpa81U5'\n  })\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [-8908887.277395891, 5381918.072437216],\n    maxZoom: 19,\n    zoom: 12\n  })\n});\n\n// generate a GetFeature request\nconst featureRequest = new WFS().writeGetFeature({\n  srsName: 'EPSG:3857',\n  featureNS: 'http://openstreemap.org',\n  featurePrefix: 'osm',\n  featureTypes: ['water_areas'],\n  outputFormat: 'application/json',\n  filter: andFilter(\n    likeFilter('name', 'Mississippi*'),\n    equalToFilter('waterway', 'riverbank')\n  )\n});\n\n// then post the request and add the received features to a layer\nfetch('https://ahocevar.com/geoserver/wfs', {\n  method: 'POST',\n  body: new XMLSerializer().serializeToString(featureRequest)\n}).then(function(response) {\n  return response.json();\n}).then(function(json) {\n  const features = new GeoJSON().readFeatures(json);\n  vectorSource.addFeatures(features);\n  map.getView().fit(vectorSource.getExtent());\n});\n"],"sourceRoot":""}