{"version":3,"sources":["webpack:///./geolocation-orientation.js"],"names":["view","_src_ol_View_js__WEBPACK_IMPORTED_MODULE_3__","center","Object","_src_ol_proj_js__WEBPACK_IMPORTED_MODULE_7__","zoom","map","_src_ol_Map_js__WEBPACK_IMPORTED_MODULE_1__","layers","_src_ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_6__","source","_src_ol_source_OSM_js__WEBPACK_IMPORTED_MODULE_8__","target","controls","_src_ol_control_js__WEBPACK_IMPORTED_MODULE_4__","attributionOptions","collapsible","markerEl","document","getElementById","marker","_src_ol_Overlay_js__WEBPACK_IMPORTED_MODULE_2__","positioning","element","stopEvent","addOverlay","const","positions","_src_ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_5__","geolocation","_src_ol_Geolocation_js__WEBPACK_IMPORTED_MODULE_0__","projection","getProjection","trackingOptions","maximumAge","enableHighAccuracy","timeout","deltaMean","on","position","getPosition","accuracy","getAccuracy","heading","getHeading","speed","getSpeed","m","x","y","fCoords","getCoordinates","previous","length","prevHeading","let","headingDiff","n","Math","PI","mod","abs","sign","appendCoordinate","setCoordinates","slice","src","addPosition","Date","now","coords","len","html","toFixed","round","rad","radToDeg","join","innerHTML","alert","previousM","updateView","max","c","getCoordinateAtM","setCenter","rotation","resolution","height","getSize","sin","cos","getCenterWithHeading","getResolution","setRotation","setPosition","simulationData","geolocateBtn","addEventListener","setTracking","render","disableButtons","client","XMLHttpRequest","open","onload","JSON","parse","responseText","data","send","simulateBtn","simulatePositionChange","set","deg","degToRad","projectedPosition","longitude","latitude","changed","disabled","coordinates","first","shift","prevDate","timestamp","geolocate","newDate","window","setTimeout"],"mappings":"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","file":"geolocation-orientation.js","sourcesContent":["import Geolocation from '../src/ol/Geolocation.js';\nimport Map from '../src/ol/Map.js';\nimport Overlay from '../src/ol/Overlay.js';\nimport View from '../src/ol/View.js';\nimport {defaults as defaultControls} from '../src/ol/control.js';\nimport LineString from '../src/ol/geom/LineString.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport {fromLonLat} from '../src/ol/proj.js';\nimport OSM from '../src/ol/source/OSM.js';\n\n// creating the view\nconst view = new View({\n  center: fromLonLat([5.8713, 45.6452]),\n  zoom: 19\n});\n\n// creating the map\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  target: 'map',\n  controls: defaultControls({\n    attributionOptions: {\n      collapsible: false\n    }\n  }),\n  view: view\n});\n\n// Geolocation marker\nconst markerEl = document.getElementById('geolocation_marker');\nconst marker = new Overlay({\n  positioning: 'center-center',\n  element: markerEl,\n  stopEvent: false\n});\nmap.addOverlay(marker);\n\n// LineString to store the different geolocation positions. This LineString\n// is time aware.\n// The Z dimension is actually used to store the rotation (heading).\nconst positions = new LineString([], /** @type {module:ol/geom/GeometryLayout} */ ('XYZM'));\n\n// Geolocation Control\nconst geolocation = new Geolocation({\n  projection: view.getProjection(),\n  trackingOptions: {\n    maximumAge: 10000,\n    enableHighAccuracy: true,\n    timeout: 600000\n  }\n});\n\nlet deltaMean = 500; // the geolocation sampling period mean in ms\n\n// Listen to position changes\ngeolocation.on('change', function() {\n  const position = geolocation.getPosition();\n  const accuracy = geolocation.getAccuracy();\n  const heading = geolocation.getHeading() || 0;\n  const speed = geolocation.getSpeed() || 0;\n  const m = Date.now();\n\n  addPosition(position, heading, m, speed);\n\n  const coords = positions.getCoordinates();\n  const len = coords.length;\n  if (len >= 2) {\n    deltaMean = (coords[len - 1][3] - coords[0][3]) / (len - 1);\n  }\n\n  const html = [\n    'Position: ' + position[0].toFixed(2) + ', ' + position[1].toFixed(2),\n    'Accuracy: ' + accuracy,\n    'Heading: ' + Math.round(radToDeg(heading)) + '&deg;',\n    'Speed: ' + (speed * 3.6).toFixed(1) + ' km/h',\n    'Delta: ' + Math.round(deltaMean) + 'ms'\n  ].join('<br />');\n  document.getElementById('info').innerHTML = html;\n});\n\ngeolocation.on('error', function() {\n  alert('geolocation error');\n  // FIXME we should remove the coordinates in positions\n});\n\n// convert radians to degrees\nfunction radToDeg(rad) {\n  return rad * 360 / (Math.PI * 2);\n}\n// convert degrees to radians\nfunction degToRad(deg) {\n  return deg * Math.PI * 2 / 360;\n}\n// modulo for negative values\nfunction mod(n) {\n  return ((n % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);\n}\n\nfunction addPosition(position, heading, m, speed) {\n  const x = position[0];\n  const y = position[1];\n  const fCoords = positions.getCoordinates();\n  const previous = fCoords[fCoords.length - 1];\n  const prevHeading = previous && previous[2];\n  if (prevHeading) {\n    let headingDiff = heading - mod(prevHeading);\n\n    // force the rotation change to be less than 180Â°\n    if (Math.abs(headingDiff) > Math.PI) {\n      const sign = (headingDiff >= 0) ? 1 : -1;\n      headingDiff = -sign * (2 * Math.PI - Math.abs(headingDiff));\n    }\n    heading = prevHeading + headingDiff;\n  }\n  positions.appendCoordinate([x, y, heading, m]);\n\n  // only keep the 20 last coordinates\n  positions.setCoordinates(positions.getCoordinates().slice(-20));\n\n  // FIXME use speed instead\n  if (heading && speed) {\n    markerEl.src = 'data/geolocation_marker_heading.png';\n  } else {\n    markerEl.src = 'data/geolocation_marker.png';\n  }\n}\n\n// recenters the view by putting the given coordinates at 3/4 from the top or\n// the screen\nfunction getCenterWithHeading(position, rotation, resolution) {\n  const size = map.getSize();\n  const height = size[1];\n\n  return [\n    position[0] - Math.sin(rotation) * height * resolution * 1 / 4,\n    position[1] + Math.cos(rotation) * height * resolution * 1 / 4\n  ];\n}\n\nlet previousM = 0;\nfunction updateView() {\n  // use sampling period to get a smooth transition\n  let m = Date.now() - deltaMean * 1.5;\n  m = Math.max(m, previousM);\n  previousM = m;\n  // interpolate position along positions LineString\n  const c = positions.getCoordinateAtM(m, true);\n  if (c) {\n    view.setCenter(getCenterWithHeading(c, -c[2], view.getResolution()));\n    view.setRotation(-c[2]);\n    marker.setPosition(c);\n  }\n}\n\n// geolocate device\nconst geolocateBtn = document.getElementById('geolocate');\ngeolocateBtn.addEventListener('click', function() {\n  geolocation.setTracking(true); // Start position tracking\n\n  map.on('postcompose', updateView);\n  map.render();\n\n  disableButtons();\n}, false);\n\n// simulate device move\nlet simulationData;\nconst client = new XMLHttpRequest();\nclient.open('GET', 'data/geolocation-orientation.json');\n\n\n/**\n * Handle data loading.\n */\nclient.onload = function() {\n  simulationData = JSON.parse(client.responseText).data;\n};\nclient.send();\n\nconst simulateBtn = document.getElementById('simulate');\nsimulateBtn.addEventListener('click', function() {\n  const coordinates = simulationData;\n\n  const first = coordinates.shift();\n  simulatePositionChange(first);\n\n  let prevDate = first.timestamp;\n  function geolocate() {\n    const position = coordinates.shift();\n    if (!position) {\n      return;\n    }\n    const newDate = position.timestamp;\n    simulatePositionChange(position);\n    window.setTimeout(function() {\n      prevDate = newDate;\n      geolocate();\n    }, (newDate - prevDate) / 0.5);\n  }\n  geolocate();\n\n  map.on('postcompose', updateView);\n  map.render();\n\n  disableButtons();\n}, false);\n\nfunction simulatePositionChange(position) {\n  const coords = position.coords;\n  geolocation.set('accuracy', coords.accuracy);\n  geolocation.set('heading', degToRad(coords.heading));\n  const projectedPosition = fromLonLat([coords.longitude, coords.latitude]);\n  geolocation.set('position', projectedPosition);\n  geolocation.set('speed', coords.speed);\n  geolocation.changed();\n}\n\nfunction disableButtons() {\n  geolocateBtn.disabled = 'disabled';\n  simulateBtn.disabled = 'disabled';\n}\n"],"sourceRoot":""}