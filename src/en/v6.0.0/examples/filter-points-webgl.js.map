{"version":3,"sources":["webpack:///./filter-points-webgl.js"],"names":["vectorSource","attributions","oldColor","newColor","startTime","Date","now","minYearInput","document","getElementById","maxYearInput","updateStatusText","const","div","querySelector","textContent","value","addEventListener","client","WebglPointsLayer","createRenderer","this","attributes","name","callback","feature","get","vertexShader","join","fragmentShader","uniforms","u_time","u_minYear","parseInt","u_maxYear","XMLHttpRequest","open","onload","curIndex","csv","responseText","features","prevIndex","indexOf","line","substr","split","coords","parseFloat","isNaN","push","mass","year","geometry","addFeatures","send","map","layers","source","layer","target","view","center","zoom","animate","render","window","requestAnimationFrame"],"mappings":"2FAAA,wGAaMA,EAAe,IAAI,IAAO,CAC9BC,aAAc,SAGVC,EAAW,CAAC,IAAK,IAAK,KACtBC,EAAW,CAAC,IAAK,GAAI,IAErBC,EAAyB,KAAbC,KAAKC,MAGjBC,EAAeC,SAASC,eAAe,YACvCC,EAAeF,SAASC,eAAe,YAC7C,SAASE,IACPC,IAAMC,EAAML,SAASC,eAAe,UACpCI,EAAIC,cAAc,iBAAiBC,YAAcR,EAAaS,MAC9DH,EAAIC,cAAc,iBAAiBC,YAAcL,EAAaM,MAEhET,EAAaU,iBAAiB,QAASN,GACvCJ,EAAaU,iBAAiB,SAAUN,GACxCD,EAAaO,iBAAiB,QAASN,GACvCD,EAAaO,iBAAiB,SAAUN,GACxCA,IAEA,IA6FQO,EA7FFC,EAAoC,Y,+IACxCC,eAAA,WACE,OAAO,IAAI,IAAyBC,KAAM,CACxCC,WAAY,CACV,CACEC,KAAM,OACNC,SAAU,SAASC,GACjB,OAAO,GAAK,YAAMA,EAAQC,IAAI,QAAU,IAAQ,EAAG,GAAK,IAG5D,CACEH,KAAM,OACNC,SAAU,SAASC,GACjB,OAAOA,EAAQC,IAAI,WAIzBC,aAAc,CACZ,2BAEA,mCACA,oCACA,qCACA,6BACA,2BACA,0BACA,0BACA,2BACA,wBAEA,oBACA,6CACA,qFACA,qFACA,oEACA,6EACA,4DACA,4DACA,6BACA,qBACA,KACAC,KAAK,KACPC,eAAgB,CACd,2BAEA,wBACA,2BACA,2BACA,2BACA,wBAEA,oBAGA,oDACA,eACA,MAEA,uDACA,wEACA,0CACA,+CAGA,0EACA,2BAA6B,YAAY3B,GAAY,KACrD,YAAc,YAAYC,GAAY,aAEtC,wBACA,kFAEA,qCACA,6BACA,wCACA,KACAyB,KAAK,KACPE,SAAU,CACRC,OAAQ,WACN,MAAoB,KAAb1B,KAAKC,MAAgBF,GAE9B4B,UAAW,WACT,OAAOC,SAAS1B,EAAaS,QAE/BkB,UAAW,WACT,OAAOD,SAASvB,EAAaM,Y,EApFG,CAAX,MA6FvBE,EAAS,IAAIiB,gBACZC,KAAK,MAAO,mCACnBlB,EAAOmB,OAAS,WAOd,IANAzB,IAKI0B,EALEC,EAAMrB,EAAOsB,aACbC,EAAW,GAEbC,EAAYH,EAAII,QAAQ,MAAQ,GAGiB,IAA7CL,EAAWC,EAAII,QAAQ,KAAMD,KAAmB,CACtD9B,IAAMgC,EAAOL,EAAIM,OAAOH,EAAWJ,EAAWI,GAAWI,MAAM,KAC/DJ,EAAYJ,EAAW,EAEvB1B,IAAMmC,EAAS,YAAW,CAACC,WAAWJ,EAAK,IAAKI,WAAWJ,EAAK,MAC5DK,MAAMF,EAAO,KAAOE,MAAMF,EAAO,KAKrCN,EAASS,KAAK,IAAI,IAAQ,CACxBC,KAAMH,WAAWJ,EAAK,KAAO,EAC7BQ,KAAMnB,SAASW,EAAK,KAAO,EAC3BS,SAAU,IAAI,IAAMN,MAIxB/C,EAAasD,YAAYb,IAE3BvB,EAAOqC,OAKT3C,IAAM4C,EAAM,IAAI,IAAI,CAClBC,OAAQ,CACN,IAAI,IAAU,CACZC,OAAQ,IAAI,IAAO,CACjBC,MAAO,YAGX,IAAIxC,EAAiB,CACnBuC,OAAQ1D,KAGZ4D,OAAQpD,SAASC,eAAe,OAChCoD,KAAM,IAAI,IAAK,CACbC,OAAQ,CAAC,EAAG,GACZC,KAAM,OAKV,SAASC,IACPR,EAAIS,SACJC,OAAOC,sBAAsBH,GAE/BA,K","file":"filter-points-webgl.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport Feature from '../src/ol/Feature.js';\nimport Point from '../src/ol/geom/Point.js';\nimport VectorLayer from '../src/ol/layer/Vector.js';\nimport {Vector} from '../src/ol/source.js';\nimport {fromLonLat} from '../src/ol/proj.js';\nimport WebGLPointsLayerRenderer from '../src/ol/renderer/webgl/PointsLayer.js';\nimport {clamp} from '../src/ol/math.js';\nimport Stamen from '../src/ol/source/Stamen.js';\nimport {formatColor} from '../src/ol/webgl/ShaderBuilder.js';\n\nconst vectorSource = new Vector({\n  attributions: 'NASA'\n});\n\nconst oldColor = [180, 140, 140];\nconst newColor = [255, 80, 80];\n\nconst startTime = Date.now() * 0.001;\n\n// hanle input values & events\nconst minYearInput = document.getElementById('min-year');\nconst maxYearInput = document.getElementById('max-year');\nfunction updateStatusText() {\n  const div = document.getElementById('status');\n  div.querySelector('span.min-year').textContent = minYearInput.value;\n  div.querySelector('span.max-year').textContent = maxYearInput.value;\n}\nminYearInput.addEventListener('input', updateStatusText);\nminYearInput.addEventListener('change', updateStatusText);\nmaxYearInput.addEventListener('input', updateStatusText);\nmaxYearInput.addEventListener('change', updateStatusText);\nupdateStatusText();\n\nclass WebglPointsLayer extends VectorLayer {\n  createRenderer() {\n    return new WebGLPointsLayerRenderer(this, {\n      attributes: [\n        {\n          name: 'size',\n          callback: function(feature) {\n            return 18 * clamp(feature.get('mass') / 200000, 0, 1) + 8;\n          }\n        },\n        {\n          name: 'year',\n          callback: function(feature) {\n            return feature.get('year');\n          }\n        }\n      ],\n      vertexShader: [\n        'precision mediump float;',\n\n        'uniform mat4 u_projectionMatrix;',\n        'uniform mat4 u_offsetScaleMatrix;',\n        'uniform mat4 u_offsetRotateMatrix;',\n        'attribute vec2 a_position;',\n        'attribute float a_index;',\n        'attribute float a_size;',\n        'attribute float a_year;',\n        'varying vec2 v_texCoord;',\n        'varying float v_year;',\n\n        'void main(void) {',\n        '  mat4 offsetMatrix = u_offsetScaleMatrix;',\n        '  float offsetX = a_index == 0.0 || a_index == 3.0 ? -a_size / 2.0 : a_size / 2.0;',\n        '  float offsetY = a_index == 0.0 || a_index == 1.0 ? -a_size / 2.0 : a_size / 2.0;',\n        '  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);',\n        '  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;',\n        '  float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;',\n        '  float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;',\n        '  v_texCoord = vec2(u, v);',\n        '  v_year = a_year;',\n        '}'\n      ].join(' '),\n      fragmentShader: [\n        'precision mediump float;',\n\n        'uniform float u_time;',\n        'uniform float u_minYear;',\n        'uniform float u_maxYear;',\n        'varying vec2 v_texCoord;',\n        'varying float v_year;',\n\n        'void main(void) {',\n\n        // filter out pixels if the year is outside of the given range\n        '  if (v_year < u_minYear || v_year > u_maxYear) {',\n        '    discard;',\n        '  }',\n\n        '  vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);',\n        '  float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;',\n        '  float value = 2.0 * (1.0 - sqRadius);',\n        '  float alpha = smoothstep(0.0, 1.0, value);',\n\n        // color is interpolated based on year\n        '  float ratio = clamp((v_year - 1800.0) / (2013.0 - 1800.0), 0.0, 1.1);',\n        '  vec3 color = mix(vec3(' + formatColor(oldColor) + '),',\n        '    vec3(' + formatColor(newColor) + '), ratio);',\n\n        '  float period = 8.0;',\n        '  color.g *= 2.0 * (1.0 - sqrt(mod(u_time + v_year * 0.025, period) / period));',\n\n        '  gl_FragColor = vec4(color, 1.0);',\n        '  gl_FragColor.a *= alpha;',\n        '  gl_FragColor.rgb *= gl_FragColor.a;',\n        '}'\n      ].join(' '),\n      uniforms: {\n        u_time: function() {\n          return Date.now() * 0.001 - startTime;\n        },\n        u_minYear: function() {\n          return parseInt(minYearInput.value);\n        },\n        u_maxYear: function() {\n          return parseInt(maxYearInput.value);\n        }\n      }\n    });\n  }\n}\n\n\nfunction loadData() {\n  const client = new XMLHttpRequest();\n  client.open('GET', 'data/csv/meteorite_landings.csv');\n  client.onload = function() {\n    const csv = client.responseText;\n    const features = [];\n\n    let prevIndex = csv.indexOf('\\n') + 1; // scan past the header line\n\n    let curIndex;\n    while ((curIndex = csv.indexOf('\\n', prevIndex)) != -1) {\n      const line = csv.substr(prevIndex, curIndex - prevIndex).split(',');\n      prevIndex = curIndex + 1;\n\n      const coords = fromLonLat([parseFloat(line[4]), parseFloat(line[3])]);\n      if (isNaN(coords[0]) || isNaN(coords[1])) {\n        // guard against bad data\n        continue;\n      }\n\n      features.push(new Feature({\n        mass: parseFloat(line[1]) || 0,\n        year: parseInt(line[2]) || 0,\n        geometry: new Point(coords)\n      }));\n    }\n\n    vectorSource.addFeatures(features);\n  };\n  client.send();\n}\n\nloadData();\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new Stamen({\n        layer: 'toner'\n      })\n    }),\n    new WebglPointsLayer({\n      source: vectorSource\n    })\n  ],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\n// animate the map\nfunction animate() {\n  map.render();\n  window.requestAnimationFrame(animate);\n}\nanimate();\n"],"sourceRoot":""}