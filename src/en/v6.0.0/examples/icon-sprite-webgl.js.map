{"version":3,"sources":["webpack:///./icon-sprite-webgl.js"],"names":["vectorSource","features","attributions","texture","Image","src","const","client","shapeTextureCoords","oldColor","newColor","WebglPointsLayer","createRenderer","this","attributes","name","callback","feature","get","let","coords","uniforms","u_texture","vertexShader","size","join","fragmentShader","hitVertexShader","hitFragmentShader","XMLHttpRequest","open","onload","curIndex","csv","responseText","prevIndex","indexOf","line","substr","split","parseFloat","isNaN","push","datetime","year","parseInt","exec","shape","duration","geometry","addFeatures","send","map","layers","source","url","crossOrigin","target","document","getElementById","view","center","zoom","info","on","evt","getView","getInteracting","pixel","innerText","forEachFeatureAtPixel","addEventListener","render"],"mappings":"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","file":"icon-sprite-webgl.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport TileJSON from '../src/ol/source/TileJSON.js';\nimport Feature from '../src/ol/Feature.js';\nimport Point from '../src/ol/geom/Point.js';\nimport VectorLayer from '../src/ol/layer/Vector.js';\nimport {Vector} from '../src/ol/source.js';\nimport {fromLonLat} from '../src/ol/proj.js';\nimport WebGLPointsLayerRenderer from '../src/ol/renderer/webgl/PointsLayer.js';\nimport {formatColor, formatNumber} from '../src/ol/webgl/ShaderBuilder.js';\n\nconst key = 'pk.eyJ1IjoidHNjaGF1YiIsImEiOiJjaW5zYW5lNHkxMTNmdWttM3JyOHZtMmNtIn0.CDIBD8H-G2Gf-cPkIuWtRg';\n\nconst vectorSource = new Vector({\n  features: [],\n  attributions: 'National UFO Reporting Center'\n});\n\nconst texture = new Image();\ntexture.src = 'data/ufo_shapes.png';\n\n// This describes the content of the associated sprite sheet\n// coords are u0, v0 for a given shape (all icons have a size of 0.25 x 0.5)\nconst shapeTextureCoords = {\n  'light': [0, 0],\n  'sphere': [0.25, 0],\n  'circle': [0.25, 0],\n  'disc': [0.5, 0],\n  'oval': [0.5, 0],\n  'triangle': [0.75, 0],\n  'fireball': [0, 0.5],\n  'default': [0.75, 0.5]\n};\n\nconst oldColor = [255, 160, 110];\nconst newColor = [180, 255, 200];\nconst size = 16;\n\nclass WebglPointsLayer extends VectorLayer {\n  createRenderer() {\n    return new WebGLPointsLayerRenderer(this, {\n      attributes: [\n        {\n          name: 'year',\n          callback: function(feature) {\n            return feature.get('year');\n          }\n        },\n        {\n          name: 'texCoordU',\n          callback: function(feature) {\n            let coords = shapeTextureCoords[feature.get('shape')];\n            if (!coords) {\n              coords = shapeTextureCoords['default'];\n            }\n            return coords[0];\n          }\n        },\n        {\n          name: 'texCoordV',\n          callback: function(feature) {\n            let coords = shapeTextureCoords[feature.get('shape')];\n            if (!coords) {\n              coords = shapeTextureCoords['default'];\n            }\n            return coords[1];\n          }\n        }\n      ],\n      uniforms: {\n        u_texture: texture\n      },\n      vertexShader: [\n        'precision mediump float;',\n\n        'uniform mat4 u_projectionMatrix;',\n        'uniform mat4 u_offsetScaleMatrix;',\n        'uniform mat4 u_offsetRotateMatrix;',\n        'attribute vec2 a_position;',\n        'attribute float a_index;',\n        'attribute float a_year;',\n        'attribute float a_texCoordU;',\n        'attribute float a_texCoordV;',\n        'varying vec2 v_texCoord;',\n        'varying float v_year;',\n\n        'void main(void) {',\n        '  mat4 offsetMatrix = u_offsetScaleMatrix;',\n        '  float offsetX = a_index == 0.0 || a_index == 3.0 ? ',\n        '    ' + formatNumber(-size / 2) + ' : ' + formatNumber(size / 2) + ';',\n        '  float offsetY = a_index == 0.0 || a_index == 1.0 ? ',\n        '    ' + formatNumber(-size / 2) + ' : ' + formatNumber(size / 2) + ';',\n        '  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);',\n        '  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;',\n        '  float u = a_index == 0.0 || a_index == 3.0 ? a_texCoordU : a_texCoordU + 0.25;',\n        '  float v = a_index == 2.0 || a_index == 3.0 ? a_texCoordV : a_texCoordV + 0.5;',\n        '  v_texCoord = vec2(u, v);',\n        '  v_year = a_year;',\n        '}'\n      ].join(' '),\n      fragmentShader: [\n        'precision mediump float;',\n\n        'uniform float u_time;',\n        'uniform float u_minYear;',\n        'uniform float u_maxYear;',\n        'uniform sampler2D u_texture;',\n        'varying vec2 v_texCoord;',\n        'varying float v_year;',\n\n        'void main(void) {',\n        '  vec4 textureColor = texture2D(u_texture, v_texCoord);',\n        '  if (textureColor.a < 0.1) {',\n        '    discard;',\n        '  }',\n\n        // color is interpolated based on year\n        '  float ratio = clamp((v_year - 1950.0) / (2013.0 - 1950.0), 0.0, 1.1);',\n        '  vec3 color = mix(vec3(' + formatColor(oldColor) + '),',\n        '    vec3(' + formatColor(newColor) + '), ratio);',\n\n        '  gl_FragColor = vec4(color, 1.0) * textureColor;',\n        '  gl_FragColor.rgb *= gl_FragColor.a;',\n        '}'\n      ].join(' '),\n      hitVertexShader: [\n        'precision mediump float;',\n\n        'uniform mat4 u_projectionMatrix;',\n        'uniform mat4 u_offsetScaleMatrix;',\n        'uniform mat4 u_offsetRotateMatrix;',\n        'attribute vec2 a_position;',\n        'attribute float a_index;',\n        'attribute vec4 a_hitColor;',\n        'attribute float a_texCoordU;',\n        'attribute float a_texCoordV;',\n        'varying vec2 v_texCoord;',\n        'varying vec4 v_hitColor;',\n\n        'void main(void) {',\n        '  mat4 offsetMatrix = u_offsetScaleMatrix;',\n        '  float offsetX = a_index == 0.0 || a_index == 3.0 ? ',\n        '    ' + formatNumber(-size / 2) + ' : ' + formatNumber(size / 2) + ';',\n        '  float offsetY = a_index == 0.0 || a_index == 1.0 ? ',\n        '    ' + formatNumber(-size / 2) + ' : ' + formatNumber(size / 2) + ';',\n        '  vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);',\n        '  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;',\n        '  float u = a_index == 0.0 || a_index == 3.0 ? a_texCoordU : a_texCoordU + 0.25;',\n        '  float v = a_index == 2.0 || a_index == 3.0 ? a_texCoordV : a_texCoordV + 0.5;',\n        '  v_texCoord = vec2(u, v);',\n        '  v_hitColor = a_hitColor;',\n        '}'\n      ].join(' '),\n      hitFragmentShader: [\n        'precision mediump float;',\n\n        'uniform sampler2D u_texture;',\n        'varying vec2 v_texCoord;',\n        'varying vec4 v_hitColor;',\n\n        'void main(void) {',\n        '  vec4 textureColor = texture2D(u_texture, v_texCoord);',\n        '  if (textureColor.a < 0.1) {',\n        '    discard;',\n        '  }',\n\n        '  gl_FragColor = v_hitColor;',\n        '}'\n      ].join(' ')\n    });\n  }\n}\n\n\nfunction loadData() {\n  const client = new XMLHttpRequest();\n  client.open('GET', 'data/csv/ufo_sighting_data.csv');\n  client.onload = function() {\n    const csv = client.responseText;\n    const features = [];\n\n    let prevIndex = csv.indexOf('\\n') + 1; // scan past the header line\n\n    let curIndex;\n    while ((curIndex = csv.indexOf('\\n', prevIndex)) != -1) {\n      const line = csv.substr(prevIndex, curIndex - prevIndex).split(',');\n      prevIndex = curIndex + 1;\n\n      const coords = fromLonLat([parseFloat(line[5]), parseFloat(line[4])]);\n\n      // only keep valid points\n      if (isNaN(coords[0]) || isNaN(coords[1])) {\n        continue;\n      }\n\n      features.push(new Feature({\n        datetime: line[0],\n        year: parseInt(/[0-9]{4}/.exec(line[0])[0]), // extract the year as int\n        shape: line[2],\n        duration: line[3],\n        geometry: new Point(coords)\n      }));\n    }\n    vectorSource.addFeatures(features);\n  };\n  client.send();\n}\n\nloadData();\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new TileJSON({\n        url: 'https://api.tiles.mapbox.com/v4/mapbox.world-dark.json?secure&access_token=' + key,\n        crossOrigin: 'anonymous'\n      })\n    }),\n    new WebglPointsLayer({\n      source: vectorSource\n    })\n  ],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [0, 4000000],\n    zoom: 2\n  })\n});\n\nconst info = document.getElementById('info');\nmap.on('pointermove', function(evt) {\n  if (map.getView().getInteracting()) {\n    return;\n  }\n  const pixel = evt.pixel;\n  info.innerText = '';\n  map.forEachFeatureAtPixel(pixel, function(feature) {\n    const datetime = feature.get('datetime');\n    const duration = feature.get('duration');\n    const shape = feature.get('shape');\n    info.innerText = 'On ' + datetime + ', lasted ' + duration + ' seconds and had a \"' + shape + '\" shape.';\n  });\n});\n\ntexture.addEventListener('load', function() {\n  map.render();\n});\n"],"sourceRoot":""}