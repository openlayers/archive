{"version":3,"sources":["webpack:///./webgl-points-layer.js","webpack:///../src/ol/layer/WebGLPoints.js"],"names":["pointsLayer","WebGLPoints","options","const","baseOptions","super","this","style","undefined","symbol","createRenderer","parseResult","vertexShader","params","fragmentShader","uniforms","attributes","vectorSource","Vector","url","format","GeoJSON","predefinedStyles","symbolType","src","size","color","rotateWithView","offset","opacity","literalStyle","map","Map","layers","Tile","source","OSM","target","document","getElementById","view","View","center","zoom","editor","refreshLayer","removeLayer","addLayer","setStyleStatus","valid","display","value","JSON","stringify","addEventListener","textStyle","parse","e"],"mappings":"uGAiDIA,E,sDC+CWC,EAhCqB,YAIlC,WAAYC,GACVC,IAAMC,EAAc,YAAO,GAAIF,GAE/BG,OAAM,KAAAD,GAKNE,KAAKC,MAAQL,EAAQK,MAErB,iBAA6BC,IAAtBF,KAAKC,MAAME,OAAsB,I,0GAM1CC,eAAA,WACEP,IAAMQ,EAAc,YAAiBL,KAAKC,MAAME,QAEhD,OAAO,IAAI,IAAyBH,KAAM,CACxCM,aAAc,YAAsBD,EAAYE,QAChDC,eAAgB,YAAwBH,EAAYE,QACpDE,SAAUJ,EAAYI,SACtBC,WAAYL,EAAYK,c,EA3BM,C,MAAL,G,uBDxDzBC,EAAe,IAAIC,EAAA,EAAO,CAC9BC,IAAK,oCACLC,OAAQ,IAAIC,EAAA,IAGRC,EAAmB,CACvB,MAAS,CACPb,OAAQ,CACNc,WAAY,QACZC,IAAK,gBACLC,KAAM,CAAC,GAAI,IACXC,MAAO,cACPC,gBAAgB,EAChBC,OAAQ,CAAC,EAAG,KAGhB,UAAa,CACXnB,OAAQ,CACNc,WAAY,WACZE,KAAM,GACNC,MAAO,CACL,CAAC,UAAW,CAAC,MAAO,cAAe,IAAO,IAAQ,GAAK,GACvD,CAAC,UAAW,CAAC,MAAO,cAAe,IAAO,IAAQ,GAAK,IACvD,GACA,GAEFC,gBAAgB,IAGpB,QAAW,CACTlB,OAAQ,CACNc,WAAY,SACZE,KAAM,CAAC,UAAW,CAAC,MAAO,cAAe,IAAO,IAAS,EAAG,IAC5DC,MAAO,UACPC,gBAAgB,EAChBC,OAAQ,CAAC,EAAG,GACZC,QAAS,CAAC,UAAW,CAAC,MAAO,cAAe,IAAO,IAAS,GAAK,QAInEC,EAAeR,EAA0B,QAGvCS,EAAM,IAAIC,EAAA,EAAI,CAClBC,OAAQ,CACN,IAAIC,EAAA,EAAU,CACZC,OAAQ,IAAIC,EAAA,KAGhBC,OAAQC,SAASC,eAAe,OAChCC,KAAM,IAAIC,EAAA,EAAK,CACbC,OAAQ,CAAC,EAAG,GACZC,KAAM,MAIJC,EAASN,SAASC,eAAe,gBAGvC,SAASM,IACH7C,GACF+B,EAAIe,YAAY9C,GAElBA,EAAc,IAAIC,EAAiB,CACjCkC,OAAQlB,EACRV,MAAOuB,IAETC,EAAIgB,SAAS/C,GAGf,SAASgD,EAAeC,GACtBX,SAASC,eAAe,eAAehC,MAAM2C,QAAUD,EAAQ,UAAY,OAC3EX,SAASC,eAAe,iBAAiBhC,MAAM2C,QAAWD,EAAoB,OAAZ,UAfpEL,EAAOO,MAAQC,KAAKC,UAAUvB,EAAc,KAAM,GAkBlDc,EAAOU,iBAAiB,QAAS,WAC/BnD,IAAMoD,EAAYX,EAAOO,MACzB,GAAIC,KAAKC,UAAUD,KAAKI,MAAMD,MAAgBH,KAAKC,UAAUvB,GAI7D,IACEA,EAAesB,KAAKI,MAAMD,GAC1BV,IACAG,GAAe,GACf,MAAOS,GACPT,GAAe,MAGnBH,IAEA1C,IAAM,EAASmC,SAASC,eAAe,gBACvC,EAAOe,iBAAiB,SAAU,WAChCnD,IAAMI,EAAQ,EAAO4C,MACrBrB,EAAeR,EAAiBf,GAChCqC,EAAOO,MAAQC,KAAKC,UAAUvB,EAAc,KAAM,GAClDe,Q","file":"webgl-points-layer.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport WebGLPointsLayer from '../src/ol/layer/WebGLPoints.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport Vector from '../src/ol/source/Vector.js';\nimport OSM from '../src/ol/source/OSM.js';\n\nconst vectorSource = new Vector({\n  url: 'data/geojson/world-cities.geojson',\n  format: new GeoJSON()\n});\n\nconst predefinedStyles = {\n  'icons': {\n    symbol: {\n      symbolType: 'image',\n      src: 'data/icon.png',\n      size: [18, 28],\n      color: 'lightyellow',\n      rotateWithView: false,\n      offset: [0, 9]\n    }\n  },\n  'triangles': {\n    symbol: {\n      symbolType: 'triangle',\n      size: 18,\n      color: [\n        ['stretch', ['get', 'population'], 20000, 300000, 0.1, 1.0],\n        ['stretch', ['get', 'population'], 20000, 300000, 0.6, 0.3],\n        0.6,\n        1.0\n      ],\n      rotateWithView: true\n    }\n  },\n  'circles': {\n    symbol: {\n      symbolType: 'circle',\n      size: ['stretch', ['get', 'population'], 40000, 2000000, 8, 28],\n      color: '#006688',\n      rotateWithView: false,\n      offset: [0, 0],\n      opacity: ['stretch', ['get', 'population'], 40000, 2000000, 0.6, 0.92]\n    }\n  }\n};\nlet literalStyle = predefinedStyles['circles'];\nlet pointsLayer;\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    })\n  ],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [0, 0],\n    zoom: 2\n  })\n});\n\nconst editor = document.getElementById('style-editor');\neditor.value = JSON.stringify(literalStyle, null, 2);\n\nfunction refreshLayer() {\n  if (pointsLayer) {\n    map.removeLayer(pointsLayer);\n  }\n  pointsLayer = new WebGLPointsLayer({\n    source: vectorSource,\n    style: literalStyle\n  });\n  map.addLayer(pointsLayer);\n}\n\nfunction setStyleStatus(valid) {\n  document.getElementById('style-valid').style.display = valid ? 'initial' : 'none';\n  document.getElementById('style-invalid').style.display = !valid ? 'initial' : 'none';\n}\n\neditor.addEventListener('input', function() {\n  const textStyle = editor.value;\n  if (JSON.stringify(JSON.parse(textStyle)) === JSON.stringify(literalStyle)) {\n    return;\n  }\n\n  try {\n    literalStyle = JSON.parse(textStyle);\n    refreshLayer();\n    setStyleStatus(true);\n  } catch (e) {\n    setStyleStatus(false);\n  }\n});\nrefreshLayer();\n\nconst select = document.getElementById('style-select');\nselect.addEventListener('change', function() {\n  const style = select.value;\n  literalStyle = predefinedStyles[style];\n  editor.value = JSON.stringify(literalStyle, null, 2);\n  refreshLayer();\n});\n","/**\n * @module ol/layer/WebGLPoints\n */\nimport {assign} from '../obj.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport {getSymbolFragmentShader, getSymbolVertexShader, parseSymbolStyle} from '../webgl/ShaderBuilder.js';\nimport {assert} from '../asserts.js';\nimport Layer from './Layer.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {import('../style/LiteralStyle.js').LiteralStyle} style Literal style to apply to the layer features.\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {import(\"../source/Vector.js\").default} [source] Source.\n */\n\n\n/**\n * @classdesc\n * Layer optimized for rendering large point datasets. Takes a `style` property which\n * is a serializable JSON object describing how the layer should be rendered.\n *\n * Here are a few samples of literal style objects:\n * ```js\n * const style = {\n *   symbol: {\n *     symbolType: 'circle',\n *     size: 8,\n *     color: '#33AAFF',\n *     opacity: 0.9\n *   }\n * }\n * ```\n *\n * ```js\n * const style = {\n *   symbol: {\n *     symbolType: 'image',\n *     offset: [0, 12],\n *     size: [4, 8],\n *     src: '../static/exclamation-mark.png'\n *   }\n * }\n * ```\n *\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n */\nclass WebGLPointsLayer extends Layer {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    const baseOptions = assign({}, options);\n\n    super(baseOptions);\n\n    /**\n     * @type {import('../style/LiteralStyle.js').LiteralStyle}\n     */\n    this.style = options.style;\n\n    assert(this.style.symbol !== undefined, 65);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  createRenderer() {\n    const parseResult = parseSymbolStyle(this.style.symbol);\n\n    return new WebGLPointsLayerRenderer(this, {\n      vertexShader: getSymbolVertexShader(parseResult.params),\n      fragmentShader: getSymbolFragmentShader(parseResult.params),\n      uniforms: parseResult.uniforms,\n      attributes: parseResult.attributes\n    });\n  }\n}\n\nexport default WebGLPointsLayer;\n"],"sourceRoot":""}