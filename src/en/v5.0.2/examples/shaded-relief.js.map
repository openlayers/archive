{"version":3,"sources":["webpack:///./shaded-relief.js"],"names":["elevation","_src_ol_source_js__WEBPACK_IMPORTED_MODULE_4__","url","crossOrigin","transition","raster","_src_ol_source_js__WEBPACK_IMPORTED_MODULE_5__","sources","operationType","operation","inputs","data","elevationImage","width","height","elevationData","shadeData","Uint8ClampedArray","length","dp","resolution","maxX","maxY","pixel","twoPi","Math","PI","halfPi","sunEl","sunAz","cosSunEl","cos","sinSunEl","sin","pixelX","pixelY","x0","x1","y0","y1","offset","z0","z1","dzdx","dzdy","slope","aspect","cosIncidence","scaled","vert","atan","sqrt","atan2","controls","_src_ol_Map_js__WEBPACK_IMPORTED_MODULE_0__","target","layers","_src_ol_layer_js__WEBPACK_IMPORTED_MODULE_2__","source","_src_ol_source_js__WEBPACK_IMPORTED_MODULE_6__","_src_ol_layer_js__WEBPACK_IMPORTED_MODULE_3__","opacity","view","_src_ol_View_js__WEBPACK_IMPORTED_MODULE_1__","extent","center","minZoom","maxZoom","zoom","forEach","id","control","document","getElementById","output","addEventListener","innerText","value","changed","on","event","Number"],"mappings":"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","file":"shaded-relief.js","sourcesContent":["import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {Image as ImageLayer, Tile as TileLayer} from '../src/ol/layer.js';\nimport {OSM, Raster, XYZ} from '../src/ol/source.js';\n\n\n/**\n * Generates a shaded relief image given elevation data.  Uses a 3x3\n * neighborhood for determining slope and aspect.\n * @param {Array.<ImageData>} inputs Array of input images.\n * @param {Object} data Data added in the \"beforeoperations\" event.\n * @return {ImageData} Output image.\n */\nfunction shade(inputs, data) {\n  const elevationImage = inputs[0];\n  const width = elevationImage.width;\n  const height = elevationImage.height;\n  const elevationData = elevationImage.data;\n  const shadeData = new Uint8ClampedArray(elevationData.length);\n  const dp = data.resolution * 2;\n  const maxX = width - 1;\n  const maxY = height - 1;\n  const pixel = [0, 0, 0, 0];\n  const twoPi = 2 * Math.PI;\n  const halfPi = Math.PI / 2;\n  const sunEl = Math.PI * data.sunEl / 180;\n  const sunAz = Math.PI * data.sunAz / 180;\n  const cosSunEl = Math.cos(sunEl);\n  const sinSunEl = Math.sin(sunEl);\n  let pixelX, pixelY, x0, x1, y0, y1, offset,\n      z0, z1, dzdx, dzdy, slope, aspect, cosIncidence, scaled;\n  for (pixelY = 0; pixelY <= maxY; ++pixelY) {\n    y0 = pixelY === 0 ? 0 : pixelY - 1;\n    y1 = pixelY === maxY ? maxY : pixelY + 1;\n    for (pixelX = 0; pixelX <= maxX; ++pixelX) {\n      x0 = pixelX === 0 ? 0 : pixelX - 1;\n      x1 = pixelX === maxX ? maxX : pixelX + 1;\n\n      // determine elevation for (x0, pixelY)\n      offset = (pixelY * width + x0) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z0 = data.vert * (pixel[0] + pixel[1] * 2 + pixel[2] * 3);\n\n      // determine elevation for (x1, pixelY)\n      offset = (pixelY * width + x1) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z1 = data.vert * (pixel[0] + pixel[1] * 2 + pixel[2] * 3);\n\n      dzdx = (z1 - z0) / dp;\n\n      // determine elevation for (pixelX, y0)\n      offset = (y0 * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z0 = data.vert * (pixel[0] + pixel[1] * 2 + pixel[2] * 3);\n\n      // determine elevation for (pixelX, y1)\n      offset = (y1 * width + pixelX) * 4;\n      pixel[0] = elevationData[offset];\n      pixel[1] = elevationData[offset + 1];\n      pixel[2] = elevationData[offset + 2];\n      pixel[3] = elevationData[offset + 3];\n      z1 = data.vert * (pixel[0] + pixel[1] * 2 + pixel[2] * 3);\n\n      dzdy = (z1 - z0) / dp;\n\n      slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));\n\n      aspect = Math.atan2(dzdy, -dzdx);\n      if (aspect < 0) {\n        aspect = halfPi - aspect;\n      } else if (aspect > halfPi) {\n        aspect = twoPi - aspect + halfPi;\n      } else {\n        aspect = halfPi - aspect;\n      }\n\n      cosIncidence = sinSunEl * Math.cos(slope) +\n          cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect);\n\n      offset = (pixelY * width + pixelX) * 4;\n      scaled = 255 * cosIncidence;\n      shadeData[offset] = scaled;\n      shadeData[offset + 1] = scaled;\n      shadeData[offset + 2] = scaled;\n      shadeData[offset + 3] = elevationData[offset + 3];\n    }\n  }\n\n  return {data: shadeData, width: width, height: height};\n}\n\nconst elevation = new XYZ({\n  url: 'https://{a-d}.tiles.mapbox.com/v3/aj.sf-dem/{z}/{x}/{y}.png',\n  crossOrigin: 'anonymous',\n  transition: 0\n});\n\nconst raster = new Raster({\n  sources: [elevation],\n  operationType: 'image',\n  operation: shade\n});\n\nconst map = new Map({\n  target: 'map',\n  layers: [\n    new TileLayer({\n      source: new OSM()\n    }),\n    new ImageLayer({\n      opacity: 0.3,\n      source: raster\n    })\n  ],\n  view: new View({\n    extent: [-13675026, 4439648, -13580856, 4580292],\n    center: [-13615645, 4497969],\n    minZoom: 10,\n    maxZoom: 16,\n    zoom: 13\n  })\n});\n\nconst controlIds = ['vert', 'sunEl', 'sunAz'];\nconst controls = {};\ncontrolIds.forEach(function(id) {\n  const control = document.getElementById(id);\n  const output = document.getElementById(id + 'Out');\n  control.addEventListener('input', function() {\n    output.innerText = control.value;\n    raster.changed();\n  });\n  output.innerText = control.value;\n  controls[id] = control;\n});\n\nraster.on('beforeoperations', function(event) {\n  // the event.data object will be passed to operations\n  const data = event.data;\n  data.resolution = event.resolution;\n  for (const id in controls) {\n    data[id] = Number(controls[id].value);\n  }\n});\n"],"sourceRoot":""}