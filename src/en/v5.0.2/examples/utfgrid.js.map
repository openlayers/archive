{"version":3,"sources":["webpack:///../src/ol/source/UTFGrid.js","webpack:///./utfgrid.js"],"names":["CustomTile","tileCoord","state","src","extent","preemptive","jsonp","ol_Tile","call","this","src_","extent_","preemptive_","grid_","keys_","data_","jsonp_","Object","util","prototype","getImage","getData","coordinate","xRelative","yRelative","row","Math","floor","length","code","charCodeAt","data","id","forDataAtCoordinate","callback","opt_this","opt_request","TileState","IDLE","events","EventType","CHANGE","e","loadInternal_","setTimeout","bind","getKey","handleError_","ERROR","changed","handleLoad_","json","grid","keys","EMPTY","LOADING","net","client","XMLHttpRequest","addEventListener","onXHRLoad_","onXHRError_","open","send","event","status","response","JSON","parse","responseText","err","load","UTFGrid","options","source_Tile","projection","proj","State","undefined","tileUrlFunction_","tileurlfunction","template_","url","handleTileJSONResponse","handleTileJSONError","tileJSON","asserts","getTemplate","forDataAtCoordinateAndResolution","resolution","tileGrid","getTileCoordForCoordAndResolution","getTile","getProjection","setState","epsg4326Projection","sourceProjection","bounds","transform","ol_extent","minZoom","minzoom","maxZoom","maxzoom","tilegrid","template","grids","attribution","attributionExtent","getExtent","setAttributions","frameState","READY","z","x","y","pixelRatio","tileCoordKey","tilecoord","tileCache","containsKey","get","urlTileCoord","getTileCoordForTileUrlFunction","tileUrl","tile","getTileCoordExtent","set","useTile","source_UTFGrid","key","mapLayer","Tile","source","TileJSON","gridSource","gridLayer","view","View","center","zoom","mapElement","document","getElementById","map","Map","layers","target","infoElement","flagElement","nameElement","infoOverlay","Overlay","element","offset","stopEvent","addOverlay","displayCountryInfo","viewResolution","getResolution","style","cursor","innerHTML","setPosition","on","evt","dragging","getEventCoordinate","originalEvent"],"mappings":"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","file":"utfgrid.js","sourcesContent":["/**\n * @module ol/source/UTFGrid\n */\nimport {inherits} from '../util.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {createFromTemplates, nullTileUrlFunction} from '../tileurlfunction.js';\nimport {assert} from '../asserts.js';\nimport {listenOnce} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {applyTransform, intersects} from '../extent.js';\nimport {jsonp as requestJSONP} from '../net.js';\nimport {get as getProjection, getTransformFromProjections} from '../proj.js';\nimport SourceState from '../source/State.js';\nimport TileSource from '../source/Tile.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n\n/**\n * @constructor\n * @extends {module:ol/Tile}\n * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.\n * @param {module:ol/TileState} state State.\n * @param {string} src Image source URI.\n * @param {module:ol/extent~Extent} extent Extent of the tile.\n * @param {boolean} preemptive Load the tile when visible (before it's needed).\n * @param {boolean} jsonp Load the tile as a script.\n */\nexport const CustomTile = function(tileCoord, state, src, extent, preemptive, jsonp) {\n\n  Tile.call(this, tileCoord, state);\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this.src_ = src;\n\n  /**\n   * @private\n   * @type {module:ol/extent~Extent}\n   */\n  this.extent_ = extent;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.preemptive_ = preemptive;\n\n  /**\n   * @private\n   * @type {Array.<string>}\n   */\n  this.grid_ = null;\n\n  /**\n   * @private\n   * @type {Array.<string>}\n   */\n  this.keys_ = null;\n\n  /**\n   * @private\n   * @type {Object.<string, Object>|undefined}\n   */\n  this.data_ = null;\n\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.jsonp_ = jsonp;\n\n};\ninherits(CustomTile, Tile);\n\n\n/**\n * Get the image element for this tile.\n * @return {Image} Image.\n */\nCustomTile.prototype.getImage = function() {\n  return null;\n};\n\n\n/**\n * Synchronously returns data at given coordinate (if available).\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @return {*} The data.\n */\nCustomTile.prototype.getData = function(coordinate) {\n  if (!this.grid_ || !this.keys_) {\n    return null;\n  }\n  const xRelative = (coordinate[0] - this.extent_[0]) /\n      (this.extent_[2] - this.extent_[0]);\n  const yRelative = (coordinate[1] - this.extent_[1]) /\n      (this.extent_[3] - this.extent_[1]);\n\n  const row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];\n\n  if (typeof row !== 'string') {\n    return null;\n  }\n\n  let code = row.charCodeAt(Math.floor(xRelative * row.length));\n  if (code >= 93) {\n    code--;\n  }\n  if (code >= 35) {\n    code--;\n  }\n  code -= 32;\n\n  let data = null;\n  if (code in this.keys_) {\n    const id = this.keys_[code];\n    if (this.data_ && id in this.data_) {\n      data = this.data_[id];\n    } else {\n      data = id;\n    }\n  }\n  return data;\n};\n\n\n/**\n * Calls the callback (synchronously by default) with the available data\n * for given coordinate (or `null` if not yet loaded).\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {function(this: T, *)} callback Callback.\n * @param {T=} opt_this The object to use as `this` in the callback.\n * @param {boolean=} opt_request If `true` the callback is always async.\n *                               The tile data is requested if not yet loaded.\n * @template T\n */\nCustomTile.prototype.forDataAtCoordinate = function(coordinate, callback, opt_this, opt_request) {\n  if (this.state == TileState.IDLE && opt_request === true) {\n    listenOnce(this, EventType.CHANGE, function(e) {\n      callback.call(opt_this, this.getData(coordinate));\n    }, this);\n    this.loadInternal_();\n  } else {\n    if (opt_request === true) {\n      setTimeout(function() {\n        callback.call(opt_this, this.getData(coordinate));\n      }.bind(this), 0);\n    } else {\n      callback.call(opt_this, this.getData(coordinate));\n    }\n  }\n};\n\n\n/**\n * @inheritDoc\n */\nCustomTile.prototype.getKey = function() {\n  return this.src_;\n};\n\n\n/**\n * @private\n */\nCustomTile.prototype.handleError_ = function() {\n  this.state = TileState.ERROR;\n  this.changed();\n};\n\n\n/**\n * @param {!UTFGridJSON} json UTFGrid data.\n * @private\n */\nCustomTile.prototype.handleLoad_ = function(json) {\n  this.grid_ = json.grid;\n  this.keys_ = json.keys;\n  this.data_ = json.data;\n\n  this.state = TileState.EMPTY;\n  this.changed();\n};\n\n\n/**\n * @private\n */\nCustomTile.prototype.loadInternal_ = function() {\n  if (this.state == TileState.IDLE) {\n    this.state = TileState.LOADING;\n    if (this.jsonp_) {\n      requestJSONP(this.src_, this.handleLoad_.bind(this),\n        this.handleError_.bind(this));\n    } else {\n      const client = new XMLHttpRequest();\n      client.addEventListener('load', this.onXHRLoad_.bind(this));\n      client.addEventListener('error', this.onXHRError_.bind(this));\n      client.open('GET', this.src_);\n      client.send();\n    }\n  }\n};\n\n\n/**\n * @private\n * @param {Event} event The load event.\n */\nCustomTile.prototype.onXHRLoad_ = function(event) {\n  const client = /** @type {XMLHttpRequest} */ (event.target);\n  // status will be 0 for file:// urls\n  if (!client.status || client.status >= 200 && client.status < 300) {\n    let response;\n    try {\n      response = /** @type {!UTFGridJSON} */(JSON.parse(client.responseText));\n    } catch (err) {\n      this.handleError_();\n      return;\n    }\n    this.handleLoad_(response);\n  } else {\n    this.handleError_();\n  }\n};\n\n\n/**\n * @private\n * @param {Event} event The error event.\n */\nCustomTile.prototype.onXHRError_ = function(event) {\n  this.handleError_();\n};\n\n\n/**\n * @override\n */\nCustomTile.prototype.load = function() {\n  if (this.preemptive_) {\n    this.loadInternal_();\n  }\n};\n\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [preemptive=true]\n * If `true` the UTFGrid source loads the tiles based on their \"visibility\".\n * This improves the speed of response, but increases traffic.\n * Note that if set to `false`, you need to pass `true` as `opt_request`\n * to the `forDataAtCoordinateAndResolution` method otherwise no data\n * will ever be loaded.\n * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.\n * Useful when the server does not support CORS..\n * @property {tileJSON} [tileJSON] TileJSON configuration for this source.\n * If not provided, `url` must be configured.\n * @property {string} [url] TileJSON endpoint that provides the configuration for this source.\n * Request will be made through JSONP. If not provided, `tileJSON` must be configured.\n */\n\n\n/**\n * @classdesc\n * Layer source for UTFGrid interaction data loaded from TileJSON format.\n *\n * @constructor\n * @extends {module:ol/source/Tile}\n * @param {module:ol/source/UTFGrid~Options=} options Source options.\n * @api\n */\nconst UTFGrid = function(options) {\n  TileSource.call(this, {\n    projection: getProjection('EPSG:3857'),\n    state: SourceState.LOADING\n  });\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.preemptive_ = options.preemptive !== undefined ?\n    options.preemptive : true;\n\n  /**\n   * @private\n   * @type {!module:ol/Tile~UrlFunction}\n   */\n  this.tileUrlFunction_ = nullTileUrlFunction;\n\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n  this.template_ = undefined;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.jsonp_ = options.jsonp || false;\n\n  if (options.url) {\n    if (this.jsonp_) {\n      requestJSONP(options.url, this.handleTileJSONResponse.bind(this),\n        this.handleTileJSONError.bind(this));\n    } else {\n      const client = new XMLHttpRequest();\n      client.addEventListener('load', this.onXHRLoad_.bind(this));\n      client.addEventListener('error', this.onXHRError_.bind(this));\n      client.open('GET', options.url);\n      client.send();\n    }\n  } else if (options.tileJSON) {\n    this.handleTileJSONResponse(options.tileJSON);\n  } else {\n    assert(false, 51); // Either `url` or `tileJSON` options must be provided\n  }\n};\n\ninherits(UTFGrid, TileSource);\n\n\n/**\n * @private\n * @param {Event} event The load event.\n */\nUTFGrid.prototype.onXHRLoad_ = function(event) {\n  const client = /** @type {XMLHttpRequest} */ (event.target);\n  // status will be 0 for file:// urls\n  if (!client.status || client.status >= 200 && client.status < 300) {\n    let response;\n    try {\n      response = /** @type {TileJSON} */(JSON.parse(client.responseText));\n    } catch (err) {\n      this.handleTileJSONError();\n      return;\n    }\n    this.handleTileJSONResponse(response);\n  } else {\n    this.handleTileJSONError();\n  }\n};\n\n\n/**\n * @private\n * @param {Event} event The error event.\n */\nUTFGrid.prototype.onXHRError_ = function(event) {\n  this.handleTileJSONError();\n};\n\n\n/**\n * Return the template from TileJSON.\n * @return {string|undefined} The template from TileJSON.\n * @api\n */\nUTFGrid.prototype.getTemplate = function() {\n  return this.template_;\n};\n\n\n/**\n * Calls the callback (synchronously by default) with the available data\n * for given coordinate and resolution (or `null` if not yet loaded or\n * in case of an error).\n * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @param {function(*)} callback Callback.\n * @param {boolean=} opt_request If `true` the callback is always async.\n *                               The tile data is requested if not yet loaded.\n * @api\n */\nUTFGrid.prototype.forDataAtCoordinateAndResolution = function(\n  coordinate, resolution, callback, opt_request) {\n  if (this.tileGrid) {\n    const tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(\n      coordinate, resolution);\n    const tile = /** @type {!module:ol/source/UTFGrid~CustomTile} */(this.getTile(\n      tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection()));\n    tile.forDataAtCoordinate(coordinate, callback, null, opt_request);\n  } else {\n    if (opt_request === true) {\n      setTimeout(function() {\n        callback(null);\n      }, 0);\n    } else {\n      callback(null);\n    }\n  }\n};\n\n\n/**\n * @protected\n */\nUTFGrid.prototype.handleTileJSONError = function() {\n  this.setState(SourceState.ERROR);\n};\n\n\n/**\n * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse\n * @protected\n * @param {TileJSON} tileJSON Tile JSON.\n */\nUTFGrid.prototype.handleTileJSONResponse = function(tileJSON) {\n\n  const epsg4326Projection = getProjection('EPSG:4326');\n\n  const sourceProjection = this.getProjection();\n  let extent;\n  if (tileJSON.bounds !== undefined) {\n    const transform = getTransformFromProjections(\n      epsg4326Projection, sourceProjection);\n    extent = applyTransform(tileJSON.bounds, transform);\n  }\n\n  const minZoom = tileJSON.minzoom || 0;\n  const maxZoom = tileJSON.maxzoom || 22;\n  const tileGrid = createXYZ({\n    extent: extentFromProjection(sourceProjection),\n    maxZoom: maxZoom,\n    minZoom: minZoom\n  });\n  this.tileGrid = tileGrid;\n\n  this.template_ = tileJSON.template;\n\n  const grids = tileJSON.grids;\n  if (!grids) {\n    this.setState(SourceState.ERROR);\n    return;\n  }\n\n  this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);\n\n  if (tileJSON.attribution !== undefined) {\n    const attributionExtent = extent !== undefined ?\n      extent : epsg4326Projection.getExtent();\n\n    this.setAttributions(function(frameState) {\n      if (intersects(attributionExtent, frameState.extent)) {\n        return [tileJSON.attribution];\n      }\n      return null;\n    });\n  }\n\n  this.setState(SourceState.READY);\n\n};\n\n\n/**\n * @inheritDoc\n */\nUTFGrid.prototype.getTile = function(z, x, y, pixelRatio, projection) {\n  const tileCoordKey = getKeyZXY(z, x, y);\n  if (this.tileCache.containsKey(tileCoordKey)) {\n    return (\n      /** @type {!module:ol/Tile} */ (this.tileCache.get(tileCoordKey))\n    );\n  } else {\n    const tileCoord = [z, x, y];\n    const urlTileCoord =\n        this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    const tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);\n    const tile = new CustomTile(\n      tileCoord,\n      tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,\n      tileUrl !== undefined ? tileUrl : '',\n      this.tileGrid.getTileCoordExtent(tileCoord),\n      this.preemptive_,\n      this.jsonp_);\n    this.tileCache.set(tileCoordKey, tile);\n    return tile;\n  }\n};\n\n\n/**\n * @inheritDoc\n */\nUTFGrid.prototype.useTile = function(z, x, y) {\n  const tileCoordKey = getKeyZXY(z, x, y);\n  if (this.tileCache.containsKey(tileCoordKey)) {\n    this.tileCache.get(tileCoordKey);\n  }\n};\n\n\nexport default UTFGrid;\n","import Map from '../src/ol/Map.js';\nimport Overlay from '../src/ol/Overlay.js';\nimport View from '../src/ol/View.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport TileJSON from '../src/ol/source/TileJSON.js';\nimport UTFGrid from '../src/ol/source/UTFGrid.js';\n\nconst key = 'pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2pzbmg0Nmk5MGF5NzQzbzRnbDNoeHJrbiJ9.7_-_gL8ur7ZtEiNwRfCy7Q';\n\nconst mapLayer = new TileLayer({\n  source: new TileJSON({\n    url: 'https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=' + key\n  })\n});\n\n\nconst gridSource = new UTFGrid({\n  url: 'https://api.tiles.mapbox.com/v4/mapbox.geography-class.json?secure&access_token=' + key\n});\n\nconst gridLayer = new TileLayer({source: gridSource});\n\nconst view = new View({\n  center: [0, 0],\n  zoom: 1\n});\n\nconst mapElement = document.getElementById('map');\nconst map = new Map({\n  layers: [mapLayer, gridLayer],\n  target: mapElement,\n  view: view\n});\n\nconst infoElement = document.getElementById('country-info');\nconst flagElement = document.getElementById('country-flag');\nconst nameElement = document.getElementById('country-name');\n\nconst infoOverlay = new Overlay({\n  element: infoElement,\n  offset: [15, 15],\n  stopEvent: false\n});\nmap.addOverlay(infoOverlay);\n\nconst displayCountryInfo = function(coordinate) {\n  const viewResolution = /** @type {number} */ (view.getResolution());\n  gridSource.forDataAtCoordinateAndResolution(coordinate, viewResolution,\n    function(data) {\n      // If you want to use the template from the TileJSON,\n      //  load the mustache.js library separately and call\n      //  info.innerHTML = Mustache.render(gridSource.getTemplate(), data);\n      mapElement.style.cursor = data ? 'pointer' : '';\n      if (data) {\n        flagElement.src = 'data:image/png;base64,' + data['flag_png'];\n        nameElement.innerHTML = data['admin'];\n      }\n      infoOverlay.setPosition(data ? coordinate : undefined);\n    });\n};\n\nmap.on('pointermove', function(evt) {\n  if (evt.dragging) {\n    return;\n  }\n  const coordinate = map.getEventCoordinate(evt.originalEvent);\n  displayCountryInfo(coordinate);\n});\n\nmap.on('click', function(evt) {\n  displayCountryInfo(evt.coordinate);\n});\n"],"sourceRoot":""}