{"version":3,"sources":["webpack:///../src/ol/control/ZoomSlider.js","webpack:///./zoomslider.js"],"names":["Direction","ZoomSlider","opt_options","options","this","currentResolution_","undefined","direction_","dragging_","heightLimit_","widthLimit_","previousX_","previousY_","thumbSize_","sliderInitialized_","duration_","duration","className","thumbElement","document","createElement","setAttribute","css","containerElement","appendChild","dragger_","PointerEventHandler","Object","events","pointer_EventType","POINTERDOWN","handleDraggerStart_","POINTERMOVE","handleDraggerDrag_","POINTERUP","handleDraggerEnd_","EventType","CLICK","handleContainerClick_","Event","Control","call","element","render","mapEvent","frameState","initSlider_","res","viewState","resolution","setThumbPosition_","util","prototype","disposeInternal","dispose","setMap","map","container","containerSize","offsetWidth","offsetHeight","thumb","firstElementChild","computedStyle","getComputedStyle","thumbWidth","parseFloat","thumbHeight","event","view","getMap","getView","relativePosition","getRelativePosition_","offsetX","offsetY","getResolutionForPosition_","animate","constrainResolution","easing","originalEvent","target","setHint","ViewHint","INTERACTING","clientX","clientY","deltaX","parseInt","style","left","deltaY","top","setResolution","position","getPositionForResolution_","x","y","amount","math","getResolutionForValueFunction","fn","getValueForResolutionFunction","control_ZoomSlider","createMap","divId","source","OSM","layer","Tile","Map","layers","View","center","zoom","zoomslider","addControl"],"mappings":"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","file":"zoomslider.js","sourcesContent":["/**\n * @module ol/control/ZoomSlider\n */\nimport {inherits} from '../util.js';\nimport ViewHint from '../ViewHint.js';\nimport Control from '../control/Control.js';\nimport {CLASS_CONTROL, CLASS_UNSELECTABLE} from '../css.js';\nimport {easeOut} from '../easing.js';\nimport {listen} from '../events.js';\nimport {stopPropagation} from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {clamp} from '../math.js';\nimport PointerEventType from '../pointer/EventType.js';\nimport PointerEventHandler from '../pointer/PointerEventHandler.js';\n\n\n/**\n * The enum for available directions.\n *\n * @enum {number}\n */\nconst Direction = {\n  VERTICAL: 0,\n  HORIZONTAL: 1\n};\n\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-zoomslider'] CSS class name.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {function(module:ol/MapEvent)} [render] Function called when the control\n * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n */\n\n\n/**\n * @classdesc\n * A slider type of control for zooming.\n *\n * Example:\n *\n *     map.addControl(new ZoomSlider());\n *\n * @constructor\n * @extends {module:ol/control/Control}\n * @param {module:ol/control/ZoomSlider~Options=} opt_options Zoom slider options.\n * @api\n */\nconst ZoomSlider = function(opt_options) {\n\n  const options = opt_options ? opt_options : {};\n\n  /**\n   * Will hold the current resolution of the view.\n   *\n   * @type {number|undefined}\n   * @private\n   */\n  this.currentResolution_ = undefined;\n\n  /**\n   * The direction of the slider. Will be determined from actual display of the\n   * container and defaults to Direction.VERTICAL.\n   *\n   * @type {Direction}\n   * @private\n   */\n  this.direction_ = Direction.VERTICAL;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.dragging_;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.heightLimit_ = 0;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.widthLimit_ = 0;\n\n  /**\n   * @type {number|undefined}\n   * @private\n   */\n  this.previousX_;\n\n  /**\n   * @type {number|undefined}\n   * @private\n   */\n  this.previousY_;\n\n  /**\n   * The calculated thumb size (border box plus margins).  Set when initSlider_\n   * is called.\n   * @type {module:ol/size~Size}\n   * @private\n   */\n  this.thumbSize_ = null;\n\n  /**\n   * Whether the slider is initialized.\n   * @type {boolean}\n   * @private\n   */\n  this.sliderInitialized_ = false;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n  const className = options.className !== undefined ? options.className : 'ol-zoomslider';\n  const thumbElement = document.createElement('button');\n  thumbElement.setAttribute('type', 'button');\n  thumbElement.className = className + '-thumb ' + CLASS_UNSELECTABLE;\n  const containerElement = document.createElement('div');\n  containerElement.className = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n  containerElement.appendChild(thumbElement);\n  /**\n   * @type {module:ol/pointer/PointerEventHandler}\n   * @private\n   */\n  this.dragger_ = new PointerEventHandler(containerElement);\n\n  listen(this.dragger_, PointerEventType.POINTERDOWN,\n    this.handleDraggerStart_, this);\n  listen(this.dragger_, PointerEventType.POINTERMOVE,\n    this.handleDraggerDrag_, this);\n  listen(this.dragger_, PointerEventType.POINTERUP,\n    this.handleDraggerEnd_, this);\n\n  listen(containerElement, EventType.CLICK, this.handleContainerClick_, this);\n  listen(thumbElement, EventType.CLICK, stopPropagation);\n\n  Control.call(this, {\n    element: containerElement,\n    render: options.render || render\n  });\n};\n\ninherits(ZoomSlider, Control);\n\n\n/**\n * @inheritDoc\n */\nZoomSlider.prototype.disposeInternal = function() {\n  this.dragger_.dispose();\n  Control.prototype.disposeInternal.call(this);\n};\n\n\n/**\n * @inheritDoc\n */\nZoomSlider.prototype.setMap = function(map) {\n  Control.prototype.setMap.call(this, map);\n  if (map) {\n    map.render();\n  }\n};\n\n\n/**\n * Initializes the slider element. This will determine and set this controls\n * direction_ and also constrain the dragging of the thumb to always be within\n * the bounds of the container.\n *\n * @private\n */\nZoomSlider.prototype.initSlider_ = function() {\n  const container = this.element;\n  const containerSize = {\n    width: container.offsetWidth, height: container.offsetHeight\n  };\n\n  const thumb = container.firstElementChild;\n  const computedStyle = getComputedStyle(thumb);\n  const thumbWidth = thumb.offsetWidth +\n      parseFloat(computedStyle['marginRight']) +\n      parseFloat(computedStyle['marginLeft']);\n  const thumbHeight = thumb.offsetHeight +\n      parseFloat(computedStyle['marginTop']) +\n      parseFloat(computedStyle['marginBottom']);\n  this.thumbSize_ = [thumbWidth, thumbHeight];\n\n  if (containerSize.width > containerSize.height) {\n    this.direction_ = Direction.HORIZONTAL;\n    this.widthLimit_ = containerSize.width - thumbWidth;\n  } else {\n    this.direction_ = Direction.VERTICAL;\n    this.heightLimit_ = containerSize.height - thumbHeight;\n  }\n  this.sliderInitialized_ = true;\n};\n\n\n/**\n * Update the zoomslider element.\n * @param {module:ol/MapEvent} mapEvent Map event.\n * @this {module:ol/control/ZoomSlider}\n * @api\n */\nexport function render(mapEvent) {\n  if (!mapEvent.frameState) {\n    return;\n  }\n  if (!this.sliderInitialized_) {\n    this.initSlider_();\n  }\n  const res = mapEvent.frameState.viewState.resolution;\n  if (res !== this.currentResolution_) {\n    this.currentResolution_ = res;\n    this.setThumbPosition_(res);\n  }\n}\n\n\n/**\n * @param {Event} event The browser event to handle.\n * @private\n */\nZoomSlider.prototype.handleContainerClick_ = function(event) {\n  const view = this.getMap().getView();\n\n  const relativePosition = this.getRelativePosition_(\n    event.offsetX - this.thumbSize_[0] / 2,\n    event.offsetY - this.thumbSize_[1] / 2);\n\n  const resolution = this.getResolutionForPosition_(relativePosition);\n\n  view.animate({\n    resolution: view.constrainResolution(resolution),\n    duration: this.duration_,\n    easing: easeOut\n  });\n};\n\n\n/**\n * Handle dragger start events.\n * @param {module:ol/pointer/PointerEvent} event The drag event.\n * @private\n */\nZoomSlider.prototype.handleDraggerStart_ = function(event) {\n  if (!this.dragging_ && event.originalEvent.target === this.element.firstElementChild) {\n    this.getMap().getView().setHint(ViewHint.INTERACTING, 1);\n    this.previousX_ = event.clientX;\n    this.previousY_ = event.clientY;\n    this.dragging_ = true;\n  }\n};\n\n\n/**\n * Handle dragger drag events.\n *\n * @param {module:ol/pointer/PointerEvent|Event} event The drag event.\n * @private\n */\nZoomSlider.prototype.handleDraggerDrag_ = function(event) {\n  if (this.dragging_) {\n    const element = this.element.firstElementChild;\n    const deltaX = event.clientX - this.previousX_ + parseInt(element.style.left, 10);\n    const deltaY = event.clientY - this.previousY_ + parseInt(element.style.top, 10);\n    const relativePosition = this.getRelativePosition_(deltaX, deltaY);\n    this.currentResolution_ = this.getResolutionForPosition_(relativePosition);\n    this.getMap().getView().setResolution(this.currentResolution_);\n    this.setThumbPosition_(this.currentResolution_);\n    this.previousX_ = event.clientX;\n    this.previousY_ = event.clientY;\n  }\n};\n\n\n/**\n * Handle dragger end events.\n * @param {module:ol/pointer/PointerEvent|Event} event The drag event.\n * @private\n */\nZoomSlider.prototype.handleDraggerEnd_ = function(event) {\n  if (this.dragging_) {\n    const view = this.getMap().getView();\n    view.setHint(ViewHint.INTERACTING, -1);\n\n    view.animate({\n      resolution: view.constrainResolution(this.currentResolution_),\n      duration: this.duration_,\n      easing: easeOut\n    });\n\n    this.dragging_ = false;\n    this.previousX_ = undefined;\n    this.previousY_ = undefined;\n  }\n};\n\n\n/**\n * Positions the thumb inside its container according to the given resolution.\n *\n * @param {number} res The res.\n * @private\n */\nZoomSlider.prototype.setThumbPosition_ = function(res) {\n  const position = this.getPositionForResolution_(res);\n  const thumb = this.element.firstElementChild;\n\n  if (this.direction_ == Direction.HORIZONTAL) {\n    thumb.style.left = this.widthLimit_ * position + 'px';\n  } else {\n    thumb.style.top = this.heightLimit_ * position + 'px';\n  }\n};\n\n\n/**\n * Calculates the relative position of the thumb given x and y offsets.  The\n * relative position scales from 0 to 1.  The x and y offsets are assumed to be\n * in pixel units within the dragger limits.\n *\n * @param {number} x Pixel position relative to the left of the slider.\n * @param {number} y Pixel position relative to the top of the slider.\n * @return {number} The relative position of the thumb.\n * @private\n */\nZoomSlider.prototype.getRelativePosition_ = function(x, y) {\n  let amount;\n  if (this.direction_ === Direction.HORIZONTAL) {\n    amount = x / this.widthLimit_;\n  } else {\n    amount = y / this.heightLimit_;\n  }\n  return clamp(amount, 0, 1);\n};\n\n\n/**\n * Calculates the corresponding resolution of the thumb given its relative\n * position (where 0 is the minimum and 1 is the maximum).\n *\n * @param {number} position The relative position of the thumb.\n * @return {number} The corresponding resolution.\n * @private\n */\nZoomSlider.prototype.getResolutionForPosition_ = function(position) {\n  const fn = this.getMap().getView().getResolutionForValueFunction();\n  return fn(1 - position);\n};\n\n\n/**\n * Determines the relative position of the slider for the given resolution.  A\n * relative position of 0 corresponds to the minimum view resolution.  A\n * relative position of 1 corresponds to the maximum view resolution.\n *\n * @param {number} res The resolution.\n * @return {number} The relative position value (between 0 and 1).\n * @private\n */\nZoomSlider.prototype.getPositionForResolution_ = function(res) {\n  const fn = this.getMap().getView().getValueForResolutionFunction();\n  return 1 - fn(res);\n};\n\nexport default ZoomSlider;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {ZoomSlider} from '../src/ol/control.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport OSM from '../src/ol/source/OSM.js';\n\n\n/**\n * Helper method for map-creation.\n *\n * @param {string} divId The id of the div for the map.\n * @return {module:ol/PluggableMap} The map instance.\n */\nfunction createMap(divId) {\n  const source = new OSM();\n  const layer = new TileLayer({\n    source: source\n  });\n  const map = new Map({\n    layers: [layer],\n    target: divId,\n    view: new View({\n      center: [0, 0],\n      zoom: 2\n    })\n  });\n  const zoomslider = new ZoomSlider();\n  map.addControl(zoomslider);\n  return map;\n}\n\nconst map1 = createMap('map1');\nconst map2 = createMap('map2');\nconst map3 = createMap('map3');\n"],"sourceRoot":""}