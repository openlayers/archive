{"version":3,"sources":["webpack:///../src/ol/source/ImageCanvas.js","webpack:///./d3.js"],"names":["ImageCanvasSource","options","source_Image","call","this","attributions","projection","resolutions","state","canvasFunction_","canvasFunction","canvas_","renderedRevision_","ratio_","undefined","ratio","Object","util","prototype","getImageInternal","extent","resolution","pixelRatio","findNearestResolution","canvas","getRevision","getResolution","getPixelRatio","ol_extent","getExtent","slice","size","canvasElement","ImageCanvas","source_ImageCanvas","map","Map","layers","Tile","source","Stamen","layer","target","view","View","center","proj","zoom","d3","json","error","us","features","topojson","feature","objects","counties","Image","canvasWidth","canvasHeight","select","document","createElement","attr","context","node","getContext","d3Projection","geoMercator","scale","translate","d3Path","geoPath","pixelBounds","bounds","pixelBoundsWidth","pixelBoundsHeight","geoBounds","geoBoundsLeftBottom","geoBoundsRightTop","geoBoundsWidth","widthResolution","heightResolution","Math","max","stroke","addLayer"],"mappings":"kLAqDA,MAAAA,EAAA,SAAAC,GAEAC,EAAA,EAAAC,KAAAC,MACAC,aAAAJ,EAAAI,aACAC,WAAAL,EAAAK,WACAC,YAAAN,EAAAM,YACAC,MAAAP,EAAAO,QAOAJ,KAAAK,gBAAAR,EAAAS,eAMAN,KAAAO,QAAA,KAMAP,KAAAQ,kBAAA,EAMAR,KAAAS,YAAAC,IAAAb,EAAAc,MACAd,EAAAc,MAAA,KAIAC,OAAAC,EAAA,EAAAD,CAAAhB,EAAAE,EAAA,GAMAF,EAAAkB,UAAAC,iBAAA,SAAAC,EAAAC,EAAAC,EAAAhB,GACAe,EAAAjB,KAAAmB,sBAAAF,GAEA,IAAAG,EAAApB,KAAAO,QACA,GAAAa,GACApB,KAAAQ,mBAAAR,KAAAqB,eACAD,EAAAE,iBAAAL,GACAG,EAAAG,iBAAAL,GACAN,OAAAY,EAAA,EAAAZ,CAAAQ,EAAAK,YAAAT,GACA,OAAAI,EAGAJ,IAAAU,QACAd,OAAAY,EAAA,EAAAZ,CAAAI,EAAAhB,KAAAS,QACA,MAEAkB,GAFAf,OAAAY,EAAA,EAAAZ,CAAAI,GAAAC,EAEAC,EADAN,OAAAY,EAAA,EAAAZ,CAAAI,GAAAC,EACAC,GAEAU,EAAA5B,KAAAK,gBACAW,EAAAC,EAAAC,EAAAS,EAAAzB,GAOA,OANA0B,IACAR,EAAA,IAAAS,EAAA,EAAAb,EAAAC,EAAAC,EAAAU,IAEA5B,KAAAO,QAAAa,EACApB,KAAAQ,kBAAAR,KAAAqB,cAEAD,GAEA,IAAAU,EAAA,ECnHA,MAAAC,EAAA,IAAAC,EAAA,GACAC,QACA,IAAAC,EAAA,GACAC,OAAA,IAAAC,EAAA,GACAC,MAAA,kBAIAC,OAAA,MACAC,KAAA,IAAAC,EAAA,GACAC,OAAA7B,OAAA8B,EAAA,EAAA9B,GAAA,QACA+B,KAAA,MAQAC,GAAAC,KAAA,iCAAAC,EAAAC,GACA,MAAAC,EAAAC,SAAAC,QAAAH,IAAAI,QAAAC,UAmDAf,EAAA,IAAAgB,EAAA,GACAlB,OAAA,IAAAL,GACAxB,eA1CA,SAAAU,EAAAC,EAAAC,EAAAS,EAAAzB,GACA,MAAAoD,EAAA3B,EAAA,GACA4B,EAAA5B,EAAA,GAEAP,EAAAwB,GAAAY,OAAAC,SAAAC,cAAA,WACAtC,EAAAuC,KAAA,QAAAL,GAAAK,KAAA,SAAAJ,GAEA,MAAAK,EAAAxC,EAAAyC,OAAAC,WAAA,MAEAC,EAAAnB,GAAAoB,cAAAC,MAAA,GAAAC,WAAA,MACA,IAAAC,EAAAvB,GAAAwB,UAAAlE,WAAA6D,GAEA,MAAAM,EAAAF,EAAAG,OAAAtB,GACAuB,EAAAF,EAAA,MAAAA,EAAA,MACAG,EAAAH,EAAA,MAAAA,EAAA,MAEAI,EAAA7B,GAAA6B,UAAAzB,GACA0B,EAAA9D,OAAA8B,EAAA,EAAA9B,CAAA6D,EAAA,GAAAvE,GACAyE,EAAA/D,OAAA8B,EAAA,EAAA9B,CAAA6D,EAAA,GAAAvE,GACA,IAAA0E,EAAAD,EAAA,GAAAD,EAAA,GACAE,EAAA,IACAA,GAAAhE,OAAAY,EAAA,EAAAZ,CAAAV,EAAAuB,cAEA,MAEAoD,EAAAD,EAAAL,EACAO,GAHAH,EAAA,GAAAD,EAAA,IAGAF,EAEAP,EADAc,KAAAC,IAAAH,EAAAC,IACA7D,EAAAC,GAEAuB,EAAA7B,OAAA8B,EAAA,EAAA9B,QAAAY,EAAA,EAAAZ,CAAAI,GAAAd,GAOA,OANA6D,EAAAE,SAAAxB,UACAyB,WAAAZ,EAAA,EAAAC,EAAA,KACAY,IAAAjE,WAAA6D,GAAAH,YACAZ,GACAY,EAAAqB,SAEA7D,EAAAyC,QAMA3D,WAAA,gBAGA6B,EAAAmD,SAAA7C","file":"d3.js","sourcesContent":["/**\n * @module ol/source/ImageCanvas\n */\nimport {inherits} from '../util.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport {containsExtent, getHeight, getWidth, scaleFromCenter} from '../extent.js';\nimport ImageSource from '../source/Image.js';\n\n\n/**\n * A function returning the canvas element (`{HTMLCanvasElement}`)\n * used by the source as an image. The arguments passed to the function are:\n * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,\n * `{number}` the device pixel ratio, {@link module:ol/size~Size} the image size, and\n * {@link module:ol/proj/Projection} the image projection. The canvas returned by\n * this function is cached by the source. The this keyword inside the function\n * references the {@link module:ol/source/ImageCanvas}.\n *\n * @typedef {function(this:module:ol/ImageCanvas, module:ol/extent~Extent, number,\n *     number, module:ol/size~Size, module:ol/proj/Projection): HTMLCanvasElement} FunctionType\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\n * @property {module:ol/source/ImageCanvas~FunctionType} [canvasFunction] Canvas function.\n * The function returning the canvas element used by the source\n * as an image. The arguments passed to the function are: `{module:ol/extent~Extent}` the\n * image extent, `{number}` the image resolution, `{number}` the device pixel\n * ratio, `{module:ol/size~Size}` the image size, and `{module:ol/proj/Projection~Projection}` the image\n * projection. The canvas returned by this function is cached by the source. If\n * the value returned by the function is later changed then\n * `changed` should be called on the source for the source to\n * invalidate the current cached image. See @link: {@link module:ol/Observable~Observable#changed}\n * @property {module:ol/proj~ProjectionLike} projection Projection.\n * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the\n * width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Array.<number>} [resolutions] Resolutions.\n * If specified, new canvases will be created for these resolutions\n * @property {module:ol/source/State} [state] Source state.\n */\n\n\n/**\n * @classdesc\n * Base class for image sources where a canvas element is the image.\n *\n * @constructor\n * @extends {module:ol/source/Image}\n * @param {module:ol/source/ImageCanvas~Options=} options ImageCanvas options.\n * @api\n */\nconst ImageCanvasSource = function(options) {\n\n  ImageSource.call(this, {\n    attributions: options.attributions,\n    projection: options.projection,\n    resolutions: options.resolutions,\n    state: options.state\n  });\n\n  /**\n   * @private\n   * @type {module:ol/source/ImageCanvas~FunctionType}\n   */\n  this.canvasFunction_ = options.canvasFunction;\n\n  /**\n   * @private\n   * @type {module:ol/ImageCanvas}\n   */\n  this.canvas_ = null;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.renderedRevision_ = 0;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.ratio_ = options.ratio !== undefined ?\n    options.ratio : 1.5;\n\n};\n\ninherits(ImageCanvasSource, ImageSource);\n\n\n/**\n * @inheritDoc\n */\nImageCanvasSource.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {\n  resolution = this.findNearestResolution(resolution);\n\n  let canvas = this.canvas_;\n  if (canvas &&\n      this.renderedRevision_ == this.getRevision() &&\n      canvas.getResolution() == resolution &&\n      canvas.getPixelRatio() == pixelRatio &&\n      containsExtent(canvas.getExtent(), extent)) {\n    return canvas;\n  }\n\n  extent = extent.slice();\n  scaleFromCenter(extent, this.ratio_);\n  const width = getWidth(extent) / resolution;\n  const height = getHeight(extent) / resolution;\n  const size = [width * pixelRatio, height * pixelRatio];\n\n  const canvasElement = this.canvasFunction_(\n    extent, resolution, pixelRatio, size, projection);\n  if (canvasElement) {\n    canvas = new ImageCanvas(extent, resolution, pixelRatio, canvasElement);\n  }\n  this.canvas_ = canvas;\n  this.renderedRevision_ = this.getRevision();\n\n  return canvas;\n};\nexport default ImageCanvasSource;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {getWidth, getCenter} from '../src/ol/extent.js';\nimport {Image as ImageLayer, Tile as TileLayer} from '../src/ol/layer.js';\nimport {fromLonLat, toLonLat} from '../src/ol/proj.js';\nimport {ImageCanvas as ImageCanvasSource, Stamen} from '../src/ol/source.js';\n\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new Stamen({\n        layer: 'watercolor'\n      })\n    })\n  ],\n  target: 'map',\n  view: new View({\n    center: fromLonLat([-97, 38]),\n    zoom: 4\n  })\n});\n\n\n/**\n * Load the topojson data and create an ol/layer/Image for that data.\n */\nd3.json('data/topojson/us.json', function(error, us) {\n  const features = topojson.feature(us, us.objects.counties);\n\n  /**\n   * This function uses d3 to render the topojson features to a canvas.\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {module:ol/size~Size} size Size.\n   * @param {module:ol/proj/Projection~Projection} projection Projection.\n   * @return {HTMLCanvasElement} A canvas element.\n   */\n  const canvasFunction = function(extent, resolution, pixelRatio, size, projection) {\n    const canvasWidth = size[0];\n    const canvasHeight = size[1];\n\n    const canvas = d3.select(document.createElement('canvas'));\n    canvas.attr('width', canvasWidth).attr('height', canvasHeight);\n\n    const context = canvas.node().getContext('2d');\n\n    const d3Projection = d3.geoMercator().scale(1).translate([0, 0]);\n    let d3Path = d3.geoPath().projection(d3Projection);\n\n    const pixelBounds = d3Path.bounds(features);\n    const pixelBoundsWidth = pixelBounds[1][0] - pixelBounds[0][0];\n    const pixelBoundsHeight = pixelBounds[1][1] - pixelBounds[0][1];\n\n    const geoBounds = d3.geoBounds(features);\n    const geoBoundsLeftBottom = fromLonLat(geoBounds[0], projection);\n    const geoBoundsRightTop = fromLonLat(geoBounds[1], projection);\n    let geoBoundsWidth = geoBoundsRightTop[0] - geoBoundsLeftBottom[0];\n    if (geoBoundsWidth < 0) {\n      geoBoundsWidth += getWidth(projection.getExtent());\n    }\n    const geoBoundsHeight = geoBoundsRightTop[1] - geoBoundsLeftBottom[1];\n\n    const widthResolution = geoBoundsWidth / pixelBoundsWidth;\n    const heightResolution = geoBoundsHeight / pixelBoundsHeight;\n    const r = Math.max(widthResolution, heightResolution);\n    const scale = r / (resolution / pixelRatio);\n\n    const center = toLonLat(getCenter(extent), projection);\n    d3Projection.scale(scale).center(center)\n      .translate([canvasWidth / 2, canvasHeight / 2]);\n    d3Path = d3Path.projection(d3Projection).context(context);\n    d3Path(features);\n    context.stroke();\n\n    return canvas.node();\n  };\n\n  const layer = new ImageLayer({\n    source: new ImageCanvasSource({\n      canvasFunction: canvasFunction,\n      projection: 'EPSG:3857'\n    })\n  });\n  map.addLayer(layer);\n});\n"],"sourceRoot":""}