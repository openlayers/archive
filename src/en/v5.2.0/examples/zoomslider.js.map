{"version":3,"sources":["webpack:///../src/ol/control/ZoomSlider.js","webpack:///./zoomslider.js"],"names":["Direction","VERTICAL","HORIZONTAL","render","mapEvent","frameState","this","sliderInitialized_","initSlider_","const","res","viewState","resolution","currentResolution_","setThumbPosition_","control_ZoomSlider","Control","ZoomSlider","opt_options","options","super","element","document","createElement","undefined","direction_","dragging_","heightLimit_","widthLimit_","previousX_","previousY_","thumbSize_","duration_","duration","className","thumbElement","setAttribute","css","containerElement","appendChild","dragger_","PointerEventHandler","Object","events","pointer_EventType","POINTERDOWN","handleDraggerStart_","POINTERMOVE","handleDraggerDrag_","POINTERUP","handleDraggerEnd_","EventType","CLICK","handleContainerClick_","Event","disposeInternal","dispose","call","setMap","map","container","containerSize","offsetWidth","offsetHeight","thumb","computedStyle","getComputedStyle","thumbWidth","parseFloat","thumbHeight","event","view","getMap","getView","relativePosition","getRelativePosition_","offsetX","offsetY","getResolutionForPosition_","animate","constrainResolution","easing","originalEvent","target","firstElementChild","setHint","ViewHint","INTERACTING","clientX","clientY","deltaX","parseInt","style","left","deltaY","top","setResolution","position","getPositionForResolution_","x","y","let","amount","math","getResolutionForValueFunction","fn","getValueForResolutionFunction","control_Control","createMap","divId","source","OSM","layer","Tile","Map","layers","View","center","zoom","zoomslider","addControl"],"mappings":"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","file":"zoomslider.js","sourcesContent":["/**\n * @module ol/control/ZoomSlider\n */\nimport ViewHint from '../ViewHint.js';\nimport Control from '../control/Control.js';\nimport {CLASS_CONTROL, CLASS_UNSELECTABLE} from '../css.js';\nimport {easeOut} from '../easing.js';\nimport {listen} from '../events.js';\nimport {stopPropagation} from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {clamp} from '../math.js';\nimport PointerEventType from '../pointer/EventType.js';\nimport PointerEventHandler from '../pointer/PointerEventHandler.js';\n\n\n/**\n * The enum for available directions.\n *\n * @enum {number}\n */\nconst Direction = {\n  VERTICAL: 0,\n  HORIZONTAL: 1\n};\n\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-zoomslider'] CSS class name.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {function(module:ol/MapEvent)} [render] Function called when the control\n * should be re-rendered. This is called in a `requestAnimationFrame` callback.\n */\n\n\n/**\n * @classdesc\n * A slider type of control for zooming.\n *\n * Example:\n *\n *     map.addControl(new ZoomSlider());\n *\n * @api\n */\nclass ZoomSlider extends Control {\n\n  /**\n   * @param {module:ol/control/ZoomSlider~Options=} opt_options Zoom slider options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options ? opt_options : {};\n\n    super({\n      element: document.createElement('div'),\n      render: options.render || render\n    });\n\n    /**\n     * Will hold the current resolution of the view.\n     *\n     * @type {number|undefined}\n     * @private\n     */\n    this.currentResolution_ = undefined;\n\n    /**\n     * The direction of the slider. Will be determined from actual display of the\n     * container and defaults to Direction.VERTICAL.\n     *\n     * @type {Direction}\n     * @private\n     */\n    this.direction_ = Direction.VERTICAL;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.heightLimit_ = 0;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.widthLimit_ = 0;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.previousX_;\n\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    this.previousY_;\n\n    /**\n     * The calculated thumb size (border box plus margins).  Set when initSlider_\n     * is called.\n     * @type {module:ol/size~Size}\n     * @private\n     */\n    this.thumbSize_ = null;\n\n    /**\n     * Whether the slider is initialized.\n     * @type {boolean}\n     * @private\n     */\n    this.sliderInitialized_ = false;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    const className = options.className !== undefined ? options.className : 'ol-zoomslider';\n    const thumbElement = document.createElement('button');\n    thumbElement.setAttribute('type', 'button');\n    thumbElement.className = className + '-thumb ' + CLASS_UNSELECTABLE;\n    const containerElement = this.element;\n    containerElement.className = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;\n    containerElement.appendChild(thumbElement);\n    /**\n     * @type {module:ol/pointer/PointerEventHandler}\n     * @private\n     */\n    this.dragger_ = new PointerEventHandler(containerElement);\n\n    listen(this.dragger_, PointerEventType.POINTERDOWN,\n      this.handleDraggerStart_, this);\n    listen(this.dragger_, PointerEventType.POINTERMOVE,\n      this.handleDraggerDrag_, this);\n    listen(this.dragger_, PointerEventType.POINTERUP,\n      this.handleDraggerEnd_, this);\n\n    listen(containerElement, EventType.CLICK, this.handleContainerClick_, this);\n    listen(thumbElement, EventType.CLICK, stopPropagation);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    this.dragger_.dispose();\n    super.disposeInternal();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMap(map) {\n    super.setMap(map);\n    if (map) {\n      map.render();\n    }\n  }\n\n  /**\n   * Initializes the slider element. This will determine and set this controls\n   * direction_ and also constrain the dragging of the thumb to always be within\n   * the bounds of the container.\n   *\n   * @private\n   */\n  initSlider_() {\n    const container = this.element;\n    const containerSize = {\n      width: container.offsetWidth, height: container.offsetHeight\n    };\n\n    const thumb = /** @type {HTMLElement} */ (container.firstElementChild);\n    const computedStyle = getComputedStyle(thumb);\n    const thumbWidth = thumb.offsetWidth +\n        parseFloat(computedStyle['marginRight']) +\n        parseFloat(computedStyle['marginLeft']);\n    const thumbHeight = thumb.offsetHeight +\n        parseFloat(computedStyle['marginTop']) +\n        parseFloat(computedStyle['marginBottom']);\n    this.thumbSize_ = [thumbWidth, thumbHeight];\n\n    if (containerSize.width > containerSize.height) {\n      this.direction_ = Direction.HORIZONTAL;\n      this.widthLimit_ = containerSize.width - thumbWidth;\n    } else {\n      this.direction_ = Direction.VERTICAL;\n      this.heightLimit_ = containerSize.height - thumbHeight;\n    }\n    this.sliderInitialized_ = true;\n  }\n\n  /**\n   * @param {MouseEvent} event The browser event to handle.\n   * @private\n   */\n  handleContainerClick_(event) {\n    const view = this.getMap().getView();\n\n    const relativePosition = this.getRelativePosition_(\n      event.offsetX - this.thumbSize_[0] / 2,\n      event.offsetY - this.thumbSize_[1] / 2);\n\n    const resolution = this.getResolutionForPosition_(relativePosition);\n\n    view.animate({\n      resolution: view.constrainResolution(resolution),\n      duration: this.duration_,\n      easing: easeOut\n    });\n  }\n\n  /**\n   * Handle dragger start events.\n   * @param {module:ol/pointer/PointerEvent} event The drag event.\n   * @private\n   */\n  handleDraggerStart_(event) {\n    if (!this.dragging_ && event.originalEvent.target === this.element.firstElementChild) {\n      this.getMap().getView().setHint(ViewHint.INTERACTING, 1);\n      this.previousX_ = event.clientX;\n      this.previousY_ = event.clientY;\n      this.dragging_ = true;\n    }\n  }\n\n  /**\n   * Handle dragger drag events.\n   *\n   * @param {module:ol/pointer/PointerEvent|Event} event The drag event.\n   * @private\n   */\n  handleDraggerDrag_(event) {\n    if (this.dragging_) {\n      const element = /** @type {HTMLElement} */ (this.element.firstElementChild);\n      const deltaX = event.clientX - this.previousX_ + parseInt(element.style.left, 10);\n      const deltaY = event.clientY - this.previousY_ + parseInt(element.style.top, 10);\n      const relativePosition = this.getRelativePosition_(deltaX, deltaY);\n      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);\n      this.getMap().getView().setResolution(this.currentResolution_);\n      this.setThumbPosition_(this.currentResolution_);\n      this.previousX_ = event.clientX;\n      this.previousY_ = event.clientY;\n    }\n  }\n\n  /**\n   * Handle dragger end events.\n   * @param {module:ol/pointer/PointerEvent|Event} event The drag event.\n   * @private\n   */\n  handleDraggerEnd_(event) {\n    if (this.dragging_) {\n      const view = this.getMap().getView();\n      view.setHint(ViewHint.INTERACTING, -1);\n\n      view.animate({\n        resolution: view.constrainResolution(this.currentResolution_),\n        duration: this.duration_,\n        easing: easeOut\n      });\n\n      this.dragging_ = false;\n      this.previousX_ = undefined;\n      this.previousY_ = undefined;\n    }\n  }\n\n  /**\n   * Positions the thumb inside its container according to the given resolution.\n   *\n   * @param {number} res The res.\n   * @private\n   */\n  setThumbPosition_(res) {\n    const position = this.getPositionForResolution_(res);\n    const thumb = /** @type {HTMLElement} */ (this.element.firstElementChild);\n\n    if (this.direction_ == Direction.HORIZONTAL) {\n      thumb.style.left = this.widthLimit_ * position + 'px';\n    } else {\n      thumb.style.top = this.heightLimit_ * position + 'px';\n    }\n  }\n\n  /**\n   * Calculates the relative position of the thumb given x and y offsets.  The\n   * relative position scales from 0 to 1.  The x and y offsets are assumed to be\n   * in pixel units within the dragger limits.\n   *\n   * @param {number} x Pixel position relative to the left of the slider.\n   * @param {number} y Pixel position relative to the top of the slider.\n   * @return {number} The relative position of the thumb.\n   * @private\n   */\n  getRelativePosition_(x, y) {\n    let amount;\n    if (this.direction_ === Direction.HORIZONTAL) {\n      amount = x / this.widthLimit_;\n    } else {\n      amount = y / this.heightLimit_;\n    }\n    return clamp(amount, 0, 1);\n  }\n\n  /**\n   * Calculates the corresponding resolution of the thumb given its relative\n   * position (where 0 is the minimum and 1 is the maximum).\n   *\n   * @param {number} position The relative position of the thumb.\n   * @return {number} The corresponding resolution.\n   * @private\n   */\n  getResolutionForPosition_(position) {\n    const fn = this.getMap().getView().getResolutionForValueFunction();\n    return fn(1 - position);\n  }\n\n  /**\n   * Determines the relative position of the slider for the given resolution.  A\n   * relative position of 0 corresponds to the minimum view resolution.  A\n   * relative position of 1 corresponds to the maximum view resolution.\n   *\n   * @param {number} res The resolution.\n   * @return {number} The relative position value (between 0 and 1).\n   * @private\n   */\n  getPositionForResolution_(res) {\n    const fn = this.getMap().getView().getValueForResolutionFunction();\n    return 1 - fn(res);\n  }\n}\n\n\n/**\n * Update the zoomslider element.\n * @param {module:ol/MapEvent} mapEvent Map event.\n * @this {module:ol/control/ZoomSlider}\n * @api\n */\nexport function render(mapEvent) {\n  if (!mapEvent.frameState) {\n    return;\n  }\n  if (!this.sliderInitialized_) {\n    this.initSlider_();\n  }\n  const res = mapEvent.frameState.viewState.resolution;\n  if (res !== this.currentResolution_) {\n    this.currentResolution_ = res;\n    this.setThumbPosition_(res);\n  }\n}\n\n\nexport default ZoomSlider;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {ZoomSlider} from '../src/ol/control.js';\nimport TileLayer from '../src/ol/layer/Tile.js';\nimport OSM from '../src/ol/source/OSM.js';\n\n\n/**\n * Helper method for map-creation.\n *\n * @param {string} divId The id of the div for the map.\n * @return {module:ol/PluggableMap} The map instance.\n */\nfunction createMap(divId) {\n  const source = new OSM();\n  const layer = new TileLayer({\n    source: source\n  });\n  const map = new Map({\n    layers: [layer],\n    target: divId,\n    view: new View({\n      center: [0, 0],\n      zoom: 2\n    })\n  });\n  const zoomslider = new ZoomSlider();\n  map.addControl(zoomslider);\n  return map;\n}\n\nconst map1 = createMap('map1');\nconst map2 = createMap('map2');\nconst map3 = createMap('map3');\n"],"sourceRoot":""}