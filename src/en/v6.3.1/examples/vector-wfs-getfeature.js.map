{"version":3,"sources":["webpack:///../src/ol/format/filter/Filter.js","webpack:///../src/ol/format/filter/LogicalNary.js","webpack:///../src/ol/format/filter/And.js","webpack:///../src/ol/format/filter/Bbox.js","webpack:///../src/ol/format/filter/Comparison.js","webpack:///../src/ol/format/filter/ComparisonBinary.js","webpack:///../src/ol/format/filter/EqualTo.js","webpack:///../src/ol/format/filter/IsLike.js","webpack:///../src/ol/format/filter.js","webpack:///../src/ol/format/GML3.js","webpack:///../src/ol/format/WFS.js","webpack:///./vector-wfs-getfeature.js"],"names":["tagName","this","tagName_","getTagName","conditions","super","length","Array","prototype","slice","call","arguments","geometryName","extent","opt_srsName","Error","srsName","propertyName","expression","opt_matchCase","matchCase","pattern","opt_wildCard","opt_singleChar","opt_escapeChar","wildCard","undefined","singleChar","escapeChar","and","const","params","concat","Function","bind","apply","MULTIGEOMETRY_TO_MEMBER_NODENAME","opt_options","options","surface_","surface","curve_","curve","multiCurve_","multiCurve","multiSurface_","multiSurface","schemaLocation","hasZ","readMultiCurve_","node","objectStack","lineStrings","MULTICURVE_PARSERS_","MultiLineString","readMultiSurface_","polygons","MULTISURFACE_PARSERS_","MultiPolygon","curveMemberParser_","CURVEMEMBER_PARSERS_","surfaceMemberParser_","SURFACEMEMBER_PARSERS_","readPatch_","PATCHES_PARSERS_","readSegment_","SEGMENTS_PARSERS_","readPolygonPatch_","FLAT_LINEAR_RINGS_PARSERS","readLineStringSegment_","GEOMETRY_FLAT_COORDINATES_PARSERS","interiorParser_","flatLinearRing","RING_PARSERS","push","exteriorParser_","readSurface_","flatLinearRings","SURFACE_PARSERS_","i","ii","flatCoordinates","ends","Polygon","GeometryLayout","XYZ","readCurve_","CURVE_PARSERS_","LineString","readEnvelope_","ENVELOPE_PARSERS_","readFlatPos_","let","m","s","re","exec","parseFloat","substr","containerSrs","axisOrientation","getAxisOrientation","y","x","len","readFlatPosList_","replace","context","contextDimension","z","coords","split","dim","getAttribute","writePos_","value","srsDimension","setAttribute","point","getCoordinates","getCoords_","opt_hasZ","writePosList_","points","parts","join","writePoint_","geometry","pos","namespaceURI","appendChild","writeEnvelope","values","ENVELOPE_SERIALIZERS_","writeLinearRing_","posList","RING_NODE_FACTORY_","opt_nodeName","parentNode","exteriorWritten","writeSurfaceOrPolygon_","nodeName","rings","getLinearRings","RING_SERIALIZERS_","patches","writeSurfacePatches_","writeCurveOrLineString_","segments","writeCurveSegments_","writeMultiSurfaceOrPolygon_","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS_","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","writeMultiPoint_","getPoints","POINTMEMBER_SERIALIZERS_","writeMultiCurveOrLineString_","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS_","writeRing_","ring","linearRing","writeSurfaceOrPolygonMember_","polygon","child","GEOMETRY_NODE_FACTORY_","writePointMember_","writeLineStringOrCurveMember_","line","writeGeometryElement","item","isArray","GEOMETRY_SERIALIZERS_","writeFeatureElement","feature","fid","getId","featureNS","getGeometryName","serializers","properties","getProperties","keys","key","getSimplifiedGeometry","writeFeatureMembers_","features","featureType","namespace","getType","writeGeometryNode","adaptOptions","geom","writeFeaturesNode","setAttributeNS","GEOMETRY_PARSERS","readPoint","readMultiPoint","readLineString","readMultiLineString","readLinearRing","readPolygon","readMultiPolygon","writeFeatures","FEATURE_COLLECTION_PARSERS","readGeometryElement","TRANSACTION_SUMMARY_PARSERS","TRANSACTION_RESPONSE_PARSERS","INSERT_RESULTS_PARSERS","QUERY_SERIALIZERS","TRANSACTION_SERIALIZERS","gmlVersion","GML2","featurePrefix","typeName","getTypeName","XMLNS","getKeys","get","name","writeOgcFidFilter","pair","WFSNS","nativeElement","vendorId","safeToIgnore","String","OGCNS","SCHEMA_LOCATIONS","featureType_","featureNS_","gmlFormat_","gmlFormat","schemaLocation_","getFeatureType","setFeatureType","readFeaturesFromNode","getReadOptions","readFeaturesInternal","readTransactionResponse","source","doc","readTransactionResponseFromDocument","readTransactionResponseFromNode","readFeatureCollectionMetadata","readFeatureCollectionMetadataFromDocument","readFeatureCollectionMetadataFromNode","n","nextSibling","nodeType","Node","ELEMENT_NODE","result","writeGetFeature","filter","handle","outputFormat","maxFeatures","resultType","startIndex","count","viewParams","bbox","propertyNames","featureTypes","GETFEATURE_SERIALIZERS","writeTransaction","inserts","updates","deletes","baseObj","obj","version","gmlOptions","nativeElements","readProjectionFromDocument","readProjectionFromNode","firstElementChild","nextElementSibling","childNodes","firstChild","pop","OGC_FID_PARSERS","prefix","indexOf","writeFilterCondition","valueReference","timePeriod","begin","writeTimeInstant","end","writeLogicalFilter","condition","writeOgcPropertyName","writeComparisonFilter","lowerBoundary","writeOgcLiteral","upperBoundary","toString","writeOgcExpression","property","time","timeInstant","timePosition","vectorSource","vector","Vector","style","Style","stroke","Stroke","color","width","raster","Tile","attributions","url","maxZoom","map","Map","layers","target","document","getElementById","view","View","center","zoom","featureRequest","equalTo","fetch","method","body","XMLSerializer","serializeToString","then","response","json","GeoJSON","readFeatures","addFeatures","getView","fit","getExtent"],"mappings":"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","file":"vector-wfs-getfeature.js","sourcesContent":["/**\n * @module ol/format/filter/Filter\n */\n\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature filters.\n *\n * @abstract\n */\nclass Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   */\n  constructor(tagName) {\n\n    /**\n     * @private\n     * @type {!string}\n     */\n    this.tagName_ = tagName;\n  }\n\n  /**\n   * The XML tag name for a filter.\n   * @returns {!string} Name.\n   */\n  getTagName() {\n    return this.tagName_;\n  }\n}\n\nexport default Filter;\n","/**\n * @module ol/format/filter/LogicalNary\n */\nimport {assert} from '../../asserts.js';\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature n-ary logical filters.\n *\n * @abstract\n */\nclass LogicalNary extends Filter {\n\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {Array<import(\"./Filter.js\").default>} conditions Conditions.\n   */\n  constructor(tagName, conditions) {\n\n    super(tagName);\n\n    /**\n     * @type {Array<import(\"./Filter.js\").default>}\n     */\n    this.conditions = conditions;\n    assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\n  }\n\n}\n\nexport default LogicalNary;\n","/**\n * @module ol/format/filter/And\n */\nimport LogicalNary from './LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<And>` operator between two or more filter conditions.\n *\n * @abstract\n */\nclass And extends LogicalNary {\n\n  /**\n   * @param {...import(\"./Filter.js\").default} conditions Conditions.\n   */\n  constructor(conditions) {\n    super('And', Array.prototype.slice.call(arguments));\n  }\n\n}\n\nexport default And;\n","/**\n * @module ol/format/filter/Bbox\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Represents a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @api\n */\nclass Bbox extends Filter {\n\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../../extent.js\").Extent} extent Extent.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be set\n   * on geometries when this is not provided.\n   */\n  constructor(geometryName, extent, opt_srsName) {\n\n    super('BBOX');\n\n    /**\n     * @type {!string}\n     */\n    this.geometryName = geometryName;\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.extent = extent;\n    if (extent.length !== 4) {\n      throw new Error('Expected an extent with four values ([minX, minY, maxX, maxY])');\n    }\n\n    /**\n     * @type {string|undefined}\n     */\n    this.srsName = opt_srsName;\n  }\n\n}\n\nexport default Bbox;\n","/**\n * @module ol/format/filter/Comparison\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property comparison filters.\n *\n * @abstract\n */\nclass Comparison extends Filter {\n\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   */\n  constructor(tagName, propertyName) {\n\n    super(tagName);\n\n    /**\n     * @type {!string}\n     */\n    this.propertyName = propertyName;\n  }\n\n}\n\nexport default Comparison;\n","/**\n * @module ol/format/filter/ComparisonBinary\n */\nimport Comparison from './Comparison.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property binary comparison filters.\n *\n * @abstract\n */\nclass ComparisonBinary extends Comparison {\n\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   */\n  constructor(tagName, propertyName, expression, opt_matchCase) {\n\n    super(tagName, propertyName);\n\n    /**\n     * @type {!(string|number)}\n     */\n    this.expression = expression;\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n  }\n\n}\n\nexport default ComparisonBinary;\n","/**\n * @module ol/format/filter/EqualTo\n */\nimport ComparisonBinary from './ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsEqualTo>` comparison operator.\n * @api\n */\nclass EqualTo extends ComparisonBinary {\n\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   */\n  constructor(propertyName, expression, opt_matchCase) {\n    super('PropertyIsEqualTo', propertyName, expression, opt_matchCase);\n  }\n\n}\n\nexport default EqualTo;\n","/**\n * @module ol/format/filter/IsLike\n */\nimport Comparison from './Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLike>` comparison operator.\n * @api\n */\nclass IsLike extends Comparison {\n\n  /**\n   * [constructor description]\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} pattern Text pattern.\n   * @param {string=} opt_wildCard Pattern character which matches any sequence of\n   *    zero or more string characters. Default is '*'.\n   * @param {string=} opt_singleChar pattern character which matches any single\n   *    string character. Default is '.'.\n   * @param {string=} opt_escapeChar Escape character which can be used to escape\n   *    the pattern characters. Default is '!'.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   */\n  constructor(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n    super('PropertyIsLike', propertyName);\n\n    /**\n     * @type {!string}\n     */\n    this.pattern = pattern;\n\n    /**\n     * @type {!string}\n     */\n    this.wildCard = (opt_wildCard !== undefined) ? opt_wildCard : '*';\n\n    /**\n     * @type {!string}\n     */\n    this.singleChar = (opt_singleChar !== undefined) ? opt_singleChar : '.';\n\n    /**\n     * @type {!string}\n     */\n    this.escapeChar = (opt_escapeChar !== undefined) ? opt_escapeChar : '!';\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n\n  }\n}\n\nexport default IsLike;\n","/**\n * @module ol/format/filter\n */\nimport And from './filter/And.js';\nimport Bbox from './filter/Bbox.js';\nimport Contains from './filter/Contains.js';\nimport During from './filter/During.js';\nimport EqualTo from './filter/EqualTo.js';\nimport GreaterThan from './filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\nimport Intersects from './filter/Intersects.js';\nimport IsBetween from './filter/IsBetween.js';\nimport IsLike from './filter/IsLike.js';\nimport IsNull from './filter/IsNull.js';\nimport LessThan from './filter/LessThan.js';\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\nimport Not from './filter/Not.js';\nimport NotEqualTo from './filter/NotEqualTo.js';\nimport Or from './filter/Or.js';\nimport Within from './filter/Within.js';\n\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params));\n}\n\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params));\n}\n\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\n * @returns {!Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../extent.js\").Extent} extent Extent.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, opt_srsName) {\n  return new Bbox(geometryName, extent, opt_srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, opt_srsName) {\n  return new Contains(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, opt_srsName) {\n  return new Intersects(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, opt_srsName) {\n  return new Within(geometryName, geometry, opt_srsName);\n}\n\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, opt_matchCase) {\n  return new EqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @returns {!IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @returns {!IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string=} opt_singleChar pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string=} opt_escapeChar Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(propertyName, pattern,\n  opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n  return new IsLike(propertyName, pattern,\n    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);\n}\n\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @returns {!During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n","/**\n * @module ol/format/GML3\n */\nimport {extend} from '../array.js';\nimport {createOrUpdate} from '../extent.js';\nimport {transformExtentWithOptions, transformGeometryWithOptions} from './Feature.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport {createElementNS, getAllTextContent, makeArrayPusher, makeChildAppender,\n  makeReplacer, makeSimpleNodeFactory, OBJECT_PROPERTY_NODE_FACTORY, parseNode,\n  pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI} from '../xml.js';\n\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation = GMLNS +\n    ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n    '1.0.0/gmlsf.xsd';\n\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember'\n};\n\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n\n  /**\n   * @param {import(\"./GMLBase.js\").Options=} opt_options Optional configuration object.\n   */\n  constructor(opt_options) {\n    const options = /** @type {import(\"./GMLBase.js\").Options} */\n        (opt_options ? opt_options : {});\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ = options.multiCurve !== undefined ?\n      options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ = options.multiSurface !== undefined ?\n      options.multiSurface : true;\n\n    /**\n     * @inheritDoc\n     */\n    this.schemaLocation = options.schemaLocation ?\n      options.schemaLocation : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ?\n      options.hasZ : false;\n\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve_(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop([],\n      this.MULTICURVE_PARSERS_, node, objectStack, this);\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface_(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop([],\n      this.MULTISURFACE_PARSERS_, node, objectStack, this);\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  curveMemberParser_(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS_, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  surfaceMemberParser_(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS_,\n      node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch_(node, objectStack) {\n    return pushParseAndPop([null],\n      this.PATCHES_PARSERS_, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment_(node, objectStack) {\n    return pushParseAndPop([null],\n      this.SEGMENTS_PARSERS_, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch_(node, objectStack) {\n    return pushParseAndPop([null],\n      this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment_(node, objectStack) {\n    return pushParseAndPop([null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  interiorParser_(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(undefined,\n      this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      const flatLinearRings = /** @type {Array<Array<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  exteriorParser_(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(undefined,\n      this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      const flatLinearRings = /** @type {Array<Array<number>>} */\n          (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface_(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop([null],\n      this.SURFACE_PARSERS_, node, objectStack, this);\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve_(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop([null],\n      this.CURVE_PARSERS_, node, objectStack, this);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope_(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop([null],\n      this.ENVELOPE_PARSERS_, node, objectStack, this);\n    return createOrUpdate(flatCoordinates[1][0],\n      flatCoordinates[1][1], flatCoordinates[2][0],\n      flatCoordinates[2][1]);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos_(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList_(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(\n        node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(\n        node.getAttribute('dimension'));\n    } else if (/** @type {Element} */ (node.parentNode).getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension'));\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = (dim === 3) ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = (point[0] + ' ' + point[1]);\n    } else {\n      coords = (point[1] + ' ' + point[0]);\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string=} opt_srsName Optional srsName\n   * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, opt_srsName, opt_hasZ) {\n    let axisOrientation = 'enu';\n    if (opt_srsName) {\n      axisOrientation = getProjection(opt_srsName).getAxisOrientation();\n    }\n    let coords = ((axisOrientation.substr(0, 2) === 'en') ?\n      point[0] + ' ' + point[1] :\n      point[1] + ' ' + point[0]);\n    if (opt_hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePoint_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}), this.ENVELOPE_SERIALIZERS_,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack, keys, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeLinearRing_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior');\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfaceOrPolygon_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS_,\n        this.RING_NODE_FACTORY_,\n        rings, objectStack, undefined, this);\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(\n        patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveOrLineString_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'LineString' ||\n        node.nodeName === 'LineStringSegment') {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments,\n        geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeMultiSurfaceOrPolygon_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS_,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons,\n      objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeMultiPoint_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS_,\n      makeSimpleNodeFactory('pointMember'), points,\n      objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeMultiCurveOrLineString_(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS_,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines,\n      objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeRing_(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing_(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfaceOrPolygonMember_(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(\n      polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePointMember_(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint_(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeLineStringOrCurveMember_(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString_(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI,\n      'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString_(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[objectStack.length - 1]);\n    const item = assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(/** @type {import(\"../extent.js\").Extent} */ (geometry), context);\n    } else {\n      value = transformGeometryWithOptions(/** @type {import(\"../geom/Geometry.js\").default} */ (geometry), true, context);\n    }\n    pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      (item), this.GEOMETRY_SERIALIZERS_,\n      this.GEOMETRY_NODE_FACTORY_, [value],\n      objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const properties = feature.getProperties();\n    const keys = [];\n    const values = [];\n    for (const key in properties) {\n      const value = properties[key];\n      if (value !== null) {\n        keys.push(key);\n        values.push(value);\n        if (key == geometryName || typeof /** @type {?} */ (value).getSimplifiedGeometry === 'function') {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = makeChildAppender(\n              this.writeGeometryElement, this);\n          }\n        } else {\n          if (!(key in context.serializers[featureNS])) {\n            context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n          }\n        }\n      }\n    }\n    const item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      (item), context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack, keys);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement, this);\n    const item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS), features,\n      objectStack);\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(this.namespace,\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    let nodeName;\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (value).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace,\n      nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @override\n   * @api\n   */\n  writeGeometryNode(geometry, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {node: geom, hasZ: this.hasZ, srsName: this.srsName,\n      curve: this.curve_, surface: this.surface_,\n      multiSurface: this.multiSurface_, multiCurve: this.multiCurve_};\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Element} Node.\n   * @override\n   * @api\n   */\n  writeFeaturesNode(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation);\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType\n    };\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos_),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser_,\n    'exterior': GML3.prototype.exteriorParser_\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @protected\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(\n      GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(\n      GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(\n      GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(\n      GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(\n      GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface_),\n    'MultiSurface': makeReplacer(\n      GML3.prototype.readMultiSurface_),\n    'Curve': makeReplacer(GML3.prototype.readCurve_),\n    'MultiCurve': makeReplacer(\n      GML3.prototype.readMultiCurve_),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.MULTICURVE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(\n      GML3.prototype.curveMemberParser_),\n    'curveMembers': makeArrayPusher(\n      GML3.prototype.curveMemberParser_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.MULTISURFACE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(\n      GML3.prototype.surfaceMemberParser_),\n    'surfaceMembers': makeArrayPusher(\n      GML3.prototype.surfaceMemberParser_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.CURVEMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(\n      GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.SURFACEMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.SURFACE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.CURVE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.ENVELOPE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(\n      GML3.prototype.readFlatPosList_),\n    'upperCorner': makeArrayPusher(\n      GML3.prototype.readFlatPosList_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.PATCHES_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(\n      GML3.prototype.readPolygonPatch_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n * @private\n */\nGML3.prototype.SEGMENTS_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeReplacer(\n      GML3.prototype.readLineStringSegment_)\n  }\n};\n\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\nGML3.prototype.RING_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing_),\n    'interior': makeChildAppender(GML3.prototype.writeRing_)\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\nGML3.prototype.ENVELOPE_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode)\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember_),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember_)\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(\n      GML3.prototype.writePointMember_)\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember_),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember_)\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n * @private\n */\nGML3.prototype.GEOMETRY_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(\n      GML3.prototype.writeCurveOrLineString_),\n    'MultiCurve': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString_),\n    'Point': makeChildAppender(GML3.prototype.writePoint_),\n    'MultiPoint': makeChildAppender(\n      GML3.prototype.writeMultiPoint_),\n    'LineString': makeChildAppender(\n      GML3.prototype.writeCurveOrLineString_),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString_),\n    'LinearRing': makeChildAppender(\n      GML3.prototype.writeLinearRing_),\n    'Polygon': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygon_),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon_),\n    'Surface': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygon_),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon_),\n    'Envelope': makeChildAppender(\n      GML3.prototype.writeEnvelope)\n  }\n};\n\nexport default GML3;\n","/**\n * @module ol/format/WFS\n */\nimport {assert} from '../asserts.js';\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {and as andFilter, bbox as bboxFilter} from './filter.js';\nimport XMLFeature from './XMLFeature.js';\nimport {readNonNegativeIntegerString, readNonNegativeInteger, writeStringTextNode} from './xsd.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport {createElementNS, isDocument, makeArrayPusher, makeChildAppender,\n  makeObjectPropertySetter, makeSimpleNodeFactory, parse, parseNode,\n  pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI} from '../xml.js';\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readGeometryElement, 'bounds')\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger)\n  }\n};\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(\n      readInsertResults, 'insertIds')\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  }\n};\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  }\n};\n\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response. Default is `ol/format/GML3`.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n */\n\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string>} featureTypes The feature type names.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/Filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0` or `1.1.0`.\n */\n\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures\n * @property {import(\"../extent.js\").Extent} bounds\n */\n\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted\n * @property {number} totalInserted\n * @property {number} totalUpdated\n * @property {Array<string>} insertIds\n */\n\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n\n/**\n * @type {string}\n */\nconst OGCNS = 'http://www.opengis.net/ogc';\n\n\n/**\n * @type {string}\n */\nconst WFSNS = 'http://www.opengis.net/wfs';\n\n\n/**\n * @type {string}\n */\nconst FESNS = 'http://www.opengis.net/fes';\n\n\n/**\n * @type {Object<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n};\n\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n\n  /**\n   * @param {Options=} opt_options Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat ?\n      options.gmlFormat : new GML3();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation ?\n      options.schemaLocation : SCHEMA_LOCATIONS[DEFAULT_VERSION];\n  }\n\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readFeaturesFromNode(node, opt_options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node: node\n    };\n    assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_\n    });\n\n    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n    const objectStack = [context];\n    this.gmlFormat_.FEATURE_COLLECTION_PARSERS[GMLNS][\n      'featureMember'] =\n        makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n    let features = pushParseAndPop([],\n      this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node,\n      objectStack, this.gmlFormat_);\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n        /** @type {Document} */ (source));\n    } else {\n      return this.readTransactionResponseFromNode(/** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n        /** @type {Document} */ (source));\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Element} */ (source));\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(\n      node.getAttribute('numberOfFeatures'));\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n      /** @type {FeatureCollectionMetadata} */ (result),\n      FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n      /** @type {TransactionResponse} */({}),\n      TRANSACTION_RESPONSE_PARSERS, node, []);\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS, 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', '1.1.0');\n    let filter;\n    if (options) {\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n      if (options.outputFormat) {\n        node.setAttribute('outputFormat', options.outputFormat);\n      }\n      if (options.maxFeatures !== undefined) {\n        node.setAttribute('maxFeatures', String(options.maxFeatures));\n      }\n      if (options.resultType) {\n        node.setAttribute('resultType', options.resultType);\n      }\n      if (options.startIndex !== undefined) {\n        node.setAttribute('startIndex', String(options.startIndex));\n      }\n      if (options.count !== undefined) {\n        node.setAttribute('count', String(options.count));\n      }\n      if (options.viewParams !== undefined) {\n        node.setAttribute('viewParams', options.viewParams);\n      }\n      filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName,\n          12); // `options.geometryName` must also be provided when `options.bbox` is set\n        const bbox = bboxFilter(\n          /** @type {string} */ (options.geometryName), options.bbox, options.srsName);\n        if (filter) {\n          // if bbox and filter are both set, combine the two into a single filter\n          filter = andFilter(filter, bbox);\n        } else {\n          filter = bbox;\n        }\n      }\n    }\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node: node\n    };\n    assign(context, {\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'geometryName': options.geometryName,\n      'filter': filter,\n      'propertyNames': options.propertyNames ? options.propertyNames : []\n    });\n\n    assert(Array.isArray(options.featureTypes),\n      11); // `options.featureTypes` should be an Array\n    writeGetFeature(node, /** @type {!Array<string>} */ (options.featureTypes), [context]);\n    return node;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const node = createElementNS(WFSNS, 'Transaction');\n    const version = options.version ? options.version : DEFAULT_VERSION;\n    const gmlVersion = version === '1.0.0' ? 2 : 3;\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    let obj;\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    const schemaLocation = SCHEMA_LOCATIONS[version];\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', schemaLocation);\n    const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n    if (inserts) {\n      obj = assign({node: node}, {'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName});\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj,\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Insert'), inserts,\n        objectStack);\n    }\n    if (updates) {\n      obj = assign({node: node}, {'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName});\n      assign(obj, baseObj);\n      pushSerializeAndPop(obj,\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Update'), updates,\n        objectStack);\n    }\n    if (deletes) {\n      pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'srsName': options.srsName},\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Delete'), deletes,\n      objectStack);\n    }\n    if (options.nativeElements) {\n      pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n        'featureType': options.featureType, 'featurePrefix': featurePrefix,\n        'gmlVersion': gmlVersion, 'srsName': options.srsName},\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Native'), options.nativeElements,\n      objectStack);\n    }\n    return node;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(n);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild &&\n        node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (!(n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 &&\n            n.firstChild.nodeType === 3))) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop(\n    {}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function(node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  }\n};\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser\n  }\n};\n\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop(\n    [], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const filter = createElementNS(OGCNS, 'Filter');\n  const child = createElementNS(OGCNS, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', /** @type {string} */ (fid));\n  node.appendChild(filter);\n}\n\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @returns {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (value && typeof /** @type {?} */ (value).getSimplifiedGeometry === 'function') {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(/** @type {import(\"../xml.js\").NodeStackItem} */ (\n      {'gmlVersion': context['gmlVersion'], node: node,\n        'hasZ': context['hasZ'], 'srsName': context['srsName']}),\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory('Property'), values,\n    objectStack);\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const name = createElementNS(WFSNS, 'Name');\n  const context = objectStack[objectStack.length - 1];\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(WFSNS, 'Value');\n    node.appendChild(value);\n    if (pair.value && typeof /** @type {?} */ (pair.value).getSimplifiedGeometry === 'function') {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value,\n          pair.value, objectStack);\n      } else {\n        GML3.prototype.writeGeometryElement(value,\n          pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeContainsFilter),\n    'Intersects': makeChildAppender(writeIntersectsFilter),\n    'Within': makeChildAppender(writeWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  }\n};\n\n\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  node.setAttribute('typeName', typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (assign({}, context));\n  item.node = node;\n  pushSerializeAndPop(item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'), propertyNames,\n    objectStack);\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(OGCNS, 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter], objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Contains.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeContainsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Intersects.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIntersectsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Within.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeWithinFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n\n  const valueReference = createElementNS(FESNS, 'ValueReference');\n  writeStringTextNode(valueReference, filter.propertyName);\n  node.appendChild(valueReference);\n\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition], objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  const condition = filter.condition;\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition], objectStack);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.expression);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(OGCNS, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeOgcLiteral(lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(OGCNS, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeOgcLiteral(upperBoundary, '' + filter.upperBoundary);\n}\n\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.pattern);\n}\n\n\n/**\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeOgcExpression(tagName, node, value) {\n  const property = createElementNS(OGCNS, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcPropertyName(node, value) {\n  writeOgcExpression('PropertyName', node, value);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcLiteral(node, value) {\n  writeOgcExpression('Literal', node, value);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter) {\n  const child = createElementNS(OGCNS, 'Filter');\n  writeFilterCondition(child, filter, []);\n  return child;\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (assign({}, context));\n  item.node = node;\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'), featureTypes,\n    objectStack);\n}\n\n\nexport default WFS;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {\n  equalTo as equalToFilter,\n  like as likeFilter,\n  and as andFilter\n} from '../src/ol/format/filter.js';\nimport {WFS, GeoJSON} from '../src/ol/format.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\nimport XYZ from '../src/ol/source/XYZ.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport {Stroke, Style} from '../src/ol/style.js';\n\n\nconst vectorSource = new VectorSource();\nconst vector = new VectorLayer({\n  source: vectorSource,\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(0, 0, 255, 1.0)',\n      width: 2\n    })\n  })\n});\n\nconst key = 'get_your_own_D6rA4zTHduk6KOKTXzGB';\nconst attributions = '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> ' +\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>';\n\nconst raster = new TileLayer({\n  source: new XYZ({\n    attributions: attributions,\n    url: 'https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=' + key,\n    maxZoom: 20\n  })\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [-8908887.277395891, 5381918.072437216],\n    maxZoom: 19,\n    zoom: 12\n  })\n});\n\n// generate a GetFeature request\nconst featureRequest = new WFS().writeGetFeature({\n  srsName: 'EPSG:3857',\n  featureNS: 'http://openstreemap.org',\n  featurePrefix: 'osm',\n  featureTypes: ['water_areas'],\n  outputFormat: 'application/json',\n  filter: andFilter(\n    likeFilter('name', 'Mississippi*'),\n    equalToFilter('waterway', 'riverbank')\n  )\n});\n\n// then post the request and add the received features to a layer\nfetch('https://ahocevar.com/geoserver/wfs', {\n  method: 'POST',\n  body: new XMLSerializer().serializeToString(featureRequest)\n}).then(function(response) {\n  return response.json();\n}).then(function(json) {\n  const features = new GeoJSON().readFeatures(json);\n  vectorSource.addFeatures(features);\n  map.getView().fit(vectorSource.getExtent());\n});\n"],"sourceRoot":""}