{"version":3,"sources":["webpack:///../src/ol/source/ImageCanvas.js","webpack:///./d3.js"],"names":["ImageCanvasSource","options","source_Image","call","this","attributions","projection","resolutions","state","canvasFunction_","canvasFunction","canvas_","renderedRevision_","ratio_","undefined","ratio","Object","util","prototype","getImageInternal","extent","resolution","pixelRatio","findNearestResolution","let","canvas","getRevision","getResolution","getPixelRatio","ol_extent","getExtent","slice","const","size","canvasElement","ImageCanvas","source_ImageCanvas","map","Map","layers","Tile","source","Stamen","layer","target","view","View","center","proj","zoom","d3","json","error","us","features","topojson","feature","objects","counties","Image","canvasWidth","canvasHeight","select","document","createElement","attr","context","node","getContext","d3Projection","geoMercator","scale","translate","d3Path","geoPath","pixelBounds","bounds","pixelBoundsWidth","pixelBoundsHeight","geoBounds","geoBoundsLeftBottom","geoBoundsRightTop","geoBoundsWidth","widthResolution","heightResolution","Math","max","stroke","addLayer"],"mappings":"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","file":"d3.js","sourcesContent":["/**\n * @module ol/source/ImageCanvas\n */\nimport {inherits} from '../util.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport {containsExtent, getHeight, getWidth, scaleFromCenter} from '../extent.js';\nimport ImageSource from '../source/Image.js';\n\n\n/**\n * A function returning the canvas element (`{HTMLCanvasElement}`)\n * used by the source as an image. The arguments passed to the function are:\n * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,\n * `{number}` the device pixel ratio, {@link module:ol/size~Size} the image size, and\n * {@link module:ol/proj/Projection} the image projection. The canvas returned by\n * this function is cached by the source. The this keyword inside the function\n * references the {@link module:ol/source/ImageCanvas}.\n *\n * @typedef {function(this:module:ol/ImageCanvas, module:ol/extent~Extent, number,\n *     number, module:ol/size~Size, module:ol/proj/Projection): HTMLCanvasElement} FunctionType\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.\n * @property {module:ol/source/ImageCanvas~FunctionType} [canvasFunction] Canvas function.\n * The function returning the canvas element used by the source\n * as an image. The arguments passed to the function are: `{module:ol/extent~Extent}` the\n * image extent, `{number}` the image resolution, `{number}` the device pixel\n * ratio, `{module:ol/size~Size}` the image size, and `{module:ol/proj/Projection~Projection}` the image\n * projection. The canvas returned by this function is cached by the source. If\n * the value returned by the function is later changed then\n * `changed` should be called on the source for the source to\n * invalidate the current cached image. See @link: {@link module:ol/Observable~Observable#changed}\n * @property {module:ol/proj~ProjectionLike} projection Projection.\n * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the\n * width and height of the map viewport, and so on. Must be `1` or higher.\n * @property {Array.<number>} [resolutions] Resolutions.\n * If specified, new canvases will be created for these resolutions\n * @property {module:ol/source/State} [state] Source state.\n */\n\n\n/**\n * @classdesc\n * Base class for image sources where a canvas element is the image.\n *\n * @constructor\n * @extends {module:ol/source/Image}\n * @param {module:ol/source/ImageCanvas~Options=} options ImageCanvas options.\n * @api\n */\nconst ImageCanvasSource = function(options) {\n\n  ImageSource.call(this, {\n    attributions: options.attributions,\n    projection: options.projection,\n    resolutions: options.resolutions,\n    state: options.state\n  });\n\n  /**\n   * @private\n   * @type {module:ol/source/ImageCanvas~FunctionType}\n   */\n  this.canvasFunction_ = options.canvasFunction;\n\n  /**\n   * @private\n   * @type {module:ol/ImageCanvas}\n   */\n  this.canvas_ = null;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.renderedRevision_ = 0;\n\n  /**\n   * @private\n   * @type {number}\n   */\n  this.ratio_ = options.ratio !== undefined ?\n    options.ratio : 1.5;\n\n};\n\ninherits(ImageCanvasSource, ImageSource);\n\n\n/**\n * @inheritDoc\n */\nImageCanvasSource.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {\n  resolution = this.findNearestResolution(resolution);\n\n  let canvas = this.canvas_;\n  if (canvas &&\n      this.renderedRevision_ == this.getRevision() &&\n      canvas.getResolution() == resolution &&\n      canvas.getPixelRatio() == pixelRatio &&\n      containsExtent(canvas.getExtent(), extent)) {\n    return canvas;\n  }\n\n  extent = extent.slice();\n  scaleFromCenter(extent, this.ratio_);\n  const width = getWidth(extent) / resolution;\n  const height = getHeight(extent) / resolution;\n  const size = [width * pixelRatio, height * pixelRatio];\n\n  const canvasElement = this.canvasFunction_(\n    extent, resolution, pixelRatio, size, projection);\n  if (canvasElement) {\n    canvas = new ImageCanvas(extent, resolution, pixelRatio, canvasElement);\n  }\n  this.canvas_ = canvas;\n  this.renderedRevision_ = this.getRevision();\n\n  return canvas;\n};\nexport default ImageCanvasSource;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {getWidth, getCenter} from '../src/ol/extent.js';\nimport {Image as ImageLayer, Tile as TileLayer} from '../src/ol/layer.js';\nimport {fromLonLat, toLonLat} from '../src/ol/proj.js';\nimport {ImageCanvas as ImageCanvasSource, Stamen} from '../src/ol/source.js';\n\n\nconst map = new Map({\n  layers: [\n    new TileLayer({\n      source: new Stamen({\n        layer: 'watercolor'\n      })\n    })\n  ],\n  target: 'map',\n  view: new View({\n    center: fromLonLat([-97, 38]),\n    zoom: 4\n  })\n});\n\n\n/**\n * Load the topojson data and create an ol/layer/Image for that data.\n */\nd3.json('data/topojson/us.json', function(error, us) {\n  const features = topojson.feature(us, us.objects.counties);\n\n  /**\n   * This function uses d3 to render the topojson features to a canvas.\n   * @param {module:ol/extent~Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {module:ol/size~Size} size Size.\n   * @param {module:ol/proj/Projection~Projection} projection Projection.\n   * @return {HTMLCanvasElement} A canvas element.\n   */\n  const canvasFunction = function(extent, resolution, pixelRatio, size, projection) {\n    const canvasWidth = size[0];\n    const canvasHeight = size[1];\n\n    const canvas = d3.select(document.createElement('canvas'));\n    canvas.attr('width', canvasWidth).attr('height', canvasHeight);\n\n    const context = canvas.node().getContext('2d');\n\n    const d3Projection = d3.geoMercator().scale(1).translate([0, 0]);\n    let d3Path = d3.geoPath().projection(d3Projection);\n\n    const pixelBounds = d3Path.bounds(features);\n    const pixelBoundsWidth = pixelBounds[1][0] - pixelBounds[0][0];\n    const pixelBoundsHeight = pixelBounds[1][1] - pixelBounds[0][1];\n\n    const geoBounds = d3.geoBounds(features);\n    const geoBoundsLeftBottom = fromLonLat(geoBounds[0], projection);\n    const geoBoundsRightTop = fromLonLat(geoBounds[1], projection);\n    let geoBoundsWidth = geoBoundsRightTop[0] - geoBoundsLeftBottom[0];\n    if (geoBoundsWidth < 0) {\n      geoBoundsWidth += getWidth(projection.getExtent());\n    }\n    const geoBoundsHeight = geoBoundsRightTop[1] - geoBoundsLeftBottom[1];\n\n    const widthResolution = geoBoundsWidth / pixelBoundsWidth;\n    const heightResolution = geoBoundsHeight / pixelBoundsHeight;\n    const r = Math.max(widthResolution, heightResolution);\n    const scale = r / (resolution / pixelRatio);\n\n    const center = toLonLat(getCenter(extent), projection);\n    d3Projection.scale(scale).center(center)\n      .translate([canvasWidth / 2, canvasHeight / 2]);\n    d3Path = d3Path.projection(d3Projection).context(context);\n    d3Path(features);\n    context.stroke();\n\n    return canvas.node();\n  };\n\n  const layer = new ImageLayer({\n    source: new ImageCanvasSource({\n      canvasFunction: canvasFunction,\n      projection: 'EPSG:3857'\n    })\n  });\n  map.addLayer(layer);\n});\n"],"sourceRoot":""}