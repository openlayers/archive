{"version":3,"sources":["webpack:///../src/ol/format/filter/Filter.js","webpack:///../src/ol/format/filter/LogicalNary.js","webpack:///../src/ol/format/filter/And.js","webpack:///../src/ol/format/filter/Bbox.js","webpack:///../src/ol/format/filter/Spatial.js","webpack:///../src/ol/format/filter/Contains.js","webpack:///../src/ol/format/filter/Comparison.js","webpack:///../src/ol/format/filter/During.js","webpack:///../src/ol/format/filter/ComparisonBinary.js","webpack:///../src/ol/format/filter/EqualTo.js","webpack:///../src/ol/format/filter/GreaterThan.js","webpack:///../src/ol/format/filter/GreaterThanOrEqualTo.js","webpack:///../src/ol/format/filter/Intersects.js","webpack:///../src/ol/format/filter/IsBetween.js","webpack:///../src/ol/format/filter/IsLike.js","webpack:///../src/ol/format/filter/IsNull.js","webpack:///../src/ol/format/filter/LessThan.js","webpack:///../src/ol/format/filter/LessThanOrEqualTo.js","webpack:///../src/ol/format/filter/Not.js","webpack:///../src/ol/format/filter/NotEqualTo.js","webpack:///../src/ol/format/filter/Or.js","webpack:///../src/ol/format/filter/Within.js","webpack:///../src/ol/format/filter.js","webpack:///../src/ol/format/GML3.js","webpack:///../src/ol/format/WFS.js","webpack:///./vector-wfs-getfeature.js"],"names":["Filter","tagName","this","tagName_","prototype","getTagName","filter_Filter","LogicalNary","conditions","call","Array","slice","arguments","Object","asserts","length","util","filter_LogicalNary","And","const","params","concat","apply","filter_And","Bbox","geometryName","extent","opt_srsName","srsName","filter_Bbox","Spatial","geometry","filter_Spatial","Contains","Comparison","propertyName","filter_Comparison","During","begin","end","ComparisonBinary","expression","opt_matchCase","matchCase","filter_ComparisonBinary","EqualTo","filter_EqualTo","GreaterThan","GreaterThanOrEqualTo","Intersects","IsBetween","lowerBoundary","upperBoundary","IsLike","pattern","opt_wildCard","opt_singleChar","opt_escapeChar","wildCard","undefined","singleChar","escapeChar","filter_IsLike","IsNull","LessThan","LessThanOrEqualTo","Not","condition","NotEqualTo","Or","Within","and","Function","bind","GML3_schemaLocation","GMLBase","GML3","opt_options","options","surface_","surface","curve_","curve","multiCurve_","multiCurve","multiSurface_","multiSurface","schemaLocation","hasZ","readMultiCurve_","node","objectStack","lineStrings","xml","MULTICURVE_PARSERS_","multiLineString","MultiLineString","setLineStrings","readMultiSurface_","polygons","MULTISURFACE_PARSERS_","multiPolygon","MultiPolygon","setPolygons","curveMemberParser_","CURVEMEMBER_PARSERS_","surfaceMemberParser_","SURFACEMEMBER_PARSERS_","readPatch_","PATCHES_PARSERS_","readSegment_","SEGMENTS_PARSERS_","readPolygonPatch_","FLAT_LINEAR_RINGS_PARSERS_","readLineStringSegment_","GEOMETRY_FLAT_COORDINATES_PARSERS_","interiorParser_","flatLinearRing","RING_PARSERS","push","exteriorParser_","readSurface_","flatLinearRings","SURFACE_PARSERS_","i","ii","polygon","Polygon","flatCoordinates","ends","array","setFlatCoordinates","GeometryLayout","XYZ","readCurve_","CURVE_PARSERS_","lineString","LineString","readEnvelope_","ENVELOPE_PARSERS_","ol_extent","readFlatPos_","let","m","s","re","exec","parseFloat","substr","containerSrs","axisOrientation","ol_proj","getAxisOrientation","y","x","len","readFlatPosList_","replace","context","contextDimension","z","coords","split","dim","getAttribute","xsd","parentNode","http://www.opengis.net/gml","pos","posList","interior","exterior","GEOMETRY_PARSERS_","Point","readPoint","MultiPoint","readMultiPoint","readLineString","readMultiLineString","LinearRing","readLinearRing","readPolygon","readMultiPolygon","Surface","MultiSurface","Curve","MultiCurve","Envelope","curveMember","curveMembers","surfaceMember","surfaceMembers","patches","segments","lowerCorner","upperCorner","PolygonPatch","LineStringSegment","writePos_","value","srsDimension","setAttribute","point","getCoordinates","getCoords_","opt_hasZ","writePosList_","points","parts","join","writePoint_","namespaceURI","appendChild","writeEnvelope","values","ENVELOPE_SERIALIZERS_","writeLinearRing_","RING_NODE_FACTORY_","opt_nodeName","exteriorWritten","writeSurfaceOrPolygon_","nodeName","rings","getLinearRings","RING_SERIALIZERS_","writeSurfacePatches_","writeCurveOrLineString_","writeCurveSegments_","writeMultiSurfaceOrPolygon_","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS_","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","writeMultiPoint_","getPoints","POINTMEMBER_SERIALIZERS_","writeMultiCurveOrLineString_","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS_","writeRing_","ring","linearRing","writeSurfaceOrPolygonMember_","child","GEOMETRY_NODE_FACTORY_","writePointMember_","writeLineStringOrCurveMember_","line","writeGeometryElement","item","ol_obj","isArray","dataProjection","featureProjection","Feature","GEOMETRY_SERIALIZERS_","writeFeatureElement","feature","fid","getId","featureNS","getGeometryName","serializers","properties","getProperties","keys","key","Geometry","writeFeatureMembers_","features","featureType","MULTIGEOMETRY_TO_MEMBER_NODENAME","getType","writeGeometryNode","adaptOptions","geom","writeFeatures","writeFeaturesNode","setAttributeNS","polygonMember","pointMember","lineStringMember","format_GML3","FEATURE_PREFIX","XMLNS","OGCNS","WFSNS","FESNS","SCHEMA_LOCATIONS","1.1.0","1.0.0","WFS","featureType_","featureNS_","gmlFormat_","gmlFormat","schemaLocation_","XMLFeature","getFeatureType","setFeatureType","readFeatures","readFeaturesFromNode","getReadOptions","FEATURE_COLLECTION_PARSERS","readFeaturesInternal","readTransactionResponse","source","readTransactionResponseFromDocument","readTransactionResponseFromNode","doc","readFeatureCollectionMetadata","readFeatureCollectionMetadataFromDocument","readFeatureCollectionMetadataFromNode","n","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","boundedBy","readGeometryElement","result","TRANSACTION_SUMMARY_PARSERS","http://www.opengis.net/wfs","totalInserted","totalUpdated","totalDeleted","OGC_FID_PARSERS","http://www.opengis.net/ogc","FeatureId","INSERT_RESULTS_PARSERS","TRANSACTION_RESPONSE_PARSERS","TransactionSummary","InsertResults","QUERY_SERIALIZERS","PropertyName","writeOgcFidFilter","filter","getTypeName","featurePrefix","prefix","indexOf","TRANSACTION_SERIALIZERS","Insert","gmlVersion","GML2","Update","typeName","getKeys","get","name","Delete","Property","pair","Native","nativeElement","vendorId","safeToIgnore","GETFEATURE_SERIALIZERS","Query","propertyNames","writeFilterCondition","valueReference","timePeriod","writeTimeInstant","writeLogicalFilter","BBOX","writeOgcPropertyName","PropertyIsEqualTo","writeComparisonFilter","PropertyIsNotEqualTo","PropertyIsLessThan","PropertyIsLessThanOrEqualTo","PropertyIsGreaterThan","PropertyIsGreaterThanOrEqualTo","PropertyIsNull","PropertyIsBetween","writeOgcLiteral","PropertyIsLike","toString","writeOgcExpression","property","time","timeInstant","timePosition","writeGetFeature","handle","outputFormat","maxFeatures","resultType","startIndex","count","bbox","filter_bbox","featureTypes","writeTransaction","inserts","updates","deletes","baseObj","obj","version","gmlOptions","nativeElements","readProjection","readProjectionFromDocument","readProjectionFromNode","firstElementChild","nextElementSibling","childNodes","pop","format_WFS","vectorSource","source_Vector","vector","Vector","style","Style","stroke","Stroke","color","width","raster","Tile","BingMaps","imagerySet","map","Map","layers","target","document","getElementById","view","View","center","maxZoom","zoom","featureRequest","like","equalTo","fetch","method","body","XMLSerializer","serializeToString","then","response","json","GeoJSON","addFeatures","getView","fit","getExtent"],"mappings":"mIAeMA,EAAS,SAASC,GAMtBC,KAAKC,SAAWF,GAOlBD,EAAOI,UAAUC,WAAa,WAC5B,OAAOH,KAAKC,UAGd,IAAAG,EAAA,ECdMC,EAAc,SAASN,EAASO,GAEpCF,EAAOG,KAAKP,KAAMD,GAKlBC,KAAKM,WAAaE,MAAMN,UAAUO,MAAMF,KAAKG,UAAW,GACxDC,OAAAC,EAAA,EAAAD,CAAOX,KAAKM,WAAWO,QAAU,EAAG,KAGtCF,OAAAG,EAAA,EAAAH,CAASN,EAAaD,GACtB,IAAAW,EAAA,ECfMC,EAAM,SAASV,GACnBW,IAAMC,GAAU,OAAOC,OAAOX,MAAMN,UAAUO,MAAMF,KAAKG,YACzDK,EAAYK,MAAMpB,KAAMkB,IAG1BP,OAAAG,EAAA,EAAAH,CAASK,EAAKD,GAEd,IAAAM,EAAA,ECHMC,EAAO,SAASC,EAAcC,EAAQC,GAE1CrB,EAAOG,KAAKP,KAAM,QAKlBA,KAAKuB,aAAeA,EAKpBvB,KAAKwB,OAASA,EAKdxB,KAAK0B,QAAUD,GAGjBd,OAAAG,EAAA,EAAAH,CAASW,EAAMlB,GAEf,IAAAuB,EAAA,ECpBMC,EAAU,SAAS7B,EAASwB,EAAcM,EAAUJ,GAExDrB,EAAOG,KAAKP,KAAMD,GAKlBC,KAAKuB,aAAeA,GAAgB,WAKpCvB,KAAK6B,SAAWA,EAKhB7B,KAAK0B,QAAUD,GAGjBd,OAAAG,EAAA,EAAAH,CAASiB,EAASxB,GAElB,IAAA0B,EAAA,ECxBMC,EAAW,SAASR,EAAcM,EAAUJ,GAEhDK,EAAQvB,KAAKP,KAAM,WAAYuB,EAAcM,EAAUJ,IAIzDd,OAAAG,EAAA,EAAAH,CAASoB,EAAUD,GACnB,ICTME,EAAa,SAASjC,EAASkC,GAEnC7B,EAAOG,KAAKP,KAAMD,GAKlBC,KAAKiC,aAAeA,GAGtBtB,OAAAG,EAAA,EAAAH,CAASqB,EAAY5B,GAErB,IAAA8B,EAAA,ECZMC,EAAS,SAASF,EAAcG,EAAOC,GAC3CH,EAAW3B,KAAKP,KAAM,SAAUiC,GAKhCjC,KAAKoC,MAAQA,EAKbpC,KAAKqC,IAAMA,GAGb1B,OAAAG,EAAA,EAAAH,CAASwB,EAAQD,GACjB,ICbMI,EAAmB,SAASvC,EAASkC,EAAcM,EAAYC,GAEnEN,EAAW3B,KAAKP,KAAMD,EAASkC,GAK/BjC,KAAKuC,WAAaA,EAKlBvC,KAAKyC,UAAYD,GAGnB7B,OAAAG,EAAA,EAAAH,CAAS2B,EAAkBJ,GAC3B,IAAAQ,EAAA,EClBMC,EAAU,SAASV,EAAcM,EAAYC,GACjDE,EAAiBnC,KAAKP,KAAM,oBAAqBiC,EAAcM,EAAYC,IAG7E7B,OAAAG,EAAA,EAAAH,CAASgC,EAASD,GAClB,IAAAE,EAAA,ECNMC,EAAc,SAASZ,EAAcM,GACzCG,EAAiBnC,KAAKP,KAAM,wBAAyBiC,EAAcM,IAGrE5B,OAAAG,EAAA,EAAAH,CAASkC,EAAaH,GACtB,ICLMI,EAAuB,SAASb,EAAcM,GAClDG,EAAiBnC,KAAKP,KAAM,iCAAkCiC,EAAcM,IAG9E5B,OAAAG,EAAA,EAAAH,CAASmC,EAAsBJ,GAC/B,ICFMK,EAAa,SAASxB,EAAcM,EAAUJ,GAElDK,EAAQvB,KAAKP,KAAM,aAAcuB,EAAcM,EAAUJ,IAI3Dd,OAAAG,EAAA,EAAAH,CAASoC,EAAYjB,GACrB,ICTMkB,EAAY,SAASf,EAAcgB,EAAeC,GACtDhB,EAAW3B,KAAKP,KAAM,oBAAqBiC,GAK3CjC,KAAKiD,cAAgBA,EAKrBjD,KAAKkD,cAAgBA,GAGvBvC,OAAAG,EAAA,EAAAH,CAASqC,EAAWd,GACpB,ICTMiB,EAAS,SAASlB,EAAcmB,EAASC,EAAcC,EAAgBC,EAAgBf,GAC3FN,EAAW3B,KAAKP,KAAM,iBAAkBiC,GAKxCjC,KAAKoD,QAAUA,EAKfpD,KAAKwD,cAA6BC,IAAjBJ,EAA8BA,EAAe,IAK9DrD,KAAK0D,gBAAiCD,IAAnBH,EAAgCA,EAAiB,IAKpEtD,KAAK2D,gBAAiCF,IAAnBF,EAAgCA,EAAiB,IAKpEvD,KAAKyC,UAAYD,GAGnB7B,OAAAG,EAAA,EAAAH,CAASwC,EAAQjB,GACjB,IAAA0B,EAAA,ECtCMC,EAAS,SAAS5B,GACtBC,EAAW3B,KAAKP,KAAM,iBAAkBiC,IAG1CtB,OAAAG,EAAA,EAAAH,CAASkD,EAAQ3B,GACjB,ICJM4B,EAAW,SAAS7B,EAAcM,GACtCG,EAAiBnC,KAAKP,KAAM,qBAAsBiC,EAAcM,IAGlE5B,OAAAG,EAAA,EAAAH,CAASmD,EAAUpB,GACnB,ICLMqB,EAAoB,SAAS9B,EAAcM,GAC/CG,EAAiBnC,KAAKP,KAAM,8BAA+BiC,EAAcM,IAG3E5B,OAAAG,EAAA,EAAAH,CAASoD,EAAmBrB,GAC5B,ICNMsB,EAAM,SAASC,GAEnB7D,EAAOG,KAAKP,KAAM,OAKlBA,KAAKiE,UAAYA,GAGnBtD,OAAAG,EAAA,EAAAH,CAASqD,EAAK5D,GACd,ICTM8D,EAAa,SAASjC,EAAcM,EAAYC,GACpDE,EAAiBnC,KAAKP,KAAM,uBAAwBiC,EAAcM,EAAYC,IAGhF7B,OAAAG,EAAA,EAAAH,CAASuD,EAAYxB,GACrB,ICPMyB,EAAK,SAAS7D,GAClBW,IAAMC,GAAU,MAAMC,OAAOX,MAAMN,UAAUO,MAAMF,KAAKG,YACxDK,EAAYK,MAAMpB,KAAMkB,IAG1BP,OAAAG,EAAA,EAAAH,CAASwD,EAAIpD,GACb,ICFMqD,EAAS,SAAS7C,EAAcM,EAAUJ,GAE9CK,EAAQvB,KAAKP,KAAM,SAAUuB,EAAcM,EAAUJ,IAIvDd,OAAAG,EAAA,EAAAH,CAASyD,EAAQtC,GCIV,SAASuC,EAAI/D,GAClBW,IAAMC,GAAU,MAAMC,OAAOX,MAAMN,UAAUO,MAAMF,KAAKG,YACxD,OAAO,IAAK4D,SAASpE,UAAUqE,KAAKnD,MAAMC,EAAKH,6HCJ3CsD,GAAiBC,EAAA,EACnB,8EAgBEC,GAAO,SAASC,GACpB1D,IAAM2D,EACDD,MAELF,EAAA,EAAQlE,KAAKP,KAAM4E,GAMnB5E,KAAK6E,cAA+BpB,IAApBmB,EAAQE,SAAwBF,EAAQE,QAMxD9E,KAAK+E,YAA2BtB,IAAlBmB,EAAQI,OAAsBJ,EAAQI,MAMpDhF,KAAKiF,iBAAqCxB,IAAvBmB,EAAQM,YACzBN,EAAQM,WAMVlF,KAAKmF,mBAAyC1B,IAAzBmB,EAAQQ,cAC3BR,EAAQQ,aAKVpF,KAAKqF,eAAiBT,EAAQS,eAC5BT,EAAQS,eAAiBb,GAM3BxE,KAAKsF,UAAwB7B,IAAjBmB,EAAQU,MAClBV,EAAQU,MAIZ3E,OAAAG,EAAA,EAAAH,CAAS+D,GAAMD,EAAA,GASfC,GAAKxE,UAAUqF,gBAAkB,SAASC,EAAMC,GAE9CxE,IAAMyE,EAAc/E,OAAAgF,EAAA,EAAAhF,IAClBX,KAAK4F,oBAAqBJ,EAAMC,EAAazF,MAC/C,GAAI0F,EAAa,CACfzE,IAAM4E,EAAkB,IAAIC,EAAA,EAAgB,MAE5C,OADAD,EAAgBE,eAAeL,GACxBG,IAaXnB,GAAKxE,UAAU8F,kBAAoB,SAASR,EAAMC,GAEhDxE,IAAMgF,EAAWtF,OAAAgF,EAAA,EAAAhF,IACfX,KAAKkG,sBAAuBV,EAAMC,EAAazF,MACjD,GAAIiG,EAAU,CACZhF,IAAMkF,EAAe,IAAIC,EAAA,EAAa,MAEtC,OADAD,EAAaE,YAAYJ,GAClBE,IAYXzB,GAAKxE,UAAUoG,mBAAqB,SAASd,EAAMC,GACjD9E,OAAAgF,EAAA,EAAAhF,CAAUX,KAAKuG,qBAAsBf,EAAMC,EAAazF,OAS1D0E,GAAKxE,UAAUsG,qBAAuB,SAAShB,EAAMC,GACnD9E,OAAAgF,EAAA,EAAAhF,CAAUX,KAAKyG,uBACbjB,EAAMC,EAAazF,OAUvB0E,GAAKxE,UAAUwG,WAAa,SAASlB,EAAMC,GACzC,OAAO9E,OAAAgF,EAAA,EAAAhF,EAAiB,MACtBX,KAAK2G,iBAAkBnB,EAAMC,EAAazF,OAU9C0E,GAAKxE,UAAU0G,aAAe,SAASpB,EAAMC,GAC3C,OAAO9E,OAAAgF,EAAA,EAAAhF,EAAiB,MACtBX,KAAK6G,kBAAmBrB,EAAMC,EAAazF,OAU/C0E,GAAKxE,UAAU4G,kBAAoB,SAAStB,EAAMC,GAChD,OAAO9E,OAAAgF,EAAA,EAAAhF,EAAiB,MACtBX,KAAK+G,2BAA4BvB,EAAMC,EAAazF,OAUxD0E,GAAKxE,UAAU8G,uBAAyB,SAASxB,EAAMC,GACrD,OAAO9E,OAAAgF,EAAA,EAAAhF,EAAiB,MACtBX,KAAKiH,mCACLzB,EAAMC,EAAazF,OASvB0E,GAAKxE,UAAUgH,gBAAkB,SAAS1B,EAAMC,GAE9CxE,IAAMkG,EAAiBxG,OAAAgF,EAAA,EAAAhF,MAAgB8C,EACrCzD,KAAKoH,aAAc5B,EAAMC,EAAazF,MACpCmH,GAEG1B,EAAYA,EAAY5E,OAAS,GACtBwG,KAAKF,IAUzBzC,GAAKxE,UAAUoH,gBAAkB,SAAS9B,EAAMC,GAE9CxE,IAAMkG,EAAiBxG,OAAAgF,EAAA,EAAAhF,MAAgB8C,EACrCzD,KAAKoH,aAAc5B,EAAMC,EAAazF,MACpCmH,IAEG1B,EAAYA,EAAY5E,OAAS,GACtB,GAAKsG,IAWzBzC,GAAKxE,UAAUqH,aAAe,SAAS/B,EAAMC,GAE3CxE,IAAMuG,EAAkB7G,OAAAgF,EAAA,EAAAhF,EAAiB,MACvCX,KAAKyH,iBAAkBjC,EAAMC,EAAazF,MAC5C,GAAIwH,GAAmBA,EAAgB,GAAI,CACzCvG,IAGIyG,EAAGC,EAHDC,EAAU,IAAIC,EAAA,EAAQ,MACtBC,EAAkBN,EAAgB,GAClCO,GAAQD,EAAgBjH,QAE9B,IAAK6G,EAAI,EAAGC,EAAKH,EAAgB3G,OAAQ6G,EAAIC,IAAMD,EACjD/G,OAAAqH,EAAA,EAAArH,CAAOmH,EAAiBN,EAAgBE,IACxCK,EAAKV,KAAKS,EAAgBjH,QAI5B,OAFA+G,EAAQK,mBACNC,EAAA,EAAeC,IAAKL,EAAiBC,GAChCH,IAaXlD,GAAKxE,UAAUkI,WAAa,SAAS5C,EAAMC,GAEzCxE,IAAM6G,EAAkBnH,OAAAgF,EAAA,EAAAhF,EAAiB,MACvCX,KAAKqI,eAAgB7C,EAAMC,EAAazF,MAC1C,GAAI8H,EAAiB,CACnB7G,IAAMqH,EAAa,IAAIC,EAAA,EAAW,MAElC,OADAD,EAAWL,mBAAmBC,EAAA,EAAeC,IAAKL,GAC3CQ,IAaX5D,GAAKxE,UAAUsI,cAAgB,SAAShD,EAAMC,GAE5CxE,IAAM6G,EAAkBnH,OAAAgF,EAAA,EAAAhF,EAAiB,MACvCX,KAAKyI,kBAAmBjD,EAAMC,EAAazF,MAC7C,OAAOW,OAAA+H,EAAA,EAAA/H,CAAemH,EAAgB,GAAG,GACvCA,EAAgB,GAAG,GAAIA,EAAgB,GAAG,GAC1CA,EAAgB,GAAG,KAUvBpD,GAAKxE,UAAUyI,aAAe,SAASnD,EAAMC,GAM3C,IALAmD,IAIIC,EAJAC,EAAInI,OAAAgF,EAAA,EAAAhF,CAAkB6E,GAAM,GAC1BuD,EAAK,6CAELjB,KAEEe,EAAIE,EAAGC,KAAKF,IAClBhB,EAAgBT,KAAK4B,WAAWJ,EAAE,KAClCC,EAAIA,EAAEI,OAAOL,EAAE,GAAGhI,QAEpB,GAAU,KAANiI,EAAJ,CAGA7H,IAQMyG,EAAGC,EAPHwB,EADU1D,EAAY,GACU,QAClC2D,EAAkB,MACtB,GAAID,EAEFC,EADazI,OAAA0I,EAAA,EAAA1I,CAAcwI,GACJG,qBAEzB,GAAwB,QAApBF,EAEF,IAAK1B,EAAI,EAAGC,EAAKG,EAAgBjH,OAAQ6G,EAAIC,EAAID,GAAK,EAAG,CACvDzG,IAAMsI,EAAIzB,EAAgBJ,GACpB8B,EAAI1B,EAAgBJ,EAAI,GAC9BI,EAAgBJ,GAAK8B,EACrB1B,EAAgBJ,EAAI,GAAK6B,EAG7BtI,IAAMwI,EAAM3B,EAAgBjH,OAI5B,GAHW,GAAP4I,GACF3B,EAAgBT,KAAK,GAEX,IAARoC,EAGJ,OAAO3B,IAUTpD,GAAKxE,UAAUwJ,iBAAmB,SAASlE,EAAMC,GAC/CxE,IAAM6H,EAAInI,OAAAgF,EAAA,EAAAhF,CAAkB6E,GAAM,GAAOmE,QAAQ,aAAc,IACzDC,EAAUnE,EAAY,GACtB0D,EAAeS,EAAiB,QAChCC,EAAmBD,EAAsB,aAC3CR,EAAkB,MAClBD,IAEFC,EADazI,OAAA0I,EAAA,EAAA1I,CAAcwI,GACJG,sBAEzBrI,IAeIuI,EAAGD,EAAGO,EAfJC,EAASjB,EAAEkB,MAAM,OAEnBC,EAAM,EACNzE,EAAK0E,aAAa,gBACpBD,EAAMtJ,OAAAwJ,EAAA,EAAAxJ,CACJ6E,EAAK0E,aAAa,iBACX1E,EAAK0E,aAAa,aAC3BD,EAAMtJ,OAAAwJ,EAAA,EAAAxJ,CACJ6E,EAAK0E,aAAa,cACX1E,EAAK4E,WAAWF,aAAa,gBACtCD,EAAMtJ,OAAAwJ,EAAA,EAAAxJ,CACJ6E,EAAK4E,WAAWF,aAAa,iBACtBL,IACTI,EAAMtJ,OAAAwJ,EAAA,EAAAxJ,CAA6BkJ,IAIrC,IADA5I,IAAM6G,KACGJ,EAAI,EAAGC,EAAKoC,EAAOlJ,OAAQ6G,EAAIC,EAAID,GAAKuC,EAC/CT,EAAIP,WAAWc,EAAOrC,IACtB6B,EAAIN,WAAWc,EAAOrC,EAAI,IAC1BoC,EAAa,IAARG,EAAahB,WAAWc,EAAOrC,EAAI,IAAM,EACT,OAAjC0B,EAAgBF,OAAO,EAAG,GAC5BpB,EAAgBT,KAAKmC,EAAGD,EAAGO,GAE3BhC,EAAgBT,KAAKkC,EAAGC,EAAGM,GAG/B,OAAOhC,GASTpD,GAAKxE,UAAU+G,oCACboD,8BACEC,IAAO3J,OAAAgF,EAAA,EAAAhF,CAAa+D,GAAKxE,UAAUyI,cACnC4B,QAAW5J,OAAAgF,EAAA,EAAAhF,CAAa+D,GAAKxE,UAAUwJ,oBAU3ChF,GAAKxE,UAAU6G,4BACbsD,8BACEG,SAAY9F,GAAKxE,UAAUgH,gBAC3BuD,SAAY/F,GAAKxE,UAAUoH,kBAU/B5C,GAAKxE,UAAUwK,mBACbL,8BACEM,MAAShK,OAAAgF,EAAA,EAAAhF,CAAa8D,EAAA,EAAQvE,UAAU0K,WACxCC,WAAclK,OAAAgF,EAAA,EAAAhF,CACZ8D,EAAA,EAAQvE,UAAU4K,gBACpBvC,WAAc5H,OAAAgF,EAAA,EAAAhF,CACZ8D,EAAA,EAAQvE,UAAU6K,gBACpBjF,gBAAmBnF,OAAAgF,EAAA,EAAAhF,CACjB8D,EAAA,EAAQvE,UAAU8K,qBACpBC,WAActK,OAAAgF,EAAA,EAAAhF,CACZ8D,EAAA,EAAQvE,UAAUgL,gBACpBrD,QAAWlH,OAAAgF,EAAA,EAAAhF,CAAa8D,EAAA,EAAQvE,UAAUiL,aAC1C/E,aAAgBzF,OAAAgF,EAAA,EAAAhF,CACd8D,EAAA,EAAQvE,UAAUkL,kBACpBC,QAAW1K,OAAAgF,EAAA,EAAAhF,CAAa+D,GAAKxE,UAAUqH,cACvC+D,aAAgB3K,OAAAgF,EAAA,EAAAhF,CACd+D,GAAKxE,UAAU8F,mBACjBuF,MAAS5K,OAAAgF,EAAA,EAAAhF,CAAa+D,GAAKxE,UAAUkI,YACrCoD,WAAc7K,OAAAgF,EAAA,EAAAhF,CACZ+D,GAAKxE,UAAUqF,iBACjBkG,SAAY9K,OAAAgF,EAAA,EAAAhF,CAAa+D,GAAKxE,UAAUsI,iBAU5C9D,GAAKxE,UAAU0F,qBACbyE,8BACEqB,YAAe/K,OAAAgF,EAAA,EAAAhF,CACb+D,GAAKxE,UAAUoG,oBACjBqF,aAAgBhL,OAAAgF,EAAA,EAAAhF,CACd+D,GAAKxE,UAAUoG,sBAUrB5B,GAAKxE,UAAUgG,uBACbmE,8BACEuB,cAAiBjL,OAAAgF,EAAA,EAAAhF,CACf+D,GAAKxE,UAAUsG,sBACjBqF,eAAkBlL,OAAAgF,EAAA,EAAAhF,CAChB+D,GAAKxE,UAAUsG,wBAUrB9B,GAAKxE,UAAUqG,sBACb8D,8BACE9B,WAAc5H,OAAAgF,EAAA,EAAAhF,CACZ8D,EAAA,EAAQvE,UAAU6K,gBACpBQ,MAAS5K,OAAAgF,EAAA,EAAAhF,CAAgB+D,GAAKxE,UAAUkI,cAU5C1D,GAAKxE,UAAUuG,wBACb4D,8BACExC,QAAWlH,OAAAgF,EAAA,EAAAhF,CAAgB8D,EAAA,EAAQvE,UAAUiL,aAC7CE,QAAW1K,OAAAgF,EAAA,EAAAhF,CAAgB+D,GAAKxE,UAAUqH,gBAU9C7C,GAAKxE,UAAUuH,kBACb4C,8BACEyB,QAAWnL,OAAAgF,EAAA,EAAAhF,CAAa+D,GAAKxE,UAAUwG,cAU3ChC,GAAKxE,UAAUmI,gBACbgC,8BACE0B,SAAYpL,OAAAgF,EAAA,EAAAhF,CAAa+D,GAAKxE,UAAU0G,gBAU5ClC,GAAKxE,UAAUuI,mBACb4B,8BACE2B,YAAerL,OAAAgF,EAAA,EAAAhF,CACb+D,GAAKxE,UAAUwJ,kBACjBuC,YAAetL,OAAAgF,EAAA,EAAAhF,CACb+D,GAAKxE,UAAUwJ,oBAUrBhF,GAAKxE,UAAUyG,kBACb0D,8BACE6B,aAAgBvL,OAAAgF,EAAA,EAAAhF,CACd+D,GAAKxE,UAAU4G,qBAUrBpC,GAAKxE,UAAU2G,mBACbwD,8BACE8B,kBAAqBxL,OAAAgF,EAAA,EAAAhF,CACnB+D,GAAKxE,UAAU8G,0BAWrBtC,GAAKxE,UAAUkM,UAAY,SAAS5G,EAAM6G,EAAO5G,GAC/CxE,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3CyE,EAAOsE,EAAc,KACrB0C,EAAehH,EAAO,EAAI,EAChCE,EAAK+G,aAAa,eAAgBD,GAClCrL,IAAMS,EAAUkI,EAAiB,QAC7BR,EAAkB,MAClB1H,IACF0H,EAAkBzI,OAAA0I,EAAA,EAAA1I,CAAce,GAAS4H,sBAE3CrI,IACI8I,EADEyC,EAAQH,EAAMI,kBAIlB1C,EADmC,OAAjCX,EAAgBF,OAAO,EAAG,GAClBsD,EAAM,GAAK,IAAMA,EAAM,GAEvBA,EAAM,GAAK,IAAMA,EAAM,GAE/BlH,KAGFyE,GAAU,KADAyC,EAAM,IAAM,IAGxB7L,OAAAwJ,EAAA,EAAAxJ,CAAoB6E,EAAMuE,IAW5BrF,GAAKxE,UAAUwM,WAAa,SAASF,EAAO/K,EAAakL,GACvD/D,IAAIQ,EAAkB,MAClB3H,IACF2H,EAAkBzI,OAAA0I,EAAA,EAAA1I,CAAcc,GAAa6H,sBAE/CV,IAAImB,EAA4C,OAAjCX,EAAgBF,OAAO,EAAG,GACvCsD,EAAM,GAAK,IAAMA,EAAM,GACvBA,EAAM,GAAK,IAAMA,EAAM,GACrBG,IAGF5C,GAAU,KADAyC,EAAM,IAAM,IAIxB,OAAOzC,GAUTrF,GAAKxE,UAAU0M,cAAgB,SAASpH,EAAM6G,EAAO5G,OAC7CmE,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3CyE,EAAOsE,EAAc,KACrB0C,EAAehH,EAAO,EAAI,EAChCE,EAAK+G,aAAa,eAAgBD,GAOlC,IANArL,IAKIuL,EALE9K,EAAUkI,EAAiB,QAE3BiD,EAASR,EAAMI,iBACfhD,EAAMoD,EAAOhM,OACbiM,EAAQ,IAAItM,MAAMiJ,GAEf/B,EAAI,EAAGA,EAAI+B,IAAO/B,EACzB8E,EAAQK,EAAOnF,GACfoF,EAAMpF,QAAUgF,WAAWF,EAAO9K,EAAS4D,GAE7C3E,OAAAwJ,EAAA,EAAAxJ,CAAoB6E,EAAMsH,EAAMC,KAAK,OAUvCrI,GAAKxE,UAAU8M,YAAc,SAASxH,EAAM3D,EAAU4D,GACpDxE,IACMS,EADU+D,EAAYA,EAAY5E,OAAS,GAChB,QAC7Ba,GACF8D,EAAK+G,aAAa,UAAW7K,GAE/BT,IAAMqJ,EAAM3J,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aAAc,OAC/CzH,EAAK0H,YAAY5C,GACjBtK,KAAKoM,UAAU9B,EAAKzI,EAAU4D,IAShCf,GAAKxE,UAAUiN,cAAgB,SAAS3H,EAAMhE,EAAQiE,GACpDxE,IACMS,EADU+D,EAAYA,EAAY5E,OAAS,GAChB,QAC7Ba,GACF8D,EAAK+G,aAAa,UAAW7K,GAE/BT,IACMmM,GAAU5L,EAAO,GAAK,IAAMA,EAAO,GAAIA,EAAO,GAAK,IAAMA,EAAO,IACtEb,OAAAgF,EAAA,EAAAhF,EACI6E,KAAMA,GAAQxF,KAAKqN,sBACrB1H,EAAA,EACAyH,EACA3H,GANY,cAAe,eAMRzF,OAUvB0E,GAAKxE,UAAUoN,iBAAmB,SAAS9H,EAAM3D,EAAU4D,GACzDxE,IACMS,EADU+D,EAAYA,EAAY5E,OAAS,GAChB,QAC7Ba,GACF8D,EAAK+G,aAAa,UAAW7K,GAE/BT,IAAMsJ,EAAU5J,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aAAc,WACnDzH,EAAK0H,YAAY3C,GACjBvK,KAAK4M,cAAcrC,EAAS1I,EAAU4D,IAWxCf,GAAKxE,UAAUqN,mBAAqB,SAASlB,EAAO5G,EAAa+H,GAC/DvM,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3CuJ,EAAaR,EAAQpE,KACrBiI,EAAkB7D,EAAyB,gBAIjD,YAHwBnG,IAApBgK,IACF7D,EAAyB,iBAAI,GAExBjJ,OAAAgF,EAAA,EAAAhF,CAAgByJ,EAAW6C,kBACZxJ,IAApBgK,EAAgC,WAAa,aAUjD/I,GAAKxE,UAAUwN,uBAAyB,SAASlI,EAAM3D,EAAU4D,GAC/DxE,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3CyE,EAAOsE,EAAc,KACrBlI,EAAUkI,EAAiB,QAIjC,GAHsB,iBAAlBpE,EAAKmI,UAA+BjM,GACtC8D,EAAK+G,aAAa,UAAW7K,GAET,YAAlB8D,EAAKmI,UAA4C,iBAAlBnI,EAAKmI,SAA6B,CACnE1M,IAAM2M,EAAQ/L,EAASgM,iBACvBlN,OAAAgF,EAAA,EAAAhF,EACG6E,KAAMA,EAAMF,KAAMA,EAAM5D,QAASA,GAClC1B,KAAK8N,kBACL9N,KAAKuN,mBACLK,EAAOnI,OAAahC,EAAWzD,WAC5B,GAAsB,YAAlBwF,EAAKmI,SAAwB,CACtC1M,IAAM6K,EAAUnL,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aAAc,WACnDzH,EAAK0H,YAAYpB,GACjB9L,KAAK+N,qBACHjC,EAASjK,EAAU4D,KAWzBf,GAAKxE,UAAU8N,wBAA0B,SAASxI,EAAM3D,EAAU4D,GAChExE,IACMS,EADU+D,EAAYA,EAAY5E,OAAS,GAChB,QAIjC,GAHsB,sBAAlB2E,EAAKmI,UAAoCjM,GAC3C8D,EAAK+G,aAAa,UAAW7K,GAET,eAAlB8D,EAAKmI,UACa,sBAAlBnI,EAAKmI,SAAkC,CACzC1M,IAAMsJ,EAAU5J,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aAAc,WACnDzH,EAAK0H,YAAY3C,GACjBvK,KAAK4M,cAAcrC,EAAS1I,EAAU4D,QACjC,GAAsB,UAAlBD,EAAKmI,SAAsB,CACpC1M,IAAM8K,EAAWpL,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aAAc,YACpDzH,EAAK0H,YAAYnB,GACjB/L,KAAKiO,oBAAoBlC,EACvBlK,EAAU4D,KAWhBf,GAAKxE,UAAUgO,4BAA8B,SAAS1I,EAAM3D,EAAU4D,GACpExE,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3CyE,EAAOsE,EAAc,KACrBlI,EAAUkI,EAAiB,QAC3B9E,EAAU8E,EAAiB,QAC7BlI,GACF8D,EAAK+G,aAAa,UAAW7K,GAE/BT,IAAMgF,EAAWpE,EAASsM,cAC1BxN,OAAAgF,EAAA,EAAAhF,EAAqB6E,KAAMA,EAAMF,KAAMA,EAAM5D,QAASA,EAASoD,QAASA,GACtE9E,KAAKoO,oCACLpO,KAAKqO,mCAAoCpI,EACzCR,OAAahC,EAAWzD,OAU5B0E,GAAKxE,UAAUoO,iBAAmB,SAAS9I,EAAM3D,EAAU4D,GACzDxE,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3Ca,EAAUkI,EAAiB,QAC3BtE,EAAOsE,EAAc,KACvBlI,GACF8D,EAAK+G,aAAa,UAAW7K,GAE/BT,IAAM4L,EAAShL,EAAS0M,YACxB5N,OAAAgF,EAAA,EAAAhF,EAAqB6E,KAAMA,EAAMF,KAAMA,EAAM5D,QAASA,GACpD1B,KAAKwO,yBACL7N,OAAAgF,EAAA,EAAAhF,CAAsB,eAAgBkM,EACtCpH,OAAahC,EAAWzD,OAU5B0E,GAAKxE,UAAUuO,6BAA+B,SAASjJ,EAAM3D,EAAU4D,GACrExE,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3CyE,EAAOsE,EAAc,KACrBlI,EAAUkI,EAAiB,QAC3B5E,EAAQ4E,EAAe,MACzBlI,GACF8D,EAAK+G,aAAa,UAAW7K,GAE/BT,IAAMyN,EAAQ7M,EAAS8M,iBACvBhO,OAAAgF,EAAA,EAAAhF,EAAqB6E,KAAMA,EAAMF,KAAMA,EAAM5D,QAASA,EAASsD,MAAOA,GACpEhF,KAAK4O,qCACL5O,KAAKqO,mCAAoCK,EACzCjJ,OAAahC,EAAWzD,OAU5B0E,GAAKxE,UAAU2O,WAAa,SAASrJ,EAAMsJ,EAAMrJ,GAC/CxE,IAAM8N,EAAapO,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aAAc,cACtDzH,EAAK0H,YAAY6B,GACjB/O,KAAKsN,iBAAiByB,EAAYD,EAAMrJ,IAU1Cf,GAAKxE,UAAU8O,6BAA+B,SAASxJ,EAAMoC,EAASnC,GACpExE,IAAMgO,EAAQjP,KAAKkP,uBACjBtH,EAASnC,GACPwJ,IACFzJ,EAAK0H,YAAY+B,GACjBjP,KAAK0N,uBAAuBuB,EAAOrH,EAASnC,KAWhDf,GAAKxE,UAAUiP,kBAAoB,SAAS3J,EAAMgH,EAAO/G,GACvDxE,IAAMgO,EAAQtO,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aAAc,SACjDzH,EAAK0H,YAAY+B,GACjBjP,KAAKgN,YAAYiC,EAAOzC,EAAO/G,IAUjCf,GAAKxE,UAAUkP,8BAAgC,SAAS5J,EAAM6J,EAAM5J,GAClExE,IAAMgO,EAAQjP,KAAKkP,uBAAuBG,EAAM5J,GAC5CwJ,IACFzJ,EAAK0H,YAAY+B,GACjBjP,KAAKgO,wBAAwBiB,EAAOI,EAAM5J,KAW9Cf,GAAKxE,UAAU6N,qBAAuB,SAASvI,EAAMoC,EAASnC,GAC5DxE,IAAMgO,EAAQtO,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aAAc,gBACjDzH,EAAK0H,YAAY+B,GACjBjP,KAAK0N,uBAAuBuB,EAAOrH,EAASnC,IAU9Cf,GAAKxE,UAAU+N,oBAAsB,SAASzI,EAAM6J,EAAM5J,GACxDxE,IAAMgO,EAAQtO,OAAAgF,EAAA,EAAAhF,CAAgB6E,EAAKyH,aACjC,qBACFzH,EAAK0H,YAAY+B,GACjBjP,KAAKgO,wBAAwBiB,EAAOI,EAAM5J,IAS5Cf,GAAKxE,UAAUoP,qBAAuB,SAAS9J,EAAM3D,EAAU4D,GAC7DxE,IAGIoL,EAHEzC,EAAgEnE,EAAYA,EAAY5E,OAAS,GACjG0O,EAAO5O,OAAA6O,EAAA,EAAA7O,IAAWiJ,GACxB2F,EAAK/J,KAAOA,EAIR6G,EAFA7L,MAAMiP,QAAQ5N,GACZ+H,EAAQ8F,eACF/O,OAAA0I,EAAA,EAAA1I,CACNkB,EAAU+H,EAAQ+F,kBAAmB/F,EAAQ8F,gBAEvC7N,EAGFlB,OAAAiP,EAAA,EAAAjP,CAA4D,GAAY,EAAMiJ,GAExFjJ,OAAAgF,EAAA,EAAAhF,CACE,EAAQX,KAAK6P,sBACb7P,KAAKkP,wBAAyB7C,GAC9B5G,OAAahC,EAAWzD,OAS5B0E,GAAKxE,UAAU4P,oBAAsB,SAAStK,EAAMuK,EAAStK,OACrDuK,EAAMD,EAAQE,QAChBD,GACFxK,EAAK+G,aAAa,MAAOyD,GAE3B/O,IAAM2I,EAAiCnE,EAAYA,EAAY5E,OAAS,GAClEqP,EAAYtG,EAAmB,UAC/BrI,EAAewO,EAAQI,kBACxBvG,EAAQwG,cACXxG,EAAQwG,eACRxG,EAAQwG,YAAYF,OAEtBjP,IAAMoP,EAAaN,EAAQO,gBACrBC,KACAnD,KACN,IAAKnM,IAAMuP,KAAOH,EAAY,CAC5BpP,IAAMoL,EAAQgE,EAAWG,GACX,OAAVnE,IACFkE,EAAKlJ,KAAKmJ,GACVpD,EAAO/F,KAAKgF,GACRmE,GAAOjP,GAAgB8K,aAAiBoE,EAAA,EACpCD,KAAO5G,EAAQwG,YAAYF,KAC/BtG,EAAQwG,YAAYF,GAAWM,GAAO7P,OAAAgF,EAAA,EAAAhF,MAC/B2O,4BAGHkB,KAAO5G,EAAQwG,YAAYF,KAC/BtG,EAAQwG,YAAYF,GAAWM,GAAO7P,OAAAgF,EAAA,EAAAhF,CAAkBwJ,EAAA,KAKhElJ,IAAMsO,EAAO5O,OAAA6O,EAAA,EAAA7O,IAAWiJ,GACxB2F,EAAK/J,KAAOA,EACZ7E,OAAAgF,EAAA,EAAAhF,CACE,EAAQiJ,EAAQwG,YAChBzP,OAAAgF,EAAA,EAAAhF,MAAsB8C,EAAWyM,GACjC9C,EACA3H,EAAa8K,IAUjB7L,GAAKxE,UAAUwQ,qBAAuB,SAASlL,EAAMmL,EAAUlL,GAC7DxE,IAAM2I,EAAiCnE,EAAYA,EAAY5E,OAAS,GAClE+P,EAAchH,EAAqB,YACnCsG,EAAYtG,EAAmB,UAC/BwG,KACNA,EAAYF,MACZE,EAAYF,GAAWU,GAAejQ,OAAAgF,EAAA,EAAAhF,CACpCX,KAAK8P,oBAAqB9P,MAC5BiB,IAAMsO,EAAO5O,OAAA6O,EAAA,EAAA7O,IAAWiJ,GACxB2F,EAAK/J,KAAOA,EACZ7E,OAAAgF,EAAA,EAAAhF,CACE,EACAyP,EACAzP,OAAAgF,EAAA,EAAAhF,CAAsBiQ,EAAaV,GAAYS,EAC/ClL,IAQJxE,IAAM4P,IACJ/K,gBAAmB,mBACnB0F,WAAc,cACdpF,aAAgB,gBAChBkF,aAAgB,iBAYlB5G,GAAKxE,UAAUmO,mCAAqC,SAAShC,EAAO5G,EAAa+H,GAC/EvM,IAAMmJ,EAAa3E,EAAYA,EAAY5E,OAAS,GAAG2E,KACvD,OAAO7E,OAAAgF,EAAA,EAAAhF,CAAgB,6BACrBkQ,GAAiCzG,EAAWuD,YAYhDjJ,GAAKxE,UAAUgP,uBAAyB,SAAS7C,EAAO5G,EAAa+H,GACnEvM,IAKI0M,EALE/D,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3CuE,EAAewE,EAAsB,aACrC9E,EAAU8E,EAAiB,QAC3B5E,EAAQ4E,EAAe,MACvB1E,EAAa0E,EAAoB,WAgBvC,OAdKpJ,MAAMiP,QAAQpD,GAYjBsB,EAAW,WAVM,kBADjBA,EAAkD,EAAQmD,aACN,IAAjB1L,EACjCuI,EAAW,eACW,YAAbA,IAAsC,IAAZ7I,EACnC6I,EAAW,UACW,eAAbA,IAAuC,IAAV3I,EACtC2I,EAAW,QACW,oBAAbA,IAAiD,IAAfzI,IAC3CyI,EAAW,cAKRhN,OAAAgF,EAAA,EAAAhF,CAAgB,6BACrBgN,IAaJjJ,GAAKxE,UAAU6Q,kBAAoB,SAASlP,EAAU8C,GACpDA,EAAc3E,KAAKgR,aAAarM,GAChC1D,IAAMgQ,EAAOtQ,OAAAgF,EAAA,EAAAhF,CAAgB,6BAA8B,QACrDiJ,GAAWpE,KAAMyL,EAAM3L,KAAMtF,KAAKsF,KAAM5D,QAAS1B,KAAK0B,QAC1DsD,MAAOhF,KAAK+E,OAAQD,QAAS9E,KAAK6E,SAClCO,aAAcpF,KAAKmF,cAAeD,WAAYlF,KAAKiF,aAKrD,OAJIN,GACFhE,OAAA6O,EAAA,EAAA7O,CAAOiJ,EAASjF,GAElB3E,KAAKsP,qBAAqB2B,EAAMpP,GAAW+H,IACpCqH,GAaTvM,GAAKxE,UAAUgR,cAYfxM,GAAKxE,UAAUiR,kBAAoB,SAASR,EAAUhM,GACpDA,EAAc3E,KAAKgR,aAAarM,GAChC1D,IAAMuE,EAAO7E,OAAAgF,EAAA,EAAAhF,CAAgB,6BAA8B,kBAC3D6E,EAAK4L,eAAezL,EAAA,EAAyB,qBAAsB3F,KAAKqF,gBACxEpE,IAAM2I,GACJlI,QAAS1B,KAAK0B,QACd4D,KAAMtF,KAAKsF,KACXN,MAAOhF,KAAK+E,OACZD,QAAS9E,KAAK6E,SACdO,aAAcpF,KAAKmF,cACnBD,WAAYlF,KAAKiF,YACjBiL,UAAWlQ,KAAKkQ,UAChBU,YAAa5Q,KAAK4Q,aAMpB,OAJIjM,GACFhE,OAAA6O,EAAA,EAAA7O,CAAOiJ,EAASjF,GAElB3E,KAAK0Q,qBAAqBlL,EAAMmL,GAAW/G,IACpCpE,GAQTd,GAAKxE,UAAU4N,mBACbzD,8BACEI,SAAY9J,OAAAgF,EAAA,EAAAhF,CAAkB+D,GAAKxE,UAAU2O,YAC7CrE,SAAY7J,OAAAgF,EAAA,EAAAhF,CAAkB+D,GAAKxE,UAAU2O,cASjDnK,GAAKxE,UAAUmN,uBACbhD,8BACE2B,YAAerL,OAAAgF,EAAA,EAAAhF,CAAkBwJ,EAAA,GACjC8B,YAAetL,OAAAgF,EAAA,EAAAhF,CAAkBwJ,EAAA,KASrCzF,GAAKxE,UAAUkO,qCACb/D,8BACEuB,cAAiBjL,OAAAgF,EAAA,EAAAhF,CACf+D,GAAKxE,UAAU8O,8BACjBqC,cAAiB1Q,OAAAgF,EAAA,EAAAhF,CACf+D,GAAKxE,UAAU8O,gCASrBtK,GAAKxE,UAAUsO,0BACbnE,8BACEiH,YAAe3Q,OAAAgF,EAAA,EAAAhF,CACb+D,GAAKxE,UAAUiP,qBASrBzK,GAAKxE,UAAU0O,sCACbvE,8BACEkH,iBAAoB5Q,OAAAgF,EAAA,EAAAhF,CAClB+D,GAAKxE,UAAUkP,+BACjB1D,YAAe/K,OAAAgF,EAAA,EAAAhF,CACb+D,GAAKxE,UAAUkP,iCASrB1K,GAAKxE,UAAU2P,uBACbxF,8BACEkB,MAAS5K,OAAAgF,EAAA,EAAAhF,CACP+D,GAAKxE,UAAU8N,yBACjBxC,WAAc7K,OAAAgF,EAAA,EAAAhF,CACZ+D,GAAKxE,UAAUuO,8BACjB9D,MAAShK,OAAAgF,EAAA,EAAAhF,CAAkB+D,GAAKxE,UAAU8M,aAC1CnC,WAAclK,OAAAgF,EAAA,EAAAhF,CACZ+D,GAAKxE,UAAUoO,kBACjB/F,WAAc5H,OAAAgF,EAAA,EAAAhF,CACZ+D,GAAKxE,UAAU8N,yBACjBlI,gBAAmBnF,OAAAgF,EAAA,EAAAhF,CACjB+D,GAAKxE,UAAUuO,8BACjBxD,WAActK,OAAAgF,EAAA,EAAAhF,CACZ+D,GAAKxE,UAAUoN,kBACjBzF,QAAWlH,OAAAgF,EAAA,EAAAhF,CACT+D,GAAKxE,UAAUwN,wBACjBtH,aAAgBzF,OAAAgF,EAAA,EAAAhF,CACd+D,GAAKxE,UAAUgO,6BACjB7C,QAAW1K,OAAAgF,EAAA,EAAAhF,CACT+D,GAAKxE,UAAUwN,wBACjBpC,aAAgB3K,OAAAgF,EAAA,EAAAhF,CACd+D,GAAKxE,UAAUgO,6BACjBzC,SAAY9K,OAAAgF,EAAA,EAAAhF,CACV+D,GAAKxE,UAAUiN,iBAKrB,IAAAqE,GAAA,YChpCMC,GAAiB,UAMjBC,GAAQ,gCAMRC,GAAQ,6BAMRC,GAAQ,6BAMRC,GAAQ,6BAMRC,IACJC,QAAS,0EACTC,QAAS,2EAuBLC,GAAM,SAAStN,GACnB1D,IAAM2D,EAAUD,MAMhB3E,KAAKkS,aAAetN,EAAQgM,YAM5B5Q,KAAKmS,WAAavN,EAAQsL,UAM1BlQ,KAAKoS,WAAaxN,EAAQyN,UACxBzN,EAAQyN,UAAY,IAAIb,GAM1BxR,KAAKsS,gBAAkB1N,EAAQS,eAC7BT,EAAQS,eAAiByM,GA1CL,SA4CtBS,GAAA,EAAWhS,KAAKP,OAGlBW,OAAAG,EAAA,EAAAH,CAASsR,GAAKM,GAAA,GAMdN,GAAI/R,UAAUsS,eAAiB,WAC7B,OAAOxS,KAAKkS,cAOdD,GAAI/R,UAAUuS,eAAiB,SAAS7B,GACtC5Q,KAAKkS,aAAetB,GAatBqB,GAAI/R,UAAUwS,aAMdT,GAAI/R,UAAUyS,qBAAuB,SAASnN,EAAMb,GAClD1D,IAAM2I,GACJgH,YAAe5Q,KAAKkS,aACpBhC,UAAalQ,KAAKmS,YAEpBxR,OAAA6O,EAAA,EAAA7O,CAAOiJ,EAAS5J,KAAK4S,eAAepN,EAAMb,QAC1C1D,IAAMwE,GAAemE,GACrB5J,KAAKoS,WAAWS,2BAA2BpO,EAAA,GAC1B,cACb9D,OAAAgF,EAAA,EAAAhF,CAAgB8D,EAAA,EAAQvE,UAAU4S,sBACtClK,IAAI+H,EAAWhQ,OAAAgF,EAAA,EAAAhF,IACbX,KAAKoS,WAAWS,2BAA4BrN,EAC5CC,EAAazF,KAAKoS,YAIpB,OAHKzB,IACHA,MAEKA,GAWTsB,GAAI/R,UAAU6S,wBAA0B,SAASC,GAC/C,GAAIrS,OAAAgF,EAAA,EAAAhF,CAAWqS,GACb,OAAOhT,KAAKiT,oCACc,GACrB,GAAItS,OAAAgF,EAAA,EAAAhF,CAAOqS,GAChB,OAAOhT,KAAKkT,gCAAoD,GAC3D,GAAsB,iBAAXF,EAAqB,CACrC/R,IAAMkS,EAAMxS,OAAAgF,EAAA,EAAAhF,CAAMqS,GAClB,OAAOhT,KAAKiT,oCAAoCE,KAepDlB,GAAI/R,UAAUkT,8BAAgC,SAASJ,GACrD,GAAIrS,OAAAgF,EAAA,EAAAhF,CAAWqS,GACb,OAAOhT,KAAKqT,0CACc,GACrB,GAAI1S,OAAAgF,EAAA,EAAAhF,CAAOqS,GAChB,OAAOhT,KAAKsT,sCACU,GACjB,GAAsB,iBAAXN,EAAqB,CACrC/R,IAAMkS,EAAMxS,OAAAgF,EAAA,EAAAhF,CAAMqS,GAClB,OAAOhT,KAAKqT,0CAA0CF,KAY1DlB,GAAI/R,UAAUmT,0CAA4C,SAASF,GACjE,QAASI,EAAIJ,EAAIK,WAAYD,EAAGA,EAAIA,EAAEE,YACpC,GAAIF,EAAEG,UAAYC,KAAKC,aACrB,YAAYN,sCAAsCC,IAWxDtS,IAAM4R,IACJxI,8BACEwJ,UAAalT,OAAAgF,EAAA,EAAAhF,CACX8D,EAAA,EAAQvE,UAAU4T,oBAAqB,YAU7C7B,GAAI/R,UAAUoT,sCAAwC,SAAS9N,GAC7DvE,IAAM8S,KACA1H,EAAQ1L,OAAAwJ,EAAA,EAAAxJ,CACZ6E,EAAK0E,aAAa,qBAEpB,OADA6J,EAAyB,iBAAI1H,EACtB1L,OAAAgF,EAAA,EAAAhF,CACyD,EAC9DkS,GAA4BrN,KAAUxF,KAAKoS,aAQ/CnR,IAAM+S,IACJC,8BACEC,cAAiBvT,OAAAgF,EAAA,EAAAhF,CAAyBwJ,EAAA,GAC1CgK,aAAgBxT,OAAAgF,EAAA,EAAAhF,CAAyBwJ,EAAA,GACzCiK,aAAgBzT,OAAAgF,EAAA,EAAAhF,CAAyBwJ,EAAA,KAoB7ClJ,IAAMoT,IACJC,8BACEC,UAAa5T,OAAAgF,EAAA,EAAAhF,CAAgB,SAAS6E,EAAMC,GAC1C,OAAOD,EAAK0E,aAAa,WAmB/BjJ,IAAMuT,IACJP,8BACErE,QAXJ,SAAmBpK,EAAMC,GACvB9E,OAAAgF,EAAA,EAAAhF,CAAU0T,GAAiB7O,EAAMC,MA8BnCxE,IAAMwT,IACJR,8BACES,mBAAsB/T,OAAAgF,EAAA,EAAAhF,CAxD1B,SAAgC6E,EAAMC,GACpC,OAAO9E,OAAAgF,EAAA,EAAAhF,IACDqT,GAA6BxO,EAAMC,IAuDb,sBAC1BkP,cAAiBhU,OAAAgF,EAAA,EAAAhF,CAdrB,SAA2B6E,EAAMC,GAC/B,OAAO9E,OAAAgF,EAAA,EAAAhF,IACD6T,GAAwBhP,EAAMC,IAab,eASzBwM,GAAI/R,UAAU+S,oCAAsC,SAASE,GAC3D,QAASI,EAAIJ,EAAIK,WAAYD,EAAGA,EAAIA,EAAEE,YACpC,GAAIF,EAAEG,UAAYC,KAAKC,aACrB,YAAYV,gCAAgCK,IAWlDtB,GAAI/R,UAAUgT,gCAAkC,SAAS1N,GACvD,OAAO7E,OAAAgF,EAAA,EAAAhF,IAEL8T,GAA8BjP,OAOlCvE,IAAM2T,IACJX,8BACEY,aAAgBlU,OAAAgF,EAAA,EAAAhF,CAAkBwJ,EAAA,KA8BtC,SAAS2K,GAAkBtP,EAAMwK,EAAKvK,GACpCxE,IAAM8T,EAASpU,OAAAgF,EAAA,EAAAhF,CAAgBgR,GAAO,UAChC1C,EAAQtO,OAAAgF,EAAA,EAAAhF,CAAgBgR,GAAO,aACrCoD,EAAO7H,YAAY+B,GACnBA,EAAM1C,aAAa,MAAOyD,GAC1BxK,EAAK0H,YAAY6H,GASnB,SAASC,GAAYC,EAAerE,GAElC3P,IAAMiU,GADND,EAAgBA,GAAgCxD,IACjB,IAE/B,OAAoC,IAAhCb,EAAYuE,QAAQD,GACftE,EAEAsE,EAAStE,EA6BpB3P,IAAMmU,IACJnB,8BACEoB,OAAU1U,OAAAgF,EAAA,EAAAhF,CAxEd,SAAsB6E,EAAMuK,EAAStK,GACnCxE,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GAC3C+P,EAAchH,EAAqB,YACnCsG,EAAYtG,EAAmB,UAC/B0L,EAAa1L,EAAoB,WACjCqF,EAAQtO,OAAAgF,EAAA,EAAAhF,CAAgBuP,EAAWU,GACzCpL,EAAK0H,YAAY+B,GACE,IAAfqG,EACFC,EAAA,EAAKrV,UAAU4P,oBAAoBb,EAAOc,EAAStK,GAEnD+L,GAAKtR,UAAU4P,oBAAoBb,EAAOc,EAAStK,KA+DnD+P,OAAU7U,OAAAgF,EAAA,EAAAhF,CAad,SAAqB6E,EAAMuK,EAAStK,GAClCxE,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GACjDF,OAAAC,EAAA,EAAAD,MAA2B8C,IAApBsM,EAAQE,QAAuB,IACtChP,IAAM2P,EAAchH,EAAqB,YACnCqL,EAAgBrL,EAAuB,cACvCsG,EAAYtG,EAAmB,UAC/B6L,EAAWT,GAAYC,EAAerE,GACtCrP,EAAewO,EAAQI,kBAC7B3K,EAAK+G,aAAa,WAAYkJ,GAC9BjQ,EAAK4L,eAAeM,GAAO,SAAWuD,EAAe/E,GACrDjP,IAAM+O,EAAMD,EAAQE,QACpB,QAAYxM,IAARuM,EAAmB,CAGrB,IAFA/O,IAAMsP,EAAOR,EAAQ2F,UACftI,KACG1F,EAAI,EAAGC,EAAK4I,EAAK1P,OAAQ6G,EAAIC,EAAID,IAAK,CAC7CzG,IAAMoL,EAAQ0D,EAAQ4F,IAAIpF,EAAK7I,IAC/B,QAAcjE,IAAV4I,EAAqB,CACvBzD,IAAIgN,EAAOrF,EAAK7I,GACZ2E,aAAiBoE,EAAA,IACnBmF,EAAOrU,GAET6L,EAAO/F,MAAMuO,KAAMA,EAAMvJ,MAAOA,KAGpC1L,OAAAgF,EAAA,EAAAhF,EACG2U,WAAc1L,EAAoB,WAAGpE,KAAMA,EAC1CF,KAAQsE,EAAc,KAAGlI,QAAWkI,EAAiB,SACzDwL,GACAzU,OAAAgF,EAAA,EAAAhF,CAAsB,YAAayM,EACnC3H,GACAqP,GAAkBtP,EAAMwK,MA1CxB6F,OAAUlV,OAAAgF,EAAA,EAAAhF,CAvBd,SAAqB6E,EAAMuK,EAAStK,GAClCxE,IAAM2I,EAAUnE,EAAYA,EAAY5E,OAAS,GACjDF,OAAAC,EAAA,EAAAD,MAA2B8C,IAApBsM,EAAQE,QAAuB,IACtChP,IAAM2P,EAAchH,EAAqB,YACnCqL,EAAgBrL,EAAuB,cACvCsG,EAAYtG,EAAmB,UAC/B6L,EAAWT,GAAYC,EAAerE,GAC5CpL,EAAK+G,aAAa,WAAYkJ,GAC9BjQ,EAAK4L,eAAeM,GAAO,SAAWuD,EAAe/E,GACrDjP,IAAM+O,EAAMD,EAAQE,aACRxM,IAARuM,GACF8E,GAAkBtP,EAAMwK,KAaxB8F,SAAYnV,OAAAgF,EAAA,EAAAhF,CAmDhB,SAAuB6E,EAAMuQ,EAAMtQ,GACjCxE,IAAM2U,EAAOjV,OAAAgF,EAAA,EAAAhF,CAAgBiR,GAAO,QAE9B0D,EADU7P,EAAYA,EAAY5E,OAAS,GACV,WAGvC,GAFA2E,EAAK0H,YAAY0I,GACjBjV,OAAAwJ,EAAA,EAAAxJ,CAAoBiV,EAAMG,EAAKH,WACZnS,IAAfsS,EAAK1J,OAAsC,OAAf0J,EAAK1J,MAAgB,CACnDpL,IAAMoL,EAAQ1L,OAAAgF,EAAA,EAAAhF,CAAgBiR,GAAO,SACrCpM,EAAK0H,YAAYb,GACb0J,EAAK1J,iBAAiBoE,EAAA,EACL,IAAf6E,EACFC,EAAA,EAAKrV,UAAUoP,qBAAqBjD,EAClC0J,EAAK1J,MAAO5G,GAEd+L,GAAKtR,UAAUoP,qBAAqBjD,EAClC0J,EAAK1J,MAAO5G,GAGhB9E,OAAAwJ,EAAA,EAAAxJ,CAAoB0L,EAAO0J,EAAK1J,UApElC2J,OAAUrV,OAAAgF,EAAA,EAAAhF,CAgFd,SAAqB6E,EAAMyQ,EAAexQ,GACpCwQ,EAAcC,UAChB1Q,EAAK+G,aAAa,WAAY0J,EAAcC,eAEXzS,IAA/BwS,EAAcE,cAChB3Q,EAAK+G,aAAa,eAAgB0J,EAAcE,mBAEtB1S,IAAxBwS,EAAc5J,OAChB1L,OAAAwJ,EAAA,EAAAxJ,CAAoB6E,EAAMyQ,EAAc5J,WAQ5CpL,IAAMmV,IACJnC,8BACEoC,MAAS1V,OAAAgF,EAAA,EAAAhF,CA6Bb,SAAoB6E,EAAMoL,EAAanL,GACrCxE,IAKIwU,EALE7L,EAAiCnE,EAAYA,EAAY5E,OAAS,GAClEoU,EAAgBrL,EAAuB,cACvCsG,EAAYtG,EAAmB,UAC/B0M,EAAgB1M,EAAuB,cACvClI,EAAUkI,EAAiB,QAI/B6L,EADER,EACSD,GAAYC,EAAerE,GAE3BA,EAEbpL,EAAK+G,aAAa,WAAYkJ,GAC1B/T,GACF8D,EAAK+G,aAAa,UAAW7K,GAE3BwO,GACF1K,EAAK4L,eAAeM,GAAO,SAAWuD,EAAe/E,GAEvDjP,IAAMsO,EAAmD5O,OAAA6O,EAAA,EAAD,IAAY5F,GACpE2F,EAAK/J,KAAOA,EACZ7E,OAAAgF,EAAA,EAAAhF,CAAoB4O,EAClBqF,GACAjU,OAAAgF,EAAA,EAAAhF,CAAsB,gBAAiB2V,EACvC7Q,GACFxE,IAAM8T,EAASnL,EAAgB,OAC/B,GAAImL,EAAQ,CACV9T,IAAMgO,EAAQtO,OAAAgF,EAAA,EAAAhF,CAAgBgR,GAAO,UACrCnM,EAAK0H,YAAY+B,GACjBsH,GAAqBtH,EAAO8F,EAAQtP,OAzDtC6O,8BACEnS,OAAUxB,OAAAgF,EAAA,EAAAhF,CAyId,SAA2B6E,EAAMuP,EAAQtP,GAEvCxE,IAAMuV,EAAiB7V,OAAAgF,EAAA,EAAAhF,CAAgBkR,GAAO,kBAC9ClR,OAAAwJ,EAAA,EAAAxJ,CAAoB6V,EAAgBzB,EAAO9S,cAC3CuD,EAAK0H,YAAYsJ,GAEjBvV,IAAMwV,EAAa9V,OAAAgF,EAAA,EAAAhF,CAAgB8D,EAAA,EAAO,cAE1Ce,EAAK0H,YAAYuJ,GAEjBxV,IAAMmB,EAAQzB,OAAAgF,EAAA,EAAAhF,CAAgB8D,EAAA,EAAO,SACrCgS,EAAWvJ,YAAY9K,GACvBsU,GAAiBtU,EAAO2S,EAAO3S,OAE/BnB,IAAMoB,EAAM1B,OAAAgF,EAAA,EAAAhF,CAAgB8D,EAAA,EAAO,OACnCgS,EAAWvJ,YAAY7K,GACvBqU,GAAiBrU,EAAK0S,EAAO1S,OAxJ3BrB,IAAOL,OAAAgF,EAAA,EAAAhF,CAAkBgW,IACzBxS,GAAMxD,OAAAgF,EAAA,EAAAhF,CAAkBgW,IACxB3S,IAAOrD,OAAAgF,EAAA,EAAAhF,CAkLX,SAAwB6E,EAAMuP,EAAQtP,GAEpCxE,IAAMsO,GAAQ/J,KAAMA,GACdvB,EAAY8Q,EAAO9Q,UACzBtD,OAAAgF,EAAA,EAAAhF,CAAoB4O,EAClB6G,GACAzV,OAAAgF,EAAA,EAAAhF,CAAsBsD,EAAU9D,eAC/B8D,GAAYwB,KAxLbmR,KAAQjW,OAAAgF,EAAA,EAAAhF,CA6EZ,SAAyB6E,EAAMuP,EAAQtP,GACrBA,EAAYA,EAAY5E,OAAS,GAChC,QAAIkU,EAAOrT,QAE5BmV,GAAqBrR,EAAMuP,EAAOxT,cAClCiQ,GAAKtR,UAAUoP,qBAAqB9J,EAAMuP,EAAOvT,OAAQiE,KAjFvD1D,SAAYpB,OAAAgF,EAAA,EAAAhF,CA0FhB,SAA6B6E,EAAMuP,EAAQtP,GACzBA,EAAYA,EAAY5E,OAAS,GAChC,QAAIkU,EAAOrT,QAE5BmV,GAAqBrR,EAAMuP,EAAOxT,cAClCiQ,GAAKtR,UAAUoP,qBAAqB9J,EAAMuP,EAAOlT,SAAU4D,KA9FzD1C,WAAcpC,OAAAgF,EAAA,EAAAhF,CAuGlB,SAA+B6E,EAAMuP,EAAQtP,GAC3BA,EAAYA,EAAY5E,OAAS,GAChC,QAAIkU,EAAOrT,QAE5BmV,GAAqBrR,EAAMuP,EAAOxT,cAClCiQ,GAAKtR,UAAUoP,qBAAqB9J,EAAMuP,EAAOlT,SAAU4D,KA3GzDrB,OAAUzD,OAAAgF,EAAA,EAAAhF,CAoHd,SAA2B6E,EAAMuP,EAAQtP,GACvBA,EAAYA,EAAY5E,OAAS,GAChC,QAAIkU,EAAOrT,QAE5BmV,GAAqBrR,EAAMuP,EAAOxT,cAClCiQ,GAAKtR,UAAUoP,qBAAqB9J,EAAMuP,EAAOlT,SAAU4D,KAxHzDqR,kBAAqBnW,OAAAgF,EAAA,EAAAhF,CAAkBoW,IACvCC,qBAAwBrW,OAAAgF,EAAA,EAAAhF,CAAkBoW,IAC1CE,mBAAsBtW,OAAAgF,EAAA,EAAAhF,CAAkBoW,IACxCG,4BAA+BvW,OAAAgF,EAAA,EAAAhF,CAAkBoW,IACjDI,sBAAyBxW,OAAAgF,EAAA,EAAAhF,CAAkBoW,IAC3CK,+BAAkCzW,OAAAgF,EAAA,EAAAhF,CAAkBoW,IACpDM,eAAkB1W,OAAAgF,EAAA,EAAAhF,CAqMtB,SAA2B6E,EAAMuP,EAAQtP,GACvCoR,GAAqBrR,EAAMuP,EAAO9S,gBArMhCqV,kBAAqB3W,OAAAgF,EAAA,EAAAhF,CA8MzB,SAA8B6E,EAAMuP,EAAQtP,GAC1CoR,GAAqBrR,EAAMuP,EAAO9S,cAElChB,IAAMgC,EAAgBtC,OAAAgF,EAAA,EAAAhF,CAAgBgR,GAAO,iBAC7CnM,EAAK0H,YAAYjK,GACjBsU,GAAgBtU,EAAe,GAAK8R,EAAO9R,eAE3ChC,IAAMiC,EAAgBvC,OAAAgF,EAAA,EAAAhF,CAAgBgR,GAAO,iBAC7CnM,EAAK0H,YAAYhK,GACjBqU,GAAgBrU,EAAe,GAAK6R,EAAO7R,iBAtNzCsU,eAAkB7W,OAAAgF,EAAA,EAAAhF,CA+NtB,SAA2B6E,EAAMuP,EAAQtP,GACvCD,EAAK+G,aAAa,WAAYwI,EAAOvR,UACrCgC,EAAK+G,aAAa,aAAcwI,EAAOrR,YACvC8B,EAAK+G,aAAa,aAAcwI,EAAOpR,iBACdF,IAArBsR,EAAOtS,WACT+C,EAAK+G,aAAa,YAAawI,EAAOtS,UAAUgV,YAElDZ,GAAqBrR,EAAMuP,EAAO9S,cAClCsV,GAAgB/R,EAAM,GAAKuP,EAAO3R,aArLpC,SAASmT,GAAqB/Q,EAAMuP,EAAQtP,GAE1CxE,IAAMsO,GAAQ/J,KAAMA,GACpB7E,OAAAgF,EAAA,EAAAhF,CAAoB4O,EAClB6G,GACAzV,OAAAgF,EAAA,EAAAhF,CAAsBoU,EAAO5U,eAC5B4U,GAAStP,GA0Fd,SAASkR,GAAmBnR,EAAMuP,EAAQtP,GAIxC,IAFAxE,IAAMsO,GAAQ/J,KAAMA,GACdlF,EAAayU,EAAOzU,WACjBoH,EAAI,EAAGC,EAAKrH,EAAWO,OAAQ6G,EAAIC,IAAMD,EAAG,CACnDzG,IAAMgD,EAAY3D,EAAWoH,GAC7B/G,OAAAgF,EAAA,EAAAhF,CAAoB4O,EAClB6G,GACAzV,OAAAgF,EAAA,EAAAhF,CAAsBsD,EAAU9D,eAC/B8D,GAAYwB,IA0BnB,SAASsR,GAAsBvR,EAAMuP,EAAQtP,QAClBhC,IAArBsR,EAAOtS,WACT+C,EAAK+G,aAAa,YAAawI,EAAOtS,UAAUgV,YAElDZ,GAAqBrR,EAAMuP,EAAO9S,cAClCsV,GAAgB/R,EAAM,GAAKuP,EAAOxS,YAsDpC,SAASmV,GAAmB3X,EAASyF,EAAM6G,GACzCpL,IAAM0W,EAAWhX,OAAAgF,EAAA,EAAAhF,CAAgBgR,GAAO5R,GACxCY,OAAAwJ,EAAA,EAAAxJ,CAAoBgX,EAAUtL,GAC9B7G,EAAK0H,YAAYyK,GAQnB,SAASd,GAAqBrR,EAAM6G,GAClCqL,GAAmB,eAAgBlS,EAAM6G,GAQ3C,SAASkL,GAAgB/R,EAAM6G,GAC7BqL,GAAmB,UAAWlS,EAAM6G,GAQtC,SAASqK,GAAiBlR,EAAMoS,GAC9B3W,IAAM4W,EAAclX,OAAAgF,EAAA,EAAAhF,CAAgB8D,EAAA,EAAO,eAC3Ce,EAAK0H,YAAY2K,GAEjB5W,IAAM6W,EAAenX,OAAAgF,EAAA,EAAAhF,CAAgB8D,EAAA,EAAO,gBAC5CoT,EAAY3K,YAAY4K,GACxBnX,OAAAwJ,EAAA,EAAAxJ,CAAoBmX,EAAcF,GAyCpC3F,GAAI/R,UAAU6X,gBAAkB,SAASnT,GACvC3D,IAGI8T,EAHEvP,EAAO7E,OAAAgF,EAAA,EAAAhF,CAAgBiR,GAAO,cAIpC,GAHApM,EAAK+G,aAAa,UAAW,OAC7B/G,EAAK+G,aAAa,UAAW,SAEzB3H,IACEA,EAAQoT,QACVxS,EAAK+G,aAAa,SAAU3H,EAAQoT,QAElCpT,EAAQqT,cACVzS,EAAK+G,aAAa,eAAgB3H,EAAQqT,mBAEhBxU,IAAxBmB,EAAQsT,aACV1S,EAAK+G,aAAa,cAAe3H,EAAQsT,aAEvCtT,EAAQuT,YACV3S,EAAK+G,aAAa,aAAc3H,EAAQuT,iBAEf1U,IAAvBmB,EAAQwT,YACV5S,EAAK+G,aAAa,aAAc3H,EAAQwT,iBAEpB3U,IAAlBmB,EAAQyT,OACV7S,EAAK+G,aAAa,QAAS3H,EAAQyT,OAErCtD,EAASnQ,EAAQmQ,OACbnQ,EAAQ0T,MAAM,CAChB3X,OAAAC,EAAA,EAAAD,CAAOiE,EAAQrD,aACb,IACFN,IAAMqX,EF54BL,SAAc/W,EAAcC,EAAQC,GACzC,OAAO,IAAIE,EAAKJ,EAAcC,EAAQC,GE24BrB8W,CACY3T,EAAoB,aAAGA,EAAQ0T,KAAM1T,EAAQlD,SAGpEqT,EAFEA,EAEO1Q,EAAU0Q,EAAQuD,GAElBA,EAIf9S,EAAK4L,eAAezL,EAAA,EAAyB,qBAAsB3F,KAAKsS,iBAExErR,IAAM2I,GACJpE,KAAMA,EACN9D,QAAWkD,EAAQlD,QACnBwO,UAAatL,EAAQsL,UAAYtL,EAAQsL,UAAYlQ,KAAKmS,WAC1D8C,cAAiBrQ,EAAQqQ,cACzB1T,aAAgBqD,EAAQrD,aACxBwT,OAAUA,EACVuB,cAAiB1R,EAAQ0R,cAAgB1R,EAAQ0R,kBAKnD,OAHA3V,OAAAC,EAAA,EAAAD,CAAOH,MAAMiP,QAAQ7K,EAAQ4T,cAC3B,IApEJ,SAAyBhT,EAAMgT,EAAc/S,GAC3CxE,IAAM2I,EAAiCnE,EAAYA,EAAY5E,OAAS,GAClE0O,EAAmD5O,OAAA6O,EAAA,EAAD,IAAY5F,GACpE2F,EAAK/J,KAAOA,EACZ7E,OAAAgF,EAAA,EAAAhF,CAAoB4O,EAClB6G,GACAzV,OAAAgF,EAAA,EAAAhF,CAAsB,SAAU6X,EAChC/S,GA8DFsS,CAAgBvS,EAAsCZ,EAAoB,cAAIgF,IACvEpE,GAcTyM,GAAI/R,UAAUuY,iBAAmB,SAASC,EAASC,EAASC,EAAShU,GACnE3D,IAMI4X,EAEAC,EARErT,KACAD,EAAO7E,OAAAgF,EAAA,EAAAhF,CAAgBiR,GAAO,eAC9BmH,EAAUnU,EAAQmU,QAAUnU,EAAQmU,QA13BpB,QA23BhBzD,EAAyB,UAAZyD,EAAsB,EAAI,EAC7CvT,EAAK+G,aAAa,UAAW,OAC7B/G,EAAK+G,aAAa,UAAWwM,GAIzBnU,IACFiU,EAAUjU,EAAQoU,WAAapU,EAAQoU,cACnCpU,EAAQoT,QACVxS,EAAK+G,aAAa,SAAU3H,EAAQoT,SAGxC/W,IAAMoE,EAAiByM,GAAiBiH,GACxCvT,EAAK4L,eAAezL,EAAA,EAAyB,qBAAsBN,GACnEpE,IAAMgU,EAAgBrQ,EAAQqQ,cAAgBrQ,EAAQqQ,cAAgBxD,GAqCtE,OApCIiH,IACFI,GAAOtT,KAAMA,EAAM0K,UAAatL,EAAQsL,UACtCU,YAAehM,EAAQgM,YAAaqE,cAAiBA,EACrDK,WAAcA,EAAYhQ,KAAQV,EAAQU,KAAM5D,QAAWkD,EAAQlD,SACrEf,OAAA6O,EAAA,EAAA7O,CAAOmY,EAAKD,GACZlY,OAAAgF,EAAA,EAAAhF,CAAoBmY,EAClB1D,GACAzU,OAAAgF,EAAA,EAAAhF,CAAsB,UAAW+X,EACjCjT,IAEAkT,IACFG,GAAOtT,KAAMA,EAAM0K,UAAatL,EAAQsL,UACtCU,YAAehM,EAAQgM,YAAaqE,cAAiBA,EACrDK,WAAcA,EAAYhQ,KAAQV,EAAQU,KAAM5D,QAAWkD,EAAQlD,SACrEf,OAAA6O,EAAA,EAAA7O,CAAOmY,EAAKD,GACZlY,OAAAgF,EAAA,EAAAhF,CAAoBmY,EAClB1D,GACAzU,OAAAgF,EAAA,EAAAhF,CAAsB,UAAWgY,EACjClT,IAEAmT,GACFjY,OAAAgF,EAAA,EAAAhF,EAAqB6E,KAAMA,EAAM0K,UAAatL,EAAQsL,UACpDU,YAAehM,EAAQgM,YAAaqE,cAAiBA,EACrDK,WAAcA,EAAY5T,QAAWkD,EAAQlD,SAC/C0T,GACAzU,OAAAgF,EAAA,EAAAhF,CAAsB,UAAWiY,EACjCnT,GAEEb,EAAQqU,gBACVtY,OAAAgF,EAAA,EAAAhF,EAAqB6E,KAAMA,EAAM0K,UAAatL,EAAQsL,UACpDU,YAAehM,EAAQgM,YAAaqE,cAAiBA,EACrDK,WAAcA,EAAY5T,QAAWkD,EAAQlD,SAC/C0T,GACAzU,OAAAgF,EAAA,EAAAhF,CAAsB,UAAWiE,EAAQqU,eACzCxT,GAEKD,GAYTyM,GAAI/R,UAAUgZ,eAMdjH,GAAI/R,UAAUiZ,2BAA6B,SAAShG,GAClD,QAASI,EAAIJ,EAAIK,WAAYD,EAAGA,EAAIA,EAAEE,YACpC,GAAIF,EAAEG,UAAYC,KAAKC,aACrB,YAAYwF,uBAAuB7F,GAGvC,OAAO,MAOTtB,GAAI/R,UAAUkZ,uBAAyB,SAAS5T,GAC9C,GAAIA,EAAK6T,mBACL7T,EAAK6T,kBAAkBA,kBAEzB,IAAKzQ,IAAI2K,GADT/N,EAAOA,EAAK6T,kBAAkBA,mBACZA,kBAAmB9F,EAAGA,EAAIA,EAAE+F,mBAC5C,GAA8B,IAAxB/F,EAAEgG,WAAW1Y,SACU,IAAxB0S,EAAEgG,WAAW1Y,QACY,IAA1B0S,EAAEC,WAAWE,UAAkB,CACjCzS,IAAMwE,OAEN,YADK2M,WAAW0B,oBAAoBP,EAAG9N,GAChC9E,OAAA0I,EAAA,EAAA1I,CAAc8E,EAAY+T,MAAM9X,SAK7C,OAAO,MAET,IAAA+X,GAAA,kECllCMC,GAAe,IAAIC,GAAA,EACnBC,GAAS,IAAIC,GAAA,GACjB7G,OAAQ0G,GACRI,MAAO,IAAIC,GAAA,GACTC,OAAQ,IAAIC,GAAA,GACVC,MAAO,uBACPC,MAAO,QAKPC,GAAS,IAAIC,GAAA,GACjBrH,OAAQ,IAAIsH,GAAA,GACVC,WAAY,SACZ/J,IAAK,uEAIHgK,GAAM,IAAIC,EAAA,GACdC,QAASN,GAAQR,IACjBe,OAAQC,SAASC,eAAe,OAChCC,KAAM,IAAIC,EAAA,GACRC,SAAU,kBAAmB,mBAC7BC,QAAS,GACTC,KAAM,OAKJC,IAAiB,IAAI1B,IAAM1B,iBAC/BrW,QAAS,YACTwO,UAAW,0BACX+E,cAAe,MACfuD,cAAe,eACfP,aAAc,mBACdlD,OAAQ1Q,EHoMH,SAAcpC,EAAcmB,EACjCC,EAAcC,EAAgBC,EAAgBf,GAC9C,OAAO,IAAIoB,EAAO3B,EAAcmB,EAC9BC,EAAcC,EAAgBC,EAAgBf,GGtM9C4Y,CAAW,OAAQ,gBHgFhB,SAAiBnZ,EAAcM,EAAYC,GAChD,OAAO,IAAII,EAAQX,EAAcM,EAAYC,GGhF3C6Y,CAAc,WAAY,gBAK9BC,MAAM,sCACJC,OAAQ,OACRC,MAAM,IAAIC,eAAgBC,kBAAkBP,MAC3CQ,KAAK,SAASC,GACf,OAAOA,EAASC,SACfF,KAAK,SAASE,GACf5a,IAAM0P,GAAW,IAAImL,GAAA,GAAUpJ,aAAamJ,GAC5CnC,GAAaqC,YAAYpL,GACzB6J,GAAIwB,UAAUC,IAAIvC,GAAawC","file":"vector-wfs-getfeature.js","sourcesContent":["/**\n * @module ol/format/filter/Filter\n */\n\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature filters.\n *\n * @constructor\n * @abstract\n * @param {!string} tagName The XML tag name for this filter.\n * @struct\n */\nconst Filter = function(tagName) {\n\n  /**\n   * @private\n   * @type {!string}\n   */\n  this.tagName_ = tagName;\n};\n\n/**\n * The XML tag name for a filter.\n * @returns {!string} Name.\n */\nFilter.prototype.getTagName = function() {\n  return this.tagName_;\n};\n\nexport default Filter;\n","/**\n * @module ol/format/filter/LogicalNary\n */\nimport {inherits} from '../../util.js';\nimport {assert} from '../../asserts.js';\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature n-ary logical filters.\n *\n * @constructor\n * @abstract\n * @param {!string} tagName The XML tag name for this filter.\n * @param {...module:ol/format/filter/Filter} conditions Conditions.\n * @extends {module:ol/format/filter/Filter}\n */\nconst LogicalNary = function(tagName, conditions) {\n\n  Filter.call(this, tagName);\n\n  /**\n   * @type {Array.<module:ol/format/filter/Filter>}\n   */\n  this.conditions = Array.prototype.slice.call(arguments, 1);\n  assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\n};\n\ninherits(LogicalNary, Filter);\nexport default LogicalNary;\n","/**\n * @module ol/format/filter/And\n */\nimport {inherits} from '../../util.js';\nimport LogicalNary from '../filter/LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<And>` operator between two or more filter conditions.\n *\n * @constructor\n * @abstract\n * @param {...module:ol/format/filter/Filter} conditions Conditions.\n * @extends {module:ol/format/filter/LogicalNary}\n */\nconst And = function(conditions) {\n  const params = ['And'].concat(Array.prototype.slice.call(arguments));\n  LogicalNary.apply(this, params);\n};\n\ninherits(And, LogicalNary);\n\nexport default And;\n","/**\n * @module ol/format/filter/Bbox\n */\nimport {inherits} from '../../util.js';\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Represents a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @constructor\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/extent~Extent} extent Extent.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @extends {module:ol/format/filter/Filter}\n * @api\n */\nconst Bbox = function(geometryName, extent, opt_srsName) {\n\n  Filter.call(this, 'BBOX');\n\n  /**\n   * @type {!string}\n   */\n  this.geometryName = geometryName;\n\n  /**\n   * @type {module:ol/extent~Extent}\n   */\n  this.extent = extent;\n\n  /**\n   * @type {string|undefined}\n   */\n  this.srsName = opt_srsName;\n};\n\ninherits(Bbox, Filter);\n\nexport default Bbox;\n","/**\n * @module ol/format/filter/Spatial\n */\nimport {inherits} from '../../util.js';\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Represents a spatial operator to test whether a geometry-valued property\n * relates to a given geometry.\n *\n * @constructor\n * @abstract\n * @param {!string} tagName The XML tag name for this filter.\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @extends {module:ol/format/filter/Filter}\n */\nconst Spatial = function(tagName, geometryName, geometry, opt_srsName) {\n\n  Filter.call(this, tagName);\n\n  /**\n   * @type {!string}\n   */\n  this.geometryName = geometryName || 'the_geom';\n\n  /**\n   * @type {module:ol/geom/Geometry}\n   */\n  this.geometry = geometry;\n\n  /**\n   * @type {string|undefined}\n   */\n  this.srsName = opt_srsName;\n};\n\ninherits(Spatial, Filter);\n\nexport default Spatial;\n","/**\n * @module ol/format/filter/Contains\n */\nimport {inherits} from '../../util.js';\nimport Spatial from '../filter/Spatial.js';\n\n/**\n * @classdesc\n * Represents a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @constructor\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @extends {module:ol/format/filter/Spatial}\n * @api\n */\nconst Contains = function(geometryName, geometry, opt_srsName) {\n\n  Spatial.call(this, 'Contains', geometryName, geometry, opt_srsName);\n\n};\n\ninherits(Contains, Spatial);\nexport default Contains;\n","/**\n * @module ol/format/filter/Comparison\n */\nimport {inherits} from '../../util.js';\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property comparison filters.\n *\n * @constructor\n * @abstract\n * @param {!string} tagName The XML tag name for this filter.\n * @param {!string} propertyName Name of the context property to compare.\n * @extends {module:ol/format/filter/Filter}\n */\nconst Comparison = function(tagName, propertyName) {\n\n  Filter.call(this, tagName);\n\n  /**\n   * @type {!string}\n   */\n  this.propertyName = propertyName;\n};\n\ninherits(Comparison, Filter);\n\nexport default Comparison;\n","/**\n * @module ol/format/filter/During\n */\nimport {inherits} from '../../util.js';\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<During>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @extends {module:ol/format/filter/Comparison}\n * @api\n */\nconst During = function(propertyName, begin, end) {\n  Comparison.call(this, 'During', propertyName);\n\n  /**\n   * @type {!string}\n   */\n  this.begin = begin;\n\n  /**\n   * @type {!string}\n   */\n  this.end = end;\n};\n\ninherits(During, Comparison);\nexport default During;\n","/**\n * @module ol/format/filter/ComparisonBinary\n */\nimport {inherits} from '../../util.js';\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property binary comparison filters.\n *\n * @constructor\n * @abstract\n * @param {!string} tagName The XML tag name for this filter.\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @extends {module:ol/format/filter/Comparison}\n */\nconst ComparisonBinary = function(tagName, propertyName, expression, opt_matchCase) {\n\n  Comparison.call(this, tagName, propertyName);\n\n  /**\n   * @type {!(string|number)}\n   */\n  this.expression = expression;\n\n  /**\n   * @type {boolean|undefined}\n   */\n  this.matchCase = opt_matchCase;\n};\n\ninherits(ComparisonBinary, Comparison);\nexport default ComparisonBinary;\n","/**\n * @module ol/format/filter/EqualTo\n */\nimport {inherits} from '../../util.js';\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsEqualTo>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @extends {module:ol/format/filter/ComparisonBinary}\n * @api\n */\nconst EqualTo = function(propertyName, expression, opt_matchCase) {\n  ComparisonBinary.call(this, 'PropertyIsEqualTo', propertyName, expression, opt_matchCase);\n};\n\ninherits(EqualTo, ComparisonBinary);\nexport default EqualTo;\n","/**\n * @module ol/format/filter/GreaterThan\n */\nimport {inherits} from '../../util.js';\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @extends {module:ol/format/filter/ComparisonBinary}\n * @api\n */\nconst GreaterThan = function(propertyName, expression) {\n  ComparisonBinary.call(this, 'PropertyIsGreaterThan', propertyName, expression);\n};\n\ninherits(GreaterThan, ComparisonBinary);\nexport default GreaterThan;\n","/**\n * @module ol/format/filter/GreaterThanOrEqualTo\n */\nimport {inherits} from '../../util.js';\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @extends {module:ol/format/filter/ComparisonBinary}\n * @api\n */\nconst GreaterThanOrEqualTo = function(propertyName, expression) {\n  ComparisonBinary.call(this, 'PropertyIsGreaterThanOrEqualTo', propertyName, expression);\n};\n\ninherits(GreaterThanOrEqualTo, ComparisonBinary);\nexport default GreaterThanOrEqualTo;\n","/**\n * @module ol/format/filter/Intersects\n */\nimport {inherits} from '../../util.js';\nimport Spatial from '../filter/Spatial.js';\n\n/**\n * @classdesc\n * Represents a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @constructor\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @extends {module:ol/format/filter/Spatial}\n * @api\n */\nconst Intersects = function(geometryName, geometry, opt_srsName) {\n\n  Spatial.call(this, 'Intersects', geometryName, geometry, opt_srsName);\n\n};\n\ninherits(Intersects, Spatial);\nexport default Intersects;\n","/**\n * @module ol/format/filter/IsBetween\n */\nimport {inherits} from '../../util.js';\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsBetween>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @extends {module:ol/format/filter/Comparison}\n * @api\n */\nconst IsBetween = function(propertyName, lowerBoundary, upperBoundary) {\n  Comparison.call(this, 'PropertyIsBetween', propertyName);\n\n  /**\n   * @type {!number}\n   */\n  this.lowerBoundary = lowerBoundary;\n\n  /**\n   * @type {!number}\n   */\n  this.upperBoundary = upperBoundary;\n};\n\ninherits(IsBetween, Comparison);\nexport default IsBetween;\n","/**\n * @module ol/format/filter/IsLike\n */\nimport {inherits} from '../../util.js';\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLike>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string=} opt_singleChar pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string=} opt_escapeChar Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @extends {module:ol/format/filter/Comparison}\n * @api\n */\nconst IsLike = function(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n  Comparison.call(this, 'PropertyIsLike', propertyName);\n\n  /**\n   * @type {!string}\n   */\n  this.pattern = pattern;\n\n  /**\n   * @type {!string}\n   */\n  this.wildCard = (opt_wildCard !== undefined) ? opt_wildCard : '*';\n\n  /**\n   * @type {!string}\n   */\n  this.singleChar = (opt_singleChar !== undefined) ? opt_singleChar : '.';\n\n  /**\n   * @type {!string}\n   */\n  this.escapeChar = (opt_escapeChar !== undefined) ? opt_escapeChar : '!';\n\n  /**\n   * @type {boolean|undefined}\n   */\n  this.matchCase = opt_matchCase;\n};\n\ninherits(IsLike, Comparison);\nexport default IsLike;\n","/**\n * @module ol/format/filter/IsNull\n */\nimport {inherits} from '../../util.js';\nimport Comparison from '../filter/Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsNull>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @extends {module:ol/format/filter/Comparison}\n * @api\n */\nconst IsNull = function(propertyName) {\n  Comparison.call(this, 'PropertyIsNull', propertyName);\n};\n\ninherits(IsNull, Comparison);\nexport default IsNull;\n","/**\n * @module ol/format/filter/LessThan\n */\nimport {inherits} from '../../util.js';\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLessThan>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @extends {module:ol/format/filter/ComparisonBinary}\n * @api\n */\nconst LessThan = function(propertyName, expression) {\n  ComparisonBinary.call(this, 'PropertyIsLessThan', propertyName, expression);\n};\n\ninherits(LessThan, ComparisonBinary);\nexport default LessThan;\n","/**\n * @module ol/format/filter/LessThanOrEqualTo\n */\nimport {inherits} from '../../util.js';\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @extends {module:ol/format/filter/ComparisonBinary}\n * @api\n */\nconst LessThanOrEqualTo = function(propertyName, expression) {\n  ComparisonBinary.call(this, 'PropertyIsLessThanOrEqualTo', propertyName, expression);\n};\n\ninherits(LessThanOrEqualTo, ComparisonBinary);\nexport default LessThanOrEqualTo;\n","/**\n * @module ol/format/filter/Not\n */\nimport {inherits} from '../../util.js';\nimport Filter from '../filter/Filter.js';\n\n/**\n * @classdesc\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @constructor\n * @param {!module:ol/format/filter/Filter} condition Filter condition.\n * @extends {module:ol/format/filter/Filter}\n * @api\n */\nconst Not = function(condition) {\n\n  Filter.call(this, 'Not');\n\n  /**\n   * @type {!module:ol/format/filter/Filter}\n   */\n  this.condition = condition;\n};\n\ninherits(Not, Filter);\nexport default Not;\n","/**\n * @module ol/format/filter/NotEqualTo\n */\nimport {inherits} from '../../util.js';\nimport ComparisonBinary from '../filter/ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @constructor\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @extends {module:ol/format/filter/ComparisonBinary}\n * @api\n */\nconst NotEqualTo = function(propertyName, expression, opt_matchCase) {\n  ComparisonBinary.call(this, 'PropertyIsNotEqualTo', propertyName, expression, opt_matchCase);\n};\n\ninherits(NotEqualTo, ComparisonBinary);\nexport default NotEqualTo;\n","/**\n * @module ol/format/filter/Or\n */\nimport {inherits} from '../../util.js';\nimport LogicalNary from '../filter/LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<Or>` operator between two ore more filter conditions.\n *\n * @constructor\n * @param {...module:ol/format/filter/Filter} conditions Conditions.\n * @extends {module:ol/format/filter/LogicalNary}\n * @api\n */\nconst Or = function(conditions) {\n  const params = ['Or'].concat(Array.prototype.slice.call(arguments));\n  LogicalNary.apply(this, params);\n};\n\ninherits(Or, LogicalNary);\nexport default Or;\n","/**\n * @module ol/format/filter/Within\n */\nimport {inherits} from '../../util.js';\nimport Spatial from '../filter/Spatial.js';\n\n/**\n * @classdesc\n * Represents a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @constructor\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @extends {module:ol/format/filter/Spatial}\n * @api\n */\nconst Within = function(geometryName, geometry, opt_srsName) {\n\n  Spatial.call(this, 'Within', geometryName, geometry, opt_srsName);\n\n};\n\ninherits(Within, Spatial);\nexport default Within;\n","/**\n * @module ol/format/filter\n */\nimport And from '../format/filter/And.js';\nimport Bbox from '../format/filter/Bbox.js';\nimport Contains from '../format/filter/Contains.js';\nimport During from '../format/filter/During.js';\nimport EqualTo from '../format/filter/EqualTo.js';\nimport GreaterThan from '../format/filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from '../format/filter/GreaterThanOrEqualTo.js';\nimport Intersects from '../format/filter/Intersects.js';\nimport IsBetween from '../format/filter/IsBetween.js';\nimport IsLike from '../format/filter/IsLike.js';\nimport IsNull from '../format/filter/IsNull.js';\nimport LessThan from '../format/filter/LessThan.js';\nimport LessThanOrEqualTo from '../format/filter/LessThanOrEqualTo.js';\nimport Not from '../format/filter/Not.js';\nimport NotEqualTo from '../format/filter/NotEqualTo.js';\nimport Or from '../format/filter/Or.js';\nimport Within from '../format/filter/Within.js';\n\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...module:ol/format/filter/Filter} conditions Filter conditions.\n * @returns {!module:ol/format/filter/And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params));\n}\n\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...module:ol/format/filter/Filter} conditions Filter conditions.\n * @returns {!module:ol/format/filter/Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params));\n}\n\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!module:ol/format/filter/Filter} condition Filter condition.\n * @returns {!module:ol/format/filter/Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/extent~Extent} extent Extent.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!module:ol/format/filter/Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, opt_srsName) {\n  return new Bbox(geometryName, extent, opt_srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!module:ol/format/filter/Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, opt_srsName) {\n  return new Contains(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!module:ol/format/filter/Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, opt_srsName) {\n  return new Intersects(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!module:ol/geom/Geometry} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!module:ol/format/filter/Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, opt_srsName) {\n  return new Within(geometryName, geometry, opt_srsName);\n}\n\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!module:ol/format/filter/EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, opt_matchCase) {\n  return new EqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!module:ol/format/filter/NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!module:ol/format/filter/LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!module:ol/format/filter/LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!module:ol/format/filter/GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!module:ol/format/filter/GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @returns {!module:ol/format/filter/IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @returns {!module:ol/format/filter/IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string=} opt_singleChar pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string=} opt_escapeChar Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!module:ol/format/filter/IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(propertyName, pattern,\n  opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {\n  return new IsLike(propertyName, pattern,\n    opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);\n}\n\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @returns {!module:ol/format/filter/During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n","/**\n * @module ol/format/GML3\n */\nimport {inherits} from '../util.js';\nimport {extend} from '../array.js';\nimport {createOrUpdate} from '../extent.js';\nimport {transformWithOptions} from '../format/Feature.js';\nimport GMLBase, {GMLNS} from '../format/GMLBase.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from '../format/xsd.js';\nimport Geometry from '../geom/Geometry.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection, transformExtent} from '../proj.js';\nimport {createElementNS, getAllTextContent, makeArrayPusher, makeChildAppender,\n  makeReplacer, makeSimpleNodeFactory, OBJECT_PROPERTY_NODE_FACTORY, parseNode,\n  pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI} from '../xml.js';\n\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation = GMLNS +\n    ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n    '1.0.0/gmlsf.xsd';\n\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @constructor\n * @param {module:ol/format/GMLBase~Options=} opt_options\n *     Optional configuration object.\n * @extends {module:ol/format/GMLBase}\n * @api\n */\nconst GML3 = function(opt_options) {\n  const options = /** @type {module:ol/format/GMLBase~Options} */\n      (opt_options ? opt_options : {});\n\n  GMLBase.call(this, options);\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.surface_ = options.surface !== undefined ? options.surface : false;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.curve_ = options.curve !== undefined ? options.curve : false;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.multiCurve_ = options.multiCurve !== undefined ?\n    options.multiCurve : true;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.multiSurface_ = options.multiSurface !== undefined ?\n    options.multiSurface : true;\n\n  /**\n   * @inheritDoc\n   */\n  this.schemaLocation = options.schemaLocation ?\n    options.schemaLocation : schemaLocation;\n\n  /**\n   * @private\n   * @type {boolean}\n   */\n  this.hasZ = options.hasZ !== undefined ?\n    options.hasZ : false;\n\n};\n\ninherits(GML3, GMLBase);\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {module:ol/geom/MultiLineString|undefined} MultiLineString.\n */\nGML3.prototype.readMultiCurve_ = function(node, objectStack) {\n  /** @type {Array.<module:ol/geom/LineString>} */\n  const lineStrings = pushParseAndPop([],\n    this.MULTICURVE_PARSERS_, node, objectStack, this);\n  if (lineStrings) {\n    const multiLineString = new MultiLineString(null);\n    multiLineString.setLineStrings(lineStrings);\n    return multiLineString;\n  } else {\n    return undefined;\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {module:ol/geom/MultiPolygon|undefined} MultiPolygon.\n */\nGML3.prototype.readMultiSurface_ = function(node, objectStack) {\n  /** @type {Array.<module:ol/geom/Polygon>} */\n  const polygons = pushParseAndPop([],\n    this.MULTISURFACE_PARSERS_, node, objectStack, this);\n  if (polygons) {\n    const multiPolygon = new MultiPolygon(null);\n    multiPolygon.setPolygons(polygons);\n    return multiPolygon;\n  } else {\n    return undefined;\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\nGML3.prototype.curveMemberParser_ = function(node, objectStack) {\n  parseNode(this.CURVEMEMBER_PARSERS_, node, objectStack, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\nGML3.prototype.surfaceMemberParser_ = function(node, objectStack) {\n  parseNode(this.SURFACEMEMBER_PARSERS_,\n    node, objectStack, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<(Array.<number>)>|undefined} flat coordinates.\n */\nGML3.prototype.readPatch_ = function(node, objectStack) {\n  return pushParseAndPop([null],\n    this.PATCHES_PARSERS_, node, objectStack, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<number>|undefined} flat coordinates.\n */\nGML3.prototype.readSegment_ = function(node, objectStack) {\n  return pushParseAndPop([null],\n    this.SEGMENTS_PARSERS_, node, objectStack, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<(Array.<number>)>|undefined} flat coordinates.\n */\nGML3.prototype.readPolygonPatch_ = function(node, objectStack) {\n  return pushParseAndPop([null],\n    this.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<number>|undefined} flat coordinates.\n */\nGML3.prototype.readLineStringSegment_ = function(node, objectStack) {\n  return pushParseAndPop([null],\n    this.GEOMETRY_FLAT_COORDINATES_PARSERS_,\n    node, objectStack, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\nGML3.prototype.interiorParser_ = function(node, objectStack) {\n  /** @type {Array.<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(undefined,\n    this.RING_PARSERS, node, objectStack, this);\n  if (flatLinearRing) {\n    const flatLinearRings = /** @type {Array.<Array.<number>>} */\n        (objectStack[objectStack.length - 1]);\n    flatLinearRings.push(flatLinearRing);\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n */\nGML3.prototype.exteriorParser_ = function(node, objectStack) {\n  /** @type {Array.<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(undefined,\n    this.RING_PARSERS, node, objectStack, this);\n  if (flatLinearRing) {\n    const flatLinearRings = /** @type {Array.<Array.<number>>} */\n        (objectStack[objectStack.length - 1]);\n    flatLinearRings[0] = flatLinearRing;\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {module:ol/geom/Polygon|undefined} Polygon.\n */\nGML3.prototype.readSurface_ = function(node, objectStack) {\n  /** @type {Array.<Array.<number>>} */\n  const flatLinearRings = pushParseAndPop([null],\n    this.SURFACE_PARSERS_, node, objectStack, this);\n  if (flatLinearRings && flatLinearRings[0]) {\n    const polygon = new Polygon(null);\n    const flatCoordinates = flatLinearRings[0];\n    const ends = [flatCoordinates.length];\n    let i, ii;\n    for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n      extend(flatCoordinates, flatLinearRings[i]);\n      ends.push(flatCoordinates.length);\n    }\n    polygon.setFlatCoordinates(\n      GeometryLayout.XYZ, flatCoordinates, ends);\n    return polygon;\n  } else {\n    return undefined;\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {module:ol/geom/LineString|undefined} LineString.\n */\nGML3.prototype.readCurve_ = function(node, objectStack) {\n  /** @type {Array.<number>} */\n  const flatCoordinates = pushParseAndPop([null],\n    this.CURVE_PARSERS_, node, objectStack, this);\n  if (flatCoordinates) {\n    const lineString = new LineString(null);\n    lineString.setFlatCoordinates(GeometryLayout.XYZ, flatCoordinates);\n    return lineString;\n  } else {\n    return undefined;\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {module:ol/extent~Extent|undefined} Envelope.\n */\nGML3.prototype.readEnvelope_ = function(node, objectStack) {\n  /** @type {Array.<number>} */\n  const flatCoordinates = pushParseAndPop([null],\n    this.ENVELOPE_PARSERS_, node, objectStack, this);\n  return createOrUpdate(flatCoordinates[1][0],\n    flatCoordinates[1][1], flatCoordinates[2][0],\n    flatCoordinates[2][1]);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<number>|undefined} Flat coordinates.\n */\nGML3.prototype.readFlatPos_ = function(node, objectStack) {\n  let s = getAllTextContent(node, false);\n  const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n  /** @type {Array.<number>} */\n  const flatCoordinates = [];\n  let m;\n  while ((m = re.exec(s))) {\n    flatCoordinates.push(parseFloat(m[1]));\n    s = s.substr(m[0].length);\n  }\n  if (s !== '') {\n    return undefined;\n  }\n  const context = objectStack[0];\n  const containerSrs = context['srsName'];\n  let axisOrientation = 'enu';\n  if (containerSrs) {\n    const proj = getProjection(containerSrs);\n    axisOrientation = proj.getAxisOrientation();\n  }\n  if (axisOrientation === 'neu') {\n    let i, ii;\n    for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n      const y = flatCoordinates[i];\n      const x = flatCoordinates[i + 1];\n      flatCoordinates[i] = x;\n      flatCoordinates[i + 1] = y;\n    }\n  }\n  const len = flatCoordinates.length;\n  if (len == 2) {\n    flatCoordinates.push(0);\n  }\n  if (len === 0) {\n    return undefined;\n  }\n  return flatCoordinates;\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @private\n * @return {Array.<number>|undefined} Flat coordinates.\n */\nGML3.prototype.readFlatPosList_ = function(node, objectStack) {\n  const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n  const context = objectStack[0];\n  const containerSrs = context['srsName'];\n  const contextDimension = context['srsDimension'];\n  let axisOrientation = 'enu';\n  if (containerSrs) {\n    const proj = getProjection(containerSrs);\n    axisOrientation = proj.getAxisOrientation();\n  }\n  const coords = s.split(/\\s+/);\n  // The \"dimension\" attribute is from the GML 3.0.1 spec.\n  let dim = 2;\n  if (node.getAttribute('srsDimension')) {\n    dim = readNonNegativeIntegerString(\n      node.getAttribute('srsDimension'));\n  } else if (node.getAttribute('dimension')) {\n    dim = readNonNegativeIntegerString(\n      node.getAttribute('dimension'));\n  } else if (node.parentNode.getAttribute('srsDimension')) {\n    dim = readNonNegativeIntegerString(\n      node.parentNode.getAttribute('srsDimension'));\n  } else if (contextDimension) {\n    dim = readNonNegativeIntegerString(contextDimension);\n  }\n  let x, y, z;\n  const flatCoordinates = [];\n  for (let i = 0, ii = coords.length; i < ii; i += dim) {\n    x = parseFloat(coords[i]);\n    y = parseFloat(coords[i + 1]);\n    z = (dim === 3) ? parseFloat(coords[i + 2]) : 0;\n    if (axisOrientation.substr(0, 2) === 'en') {\n      flatCoordinates.push(x, y, z);\n    } else {\n      flatCoordinates.push(y, x, z);\n    }\n  }\n  return flatCoordinates;\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos_),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser_,\n    'exterior': GML3.prototype.exteriorParser_\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.GEOMETRY_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(\n      GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(\n      GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(\n      GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(\n      GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(\n      GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface_),\n    'MultiSurface': makeReplacer(\n      GML3.prototype.readMultiSurface_),\n    'Curve': makeReplacer(GML3.prototype.readCurve_),\n    'MultiCurve': makeReplacer(\n      GML3.prototype.readMultiCurve_),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.MULTICURVE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(\n      GML3.prototype.curveMemberParser_),\n    'curveMembers': makeArrayPusher(\n      GML3.prototype.curveMemberParser_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.MULTISURFACE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(\n      GML3.prototype.surfaceMemberParser_),\n    'surfaceMembers': makeArrayPusher(\n      GML3.prototype.surfaceMemberParser_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.CURVEMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(\n      GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.SURFACEMEMBER_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.SURFACE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.CURVE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.ENVELOPE_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(\n      GML3.prototype.readFlatPosList_),\n    'upperCorner': makeArrayPusher(\n      GML3.prototype.readFlatPosList_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.PATCHES_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(\n      GML3.prototype.readPolygonPatch_)\n  }\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n * @private\n */\nGML3.prototype.SEGMENTS_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeReplacer(\n      GML3.prototype.readLineStringSegment_)\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Point} value Point geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writePos_ = function(node, value, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsDimension = hasZ ? 3 : 2;\n  node.setAttribute('srsDimension', srsDimension);\n  const srsName = context['srsName'];\n  let axisOrientation = 'enu';\n  if (srsName) {\n    axisOrientation = getProjection(srsName).getAxisOrientation();\n  }\n  const point = value.getCoordinates();\n  let coords;\n  // only 2d for simple features profile\n  if (axisOrientation.substr(0, 2) === 'en') {\n    coords = (point[0] + ' ' + point[1]);\n  } else {\n    coords = (point[1] + ' ' + point[0]);\n  }\n  if (hasZ) {\n    // For newly created points, Z can be undefined.\n    const z = point[2] || 0;\n    coords += ' ' + z;\n  }\n  writeStringTextNode(node, coords);\n};\n\n\n/**\n * @param {Array.<number>} point Point geometry.\n * @param {string=} opt_srsName Optional srsName\n * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\n * @return {string} The coords string.\n * @private\n */\nGML3.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {\n  let axisOrientation = 'enu';\n  if (opt_srsName) {\n    axisOrientation = getProjection(opt_srsName).getAxisOrientation();\n  }\n  let coords = ((axisOrientation.substr(0, 2) === 'en') ?\n    point[0] + ' ' + point[1] :\n    point[1] + ' ' + point[0]);\n  if (opt_hasZ) {\n    // For newly created points, Z can be undefined.\n    const z = point[2] || 0;\n    coords += ' ' + z;\n  }\n\n  return coords;\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LineString|module:ol/geom/LinearRing} value Geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writePosList_ = function(node, value, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsDimension = hasZ ? 3 : 2;\n  node.setAttribute('srsDimension', srsDimension);\n  const srsName = context['srsName'];\n  // only 2d for simple features profile\n  const points = value.getCoordinates();\n  const len = points.length;\n  const parts = new Array(len);\n  let point;\n  for (let i = 0; i < len; ++i) {\n    point = points[i];\n    parts[i] = this.getCoords_(point, srsName, hasZ);\n  }\n  writeStringTextNode(node, parts.join(' '));\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Point} geometry Point geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writePoint_ = function(node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const srsName = context['srsName'];\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  const pos = createElementNS(node.namespaceURI, 'pos');\n  node.appendChild(pos);\n  this.writePos_(pos, geometry, objectStack);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/extent~Extent} extent Extent.\n * @param {Array.<*>} objectStack Node stack.\n */\nGML3.prototype.writeEnvelope = function(node, extent, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const srsName = context['srsName'];\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  const keys = ['lowerCorner', 'upperCorner'];\n  const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n  pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */\n    ({node: node}), this.ENVELOPE_SERIALIZERS_,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack, keys, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LinearRing} geometry LinearRing geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeLinearRing_ = function(node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const srsName = context['srsName'];\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  const posList = createElementNS(node.namespaceURI, 'posList');\n  node.appendChild(posList);\n  this.writePosList_(posList, geometry, objectStack);\n};\n\n\n/**\n * @param {*} value Value.\n * @param {Array.<*>} objectStack Object stack.\n * @param {string=} opt_nodeName Node name.\n * @return {Node} Node.\n * @private\n */\nGML3.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n  const context = objectStack[objectStack.length - 1];\n  const parentNode = context.node;\n  const exteriorWritten = context['exteriorWritten'];\n  if (exteriorWritten === undefined) {\n    context['exteriorWritten'] = true;\n  }\n  return createElementNS(parentNode.namespaceURI,\n    exteriorWritten !== undefined ? 'interior' : 'exterior');\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Polygon} geometry Polygon geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeSurfaceOrPolygon_ = function(node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName'];\n  if (node.nodeName !== 'PolygonPatch' && srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n    const rings = geometry.getLinearRings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.RING_SERIALIZERS_,\n      this.RING_NODE_FACTORY_,\n      rings, objectStack, undefined, this);\n  } else if (node.nodeName === 'Surface') {\n    const patches = createElementNS(node.namespaceURI, 'patches');\n    node.appendChild(patches);\n    this.writeSurfacePatches_(\n      patches, geometry, objectStack);\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LineString} geometry LineString geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeCurveOrLineString_ = function(node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const srsName = context['srsName'];\n  if (node.nodeName !== 'LineStringSegment' && srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment') {\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  } else if (node.nodeName === 'Curve') {\n    const segments = createElementNS(node.namespaceURI, 'segments');\n    node.appendChild(segments);\n    this.writeCurveSegments_(segments,\n      geometry, objectStack);\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/MultiPolygon} geometry MultiPolygon geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeMultiSurfaceOrPolygon_ = function(node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName'];\n  const surface = context['surface'];\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  const polygons = geometry.getPolygons();\n  pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n    this.SURFACEORPOLYGONMEMBER_SERIALIZERS_,\n    this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons,\n    objectStack, undefined, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/MultiPoint} geometry MultiPoint geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeMultiPoint_ = function(node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const srsName = context['srsName'];\n  const hasZ = context['hasZ'];\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  const points = geometry.getPoints();\n  pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName},\n    this.POINTMEMBER_SERIALIZERS_,\n    makeSimpleNodeFactory('pointMember'), points,\n    objectStack, undefined, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/MultiLineString} geometry MultiLineString geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeMultiCurveOrLineString_ = function(node, geometry, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const hasZ = context['hasZ'];\n  const srsName = context['srsName'];\n  const curve = context['curve'];\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  const lines = geometry.getLineStrings();\n  pushSerializeAndPop({node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n    this.LINESTRINGORCURVEMEMBER_SERIALIZERS_,\n    this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines,\n    objectStack, undefined, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LinearRing} ring LinearRing geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeRing_ = function(node, ring, objectStack) {\n  const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n  node.appendChild(linearRing);\n  this.writeLinearRing_(linearRing, ring, objectStack);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Polygon} polygon Polygon geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeSurfaceOrPolygonMember_ = function(node, polygon, objectStack) {\n  const child = this.GEOMETRY_NODE_FACTORY_(\n    polygon, objectStack);\n  if (child) {\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Point} point Point geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writePointMember_ = function(node, point, objectStack) {\n  const child = createElementNS(node.namespaceURI, 'Point');\n  node.appendChild(child);\n  this.writePoint_(child, point, objectStack);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LineString} line LineString geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeLineStringOrCurveMember_ = function(node, line, objectStack) {\n  const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n  if (child) {\n    node.appendChild(child);\n    this.writeCurveOrLineString_(child, line, objectStack);\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Polygon} polygon Polygon geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {\n  const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n  node.appendChild(child);\n  this.writeSurfaceOrPolygon_(child, polygon, objectStack);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/LineString} line LineString geometry.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeCurveSegments_ = function(node, line, objectStack) {\n  const child = createElementNS(node.namespaceURI,\n    'LineStringSegment');\n  node.appendChild(child);\n  this.writeCurveOrLineString_(child, line, objectStack);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/geom/Geometry|module:ol/extent~Extent} geometry Geometry.\n * @param {Array.<*>} objectStack Node stack.\n */\nGML3.prototype.writeGeometryElement = function(node, geometry, objectStack) {\n  const context = /** @type {module:ol/format/Feature~WriteOptions} */ (objectStack[objectStack.length - 1]);\n  const item = assign({}, context);\n  item.node = node;\n  let value;\n  if (Array.isArray(geometry)) {\n    if (context.dataProjection) {\n      value = transformExtent(\n        geometry, context.featureProjection, context.dataProjection);\n    } else {\n      value = geometry;\n    }\n  } else {\n    value = transformWithOptions(/** @type {module:ol/geom/Geometry} */ (geometry), true, context);\n  }\n  pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */\n    (item), this.GEOMETRY_SERIALIZERS_,\n    this.GEOMETRY_NODE_FACTORY_, [value],\n    objectStack, undefined, this);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\nGML3.prototype.writeFeatureElement = function(node, feature, objectStack) {\n  const fid = feature.getId();\n  if (fid) {\n    node.setAttribute('fid', fid);\n  }\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const featureNS = context['featureNS'];\n  const geometryName = feature.getGeometryName();\n  if (!context.serializers) {\n    context.serializers = {};\n    context.serializers[featureNS] = {};\n  }\n  const properties = feature.getProperties();\n  const keys = [];\n  const values = [];\n  for (const key in properties) {\n    const value = properties[key];\n    if (value !== null) {\n      keys.push(key);\n      values.push(value);\n      if (key == geometryName || value instanceof Geometry) {\n        if (!(key in context.serializers[featureNS])) {\n          context.serializers[featureNS][key] = makeChildAppender(\n            this.writeGeometryElement, this);\n        }\n      } else {\n        if (!(key in context.serializers[featureNS])) {\n          context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n        }\n      }\n    }\n  }\n  const item = assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */\n    (item), context.serializers,\n    makeSimpleNodeFactory(undefined, featureNS),\n    values,\n    objectStack, keys);\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<module:ol/Feature>} features Features.\n * @param {Array.<*>} objectStack Node stack.\n * @private\n */\nGML3.prototype.writeFeatureMembers_ = function(node, features, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const serializers = {};\n  serializers[featureNS] = {};\n  serializers[featureNS][featureType] = makeChildAppender(\n    this.writeFeatureElement, this);\n  const item = assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */\n    (item),\n    serializers,\n    makeSimpleNodeFactory(featureType, featureNS), features,\n    objectStack);\n};\n\n\n/**\n * @const\n * @type {Object.<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember'\n};\n\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array.<*>} objectStack Object stack.\n * @param {string=} opt_nodeName Node name.\n * @return {Node|undefined} Node.\n * @private\n */\nGML3.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n  const parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS('http://www.opengis.net/gml',\n    MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n};\n\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array.<*>} objectStack Object stack.\n * @param {string=} opt_nodeName Node name.\n * @return {Node|undefined} Node.\n * @private\n */\nGML3.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {\n  const context = objectStack[objectStack.length - 1];\n  const multiSurface = context['multiSurface'];\n  const surface = context['surface'];\n  const curve = context['curve'];\n  const multiCurve = context['multiCurve'];\n  let nodeName;\n  if (!Array.isArray(value)) {\n    nodeName = /** @type {module:ol/geom/Geometry} */ (value).getType();\n    if (nodeName === 'MultiPolygon' && multiSurface === true) {\n      nodeName = 'MultiSurface';\n    } else if (nodeName === 'Polygon' && surface === true) {\n      nodeName = 'Surface';\n    } else if (nodeName === 'LineString' && curve === true) {\n      nodeName = 'Curve';\n    } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n      nodeName = 'MultiCurve';\n    }\n  } else {\n    nodeName = 'Envelope';\n  }\n  return createElementNS('http://www.opengis.net/gml',\n    nodeName);\n};\n\n\n/**\n * Encode a geometry in GML 3.1.1 Simple Features.\n *\n * @param {module:ol/geom/Geometry} geometry Geometry.\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Options.\n * @return {Node} Node.\n * @override\n * @api\n */\nGML3.prototype.writeGeometryNode = function(geometry, opt_options) {\n  opt_options = this.adaptOptions(opt_options);\n  const geom = createElementNS('http://www.opengis.net/gml', 'geom');\n  const context = {node: geom, hasZ: this.hasZ, srsName: this.srsName,\n    curve: this.curve_, surface: this.surface_,\n    multiSurface: this.multiSurface_, multiCurve: this.multiCurve_};\n  if (opt_options) {\n    assign(context, opt_options);\n  }\n  this.writeGeometryElement(geom, geometry, [context]);\n  return geom;\n};\n\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array.<module:ol/Feature>} features Features.\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n\n/**\n * Encode an array of features in the GML 3.1.1 format as an XML node.\n *\n * @param {Array.<module:ol/Feature>} features Features.\n * @param {module:ol/format/Feature~WriteOptions=} opt_options Options.\n * @return {Node} Node.\n * @override\n * @api\n */\nGML3.prototype.writeFeaturesNode = function(features, opt_options) {\n  opt_options = this.adaptOptions(opt_options);\n  const node = createElementNS('http://www.opengis.net/gml', 'featureMembers');\n  node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation);\n  const context = {\n    srsName: this.srsName,\n    hasZ: this.hasZ,\n    curve: this.curve_,\n    surface: this.surface_,\n    multiSurface: this.multiSurface_,\n    multiCurve: this.multiCurve_,\n    featureNS: this.featureNS,\n    featureType: this.featureType\n  };\n  if (opt_options) {\n    assign(context, opt_options);\n  }\n  this.writeFeatureMembers_(node, features, [context]);\n  return node;\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.RING_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing_),\n    'interior': makeChildAppender(GML3.prototype.writeRing_)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.ENVELOPE_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember_),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember_)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(\n      GML3.prototype.writePointMember_)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember_),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember_)\n  }\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n * @private\n */\nGML3.prototype.GEOMETRY_SERIALIZERS_ = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(\n      GML3.prototype.writeCurveOrLineString_),\n    'MultiCurve': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString_),\n    'Point': makeChildAppender(GML3.prototype.writePoint_),\n    'MultiPoint': makeChildAppender(\n      GML3.prototype.writeMultiPoint_),\n    'LineString': makeChildAppender(\n      GML3.prototype.writeCurveOrLineString_),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString_),\n    'LinearRing': makeChildAppender(\n      GML3.prototype.writeLinearRing_),\n    'Polygon': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygon_),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon_),\n    'Surface': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygon_),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon_),\n    'Envelope': makeChildAppender(\n      GML3.prototype.writeEnvelope)\n  }\n};\n\n\nexport default GML3;\n","/**\n * @module ol/format/WFS\n */\nimport {inherits} from '../util.js';\nimport {assert} from '../asserts.js';\nimport GML2 from '../format/GML2.js';\nimport GML3 from '../format/GML3.js';\nimport GMLBase, {GMLNS} from '../format/GMLBase.js';\nimport {and as andFilter, bbox as bboxFilter} from '../format/filter.js';\nimport XMLFeature from '../format/XMLFeature.js';\nimport {readNonNegativeIntegerString, readNonNegativeInteger, writeStringTextNode} from '../format/xsd.js';\nimport Geometry from '../geom/Geometry.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport {createElementNS, isDocument, isNode, makeArrayPusher, makeChildAppender,\n  makeObjectPropertySetter, makeSimpleNodeFactory, parse, parseNode,\n  pushParseAndPop, pushSerializeAndPop, XML_SCHEMA_INSTANCE_URI} from '../xml.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {Object.<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array.<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {module:ol/format/GMLBase} [gmlFormat] The GML format to use to parse the response. Default is `ol/format/GML3`.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n */\n\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array.<string>} featureTypes The feature type names.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array.<string>} [propertyNames] Optional list of property names to serialize.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {module:ol/extent~Extent} [bbox] Extent to use for the BBOX filter.\n * @property {module:ol/format/filter/Filter} [filter] Filter condition. See\n * {@link module:ol/format/Filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array.<Object>} nativeElements Native elements. Currently not supported.\n * @property {module:ol/format/GMLBase~Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0` or `1.1.0`.\n */\n\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures\n * @property {module:ol/extent~Extent} bounds\n */\n\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted\n * @property {number} totalInserted\n * @property {number} totalUpdated\n * @property {Array.<string>} insertIds\n */\n\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n\n/**\n * @type {string}\n */\nconst OGCNS = 'http://www.opengis.net/ogc';\n\n\n/**\n * @type {string}\n */\nconst WFSNS = 'http://www.opengis.net/wfs';\n\n\n/**\n * @type {string}\n */\nconst FESNS = 'http://www.opengis.net/fes';\n\n\n/**\n * @type {Object.<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n};\n\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @constructor\n * @param {module:ol/format/WFS~Options=} opt_options Optional configuration object.\n * @extends {module:ol/format/XMLFeature}\n * @api\n */\nconst WFS = function(opt_options) {\n  const options = opt_options ? opt_options : {};\n\n  /**\n   * @private\n   * @type {Array.<string>|string|undefined}\n   */\n  this.featureType_ = options.featureType;\n\n  /**\n   * @private\n   * @type {Object.<string, string>|string|undefined}\n   */\n  this.featureNS_ = options.featureNS;\n\n  /**\n   * @private\n   * @type {module:ol/format/GMLBase}\n   */\n  this.gmlFormat_ = options.gmlFormat ?\n    options.gmlFormat : new GML3();\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this.schemaLocation_ = options.schemaLocation ?\n    options.schemaLocation : SCHEMA_LOCATIONS[DEFAULT_VERSION];\n\n  XMLFeature.call(this);\n};\n\ninherits(WFS, XMLFeature);\n\n\n/**\n * @return {Array.<string>|string|undefined} featureType\n */\nWFS.prototype.getFeatureType = function() {\n  return this.featureType_;\n};\n\n\n/**\n * @param {Array.<string>|string|undefined} featureType Feature type(s) to parse.\n */\nWFS.prototype.setFeatureType = function(featureType) {\n  this.featureType_ = featureType;\n};\n\n\n/**\n * Read all features from a WFS FeatureCollection.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @param {module:ol/format/Feature~ReadOptions=} opt_options Read options.\n * @return {Array.<module:ol/Feature>} Features.\n * @api\n */\nWFS.prototype.readFeatures;\n\n\n/**\n * @inheritDoc\n */\nWFS.prototype.readFeaturesFromNode = function(node, opt_options) {\n  const context = /** @type {module:ol/xml~NodeStackItem} */ ({\n    'featureType': this.featureType_,\n    'featureNS': this.featureNS_\n  });\n  assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n  const objectStack = [context];\n  this.gmlFormat_.FEATURE_COLLECTION_PARSERS[GMLNS][\n    'featureMember'] =\n      makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n  let features = pushParseAndPop([],\n    this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node,\n    objectStack, this.gmlFormat_);\n  if (!features) {\n    features = [];\n  }\n  return features;\n};\n\n\n/**\n * Read transaction response of the source.\n *\n * @param {Document|Node|Object|string} source Source.\n * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n * @api\n */\nWFS.prototype.readTransactionResponse = function(source) {\n  if (isDocument(source)) {\n    return this.readTransactionResponseFromDocument(\n      /** @type {Document} */ (source));\n  } else if (isNode(source)) {\n    return this.readTransactionResponseFromNode(/** @type {Node} */ (source));\n  } else if (typeof source === 'string') {\n    const doc = parse(source);\n    return this.readTransactionResponseFromDocument(doc);\n  } else {\n    return undefined;\n  }\n};\n\n\n/**\n * Read feature collection metadata of the source.\n *\n * @param {Document|Node|Object|string} source Source.\n * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n *     FeatureCollection metadata.\n * @api\n */\nWFS.prototype.readFeatureCollectionMetadata = function(source) {\n  if (isDocument(source)) {\n    return this.readFeatureCollectionMetadataFromDocument(\n      /** @type {Document} */ (source));\n  } else if (isNode(source)) {\n    return this.readFeatureCollectionMetadataFromNode(\n      /** @type {Node} */ (source));\n  } else if (typeof source === 'string') {\n    const doc = parse(source);\n    return this.readFeatureCollectionMetadataFromDocument(doc);\n  } else {\n    return undefined;\n  }\n};\n\n\n/**\n * @param {Document} doc Document.\n * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n *     FeatureCollection metadata.\n */\nWFS.prototype.readFeatureCollectionMetadataFromDocument = function(doc) {\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readFeatureCollectionMetadataFromNode(n);\n    }\n  }\n  return undefined;\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readGeometryElement, 'bounds')\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @return {module:ol/format/WFS~FeatureCollectionMetadata|undefined}\n *     FeatureCollection metadata.\n */\nWFS.prototype.readFeatureCollectionMetadataFromNode = function(node) {\n  const result = {};\n  const value = readNonNegativeIntegerString(\n    node.getAttribute('numberOfFeatures'));\n  result['numberOfFeatures'] = value;\n  return pushParseAndPop(\n    /** @type {module:ol/format/WFS~FeatureCollectionMetadata} */ (result),\n    FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);\n};\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger)\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop(\n    {}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function(node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<*>} objectStack Object stack.\n * @return {Array.<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop(\n    [], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n\n/**\n * @const\n * @type {Object.<string, Object.<string, module:ol/xml~Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(\n      readInsertResults, 'insertIds')\n  }\n};\n\n\n/**\n * @param {Document} doc Document.\n * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n */\nWFS.prototype.readTransactionResponseFromDocument = function(doc) {\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readTransactionResponseFromNode(n);\n    }\n  }\n  return undefined;\n};\n\n\n/**\n * @param {Node} node Node.\n * @return {module:ol/format/WFS~TransactionResponse|undefined} Transaction response.\n */\nWFS.prototype.readTransactionResponseFromNode = function(node) {\n  return pushParseAndPop(\n    /** @type {module:ol/format/WFS~TransactionResponse} */({}),\n    TRANSACTION_RESPONSE_PARSERS, node, []);\n};\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const filter = createElementNS(OGCNS, 'Filter');\n  const child = createElementNS(OGCNS, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', fid);\n  node.appendChild(filter);\n}\n\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @returns {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/Feature} feature Feature.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (value instanceof Geometry) {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(/** @type {module:ol/xml~NodeStackItem} */ (\n      {'gmlVersion': context['gmlVersion'], node: node,\n        'hasZ': context['hasZ'], 'srsName': context['srsName']}),\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory('Property'), values,\n    objectStack);\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const name = createElementNS(WFSNS, 'Name');\n  const context = objectStack[objectStack.length - 1];\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(WFSNS, 'Value');\n    node.appendChild(value);\n    if (pair.value instanceof Geometry) {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value,\n          pair.value, objectStack);\n      } else {\n        GML3.prototype.writeGeometryElement(value,\n          pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}}\n *     nativeElement The native element.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', nativeElement.safeToIgnore);\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n\n/**\n * @type {Object.<string, Object.<string, module:ol/xml~Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeContainsFilter),\n    'Intersects': makeChildAppender(writeIntersectsFilter),\n    'Within': makeChildAppender(writeWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  }\n};\n\n\n/**\n * @param {Node} node Node.\n * @param {string} featureType Feature type.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  node.setAttribute('typeName', typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {module:ol/xml~NodeStackItem} */ (assign({}, context));\n  item.node = node;\n  pushSerializeAndPop(item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'), propertyNames,\n    objectStack);\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(OGCNS, 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Filter} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {node: node};\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter], objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Bbox} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Contains} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeContainsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Intersects} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeIntersectsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Within} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeWithinFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/During} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n\n  const valueReference = createElementNS(FESNS, 'ValueReference');\n  writeStringTextNode(valueReference, filter.propertyName);\n  node.appendChild(valueReference);\n\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/LogicalNary} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {node: node};\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition], objectStack);\n  }\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/Not} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  /** @type {module:ol/xml~NodeStackItem} */\n  const item = {node: node};\n  const condition = filter.condition;\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition], objectStack);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/ComparisonBinary} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.expression);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsNull} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsBetween} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(OGCNS, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeOgcLiteral(lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(OGCNS, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeOgcLiteral(upperBoundary, '' + filter.upperBoundary);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {module:ol/format/filter/IsLike} filter Filter.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.pattern);\n}\n\n\n/**\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeOgcExpression(tagName, node, value) {\n  const property = createElementNS(OGCNS, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcPropertyName(node, value) {\n  writeOgcExpression('PropertyName', node, value);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcLiteral(node, value) {\n  writeOgcExpression('Literal', node, value);\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {module:ol/format/filter/Filter} filter Filter.\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter) {\n  const child = createElementNS(OGCNS, 'Filter');\n  writeFilterCondition(child, filter, []);\n  return child;\n}\n\n\n/**\n * @param {Node} node Node.\n * @param {Array.<string>} featureTypes Feature types.\n * @param {Array.<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {module:ol/xml~NodeStackItem} */ (assign({}, context));\n  item.node = node;\n  pushSerializeAndPop(item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'), featureTypes,\n    objectStack);\n}\n\n\n/**\n * Encode format as WFS `GetFeature` and return the Node.\n *\n * @param {module:ol/format/WFS~WriteGetFeatureOptions} options Options.\n * @return {Node} Result.\n * @api\n */\nWFS.prototype.writeGetFeature = function(options) {\n  const node = createElementNS(WFSNS, 'GetFeature');\n  node.setAttribute('service', 'WFS');\n  node.setAttribute('version', '1.1.0');\n  let filter;\n  if (options) {\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n    if (options.outputFormat) {\n      node.setAttribute('outputFormat', options.outputFormat);\n    }\n    if (options.maxFeatures !== undefined) {\n      node.setAttribute('maxFeatures', options.maxFeatures);\n    }\n    if (options.resultType) {\n      node.setAttribute('resultType', options.resultType);\n    }\n    if (options.startIndex !== undefined) {\n      node.setAttribute('startIndex', options.startIndex);\n    }\n    if (options.count !== undefined) {\n      node.setAttribute('count', options.count);\n    }\n    filter = options.filter;\n    if (options.bbox) {\n      assert(options.geometryName,\n        12); // `options.geometryName` must also be provided when `options.bbox` is set\n      const bbox = bboxFilter(\n        /** @type {string} */ (options.geometryName), options.bbox, options.srsName);\n      if (filter) {\n        // if bbox and filter are both set, combine the two into a single filter\n        filter = andFilter(filter, bbox);\n      } else {\n        filter = bbox;\n      }\n    }\n  }\n  node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);\n  /** @type {module:ol/xml~NodeStackItem} */\n  const context = {\n    node: node,\n    'srsName': options.srsName,\n    'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n    'featurePrefix': options.featurePrefix,\n    'geometryName': options.geometryName,\n    'filter': filter,\n    'propertyNames': options.propertyNames ? options.propertyNames : []\n  };\n  assert(Array.isArray(options.featureTypes),\n    11); // `options.featureTypes` should be an Array\n  writeGetFeature(node, /** @type {!Array.<string>} */ (options.featureTypes), [context]);\n  return node;\n};\n\n\n/**\n * Encode format as WFS `Transaction` and return the Node.\n *\n * @param {Array.<module:ol/Feature>} inserts The features to insert.\n * @param {Array.<module:ol/Feature>} updates The features to update.\n * @param {Array.<module:ol/Feature>} deletes The features to delete.\n * @param {module:ol/format/WFS~WriteTransactionOptions} options Write options.\n * @return {Node} Result.\n * @api\n */\nWFS.prototype.writeTransaction = function(inserts, updates, deletes, options) {\n  const objectStack = [];\n  const node = createElementNS(WFSNS, 'Transaction');\n  const version = options.version ? options.version : DEFAULT_VERSION;\n  const gmlVersion = version === '1.0.0' ? 2 : 3;\n  node.setAttribute('service', 'WFS');\n  node.setAttribute('version', version);\n  let baseObj;\n  /** @type {module:ol/xml~NodeStackItem} */\n  let obj;\n  if (options) {\n    baseObj = options.gmlOptions ? options.gmlOptions : {};\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n  }\n  const schemaLocation = SCHEMA_LOCATIONS[version];\n  node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', schemaLocation);\n  const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n  if (inserts) {\n    obj = {node: node, 'featureNS': options.featureNS,\n      'featureType': options.featureType, 'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName};\n    assign(obj, baseObj);\n    pushSerializeAndPop(obj,\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Insert'), inserts,\n      objectStack);\n  }\n  if (updates) {\n    obj = {node: node, 'featureNS': options.featureNS,\n      'featureType': options.featureType, 'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion, 'hasZ': options.hasZ, 'srsName': options.srsName};\n    assign(obj, baseObj);\n    pushSerializeAndPop(obj,\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Update'), updates,\n      objectStack);\n  }\n  if (deletes) {\n    pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n      'featureType': options.featureType, 'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion, 'srsName': options.srsName},\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory('Delete'), deletes,\n    objectStack);\n  }\n  if (options.nativeElements) {\n    pushSerializeAndPop({node: node, 'featureNS': options.featureNS,\n      'featureType': options.featureType, 'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion, 'srsName': options.srsName},\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory('Native'), options.nativeElements,\n    objectStack);\n  }\n  return node;\n};\n\n\n/**\n * Read the projection from a WFS source.\n *\n * @function\n * @param {Document|Node|Object|string} source Source.\n * @return {?module:ol/proj/Projection} Projection.\n * @api\n */\nWFS.prototype.readProjection;\n\n\n/**\n * @inheritDoc\n */\nWFS.prototype.readProjectionFromDocument = function(doc) {\n  for (let n = doc.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType == Node.ELEMENT_NODE) {\n      return this.readProjectionFromNode(n);\n    }\n  }\n  return null;\n};\n\n\n/**\n * @inheritDoc\n */\nWFS.prototype.readProjectionFromNode = function(node) {\n  if (node.firstElementChild &&\n      node.firstElementChild.firstElementChild) {\n    node = node.firstElementChild.firstElementChild;\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (!(n.childNodes.length === 0 ||\n          (n.childNodes.length === 1 &&\n          n.firstChild.nodeType === 3))) {\n        const objectStack = [{}];\n        this.gmlFormat_.readGeometryElement(n, objectStack);\n        return getProjection(objectStack.pop().srsName);\n      }\n    }\n  }\n\n  return null;\n};\nexport default WFS;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {\n  equalTo as equalToFilter,\n  like as likeFilter,\n  and as andFilter\n} from '../src/ol/format/filter.js';\nimport {WFS, GeoJSON} from '../src/ol/format.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\nimport BingMaps from '../src/ol/source/BingMaps.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport {Stroke, Style} from '../src/ol/style.js';\n\n\nconst vectorSource = new VectorSource();\nconst vector = new VectorLayer({\n  source: vectorSource,\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(0, 0, 255, 1.0)',\n      width: 2\n    })\n  })\n});\n\nconst raster = new TileLayer({\n  source: new BingMaps({\n    imagerySet: 'Aerial',\n    key: 'As1HiMj1PvLPlqc_gtM7AqZfBL8ZL3VrjaS3zIb22Uvb9WKhuJObROC-qUpa81U5'\n  })\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [-8908887.277395891, 5381918.072437216],\n    maxZoom: 19,\n    zoom: 12\n  })\n});\n\n// generate a GetFeature request\nconst featureRequest = new WFS().writeGetFeature({\n  srsName: 'EPSG:3857',\n  featureNS: 'http://openstreemap.org',\n  featurePrefix: 'osm',\n  featureTypes: ['water_areas'],\n  outputFormat: 'application/json',\n  filter: andFilter(\n    likeFilter('name', 'Mississippi*'),\n    equalToFilter('waterway', 'riverbank')\n  )\n});\n\n// then post the request and add the received features to a layer\nfetch('https://ahocevar.com/geoserver/wfs', {\n  method: 'POST',\n  body: new XMLSerializer().serializeToString(featureRequest)\n}).then(function(response) {\n  return response.json();\n}).then(function(json) {\n  const features = new GeoJSON().readFeatures(json);\n  vectorSource.addFeatures(features);\n  map.getView().fit(vectorSource.getExtent());\n});\n"],"sourceRoot":""}